var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"equations/time/#Time-discretization","page":"Time discretization","title":"Time discretization","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"The spatially discretized Navier-Stokes equations form a differential-algebraic system, with an ODE for the velocity","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Omega_h fracmathrmd u_hmathrmd t = F(u_h t) - (G p_h + y_G)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"subject to the algebraic constraint formed by the mass equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"M u_h + y_M = 0","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"In the end of the previous section, we differentiated the mass equation in time to obtain a discrete pressure Poisson equation. This equation includes the term fracmathrmd y_Mmathrmd t, which is non-zero if an unsteady flow of mass is added to the domain (Dirichlet boundary conditions). This term ensures that the time-continuous discrete velocity field u_h(t) stays divergence free (conserves mass). However, if we directly discretize this system in time, the mass preservation may actually not be respected. For this, we will change the definition of the pressure such that the time-discretized velocity field is divergence free at each time step and each time sub-step (to be defined in the following).","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the interval 0 T for some simulation time T. We will divide it into N sub-intervals t^n t^n + 1 for n = 0 dots N - 1, with t^0 = 0, t^N = T, and increment Delta t^n = t^n + 1 - t^n. We define U^n approx u_h(t^n) as an approximation to the exact discrete velocity field u_h(t^n), with U^0 = u_h(0) starting from the exact initial conditions. We say that the time integration scheme (definition of U^n) is accurate to the order r if U^n = u_h(t^n) + mathcalO(Delta t^r) for all n.","category":"page"},{"location":"equations/time/#Explicit-Runge-Kutta-methods","page":"Time discretization","title":"Explicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [5].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the velocity field U_0 at a certain time t_0. We will now perform one time step to t = t_0 + Delta t. For explicit Runge-Kutta methods, this time step is divided into s sub-steps t_i = t_0 + Delta t_i with increment Delta t_i = c_i Delta t. The final substep performs the full time step Delta t_s = Delta t such that t_s = t.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"For i = 1 dots s, the intermediate velocity U_i and pressure P_i are computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nF_i  = Omega_h^-1 F(U_i - 1 t_i - 1) \nV_i  = U_0 + Delta t sum_j = 1^i a_i j F_j \nL P_i  = frac(M V_i + y_M(t_i)) - (M U_0 + y_M(t_0))Delta t_i^n \n = frac1c_i sum_j = 1^i a_i j F_j +\nfracy_M(t_i) - y_M(t_0)Delta t_i \nU_i  = V_i - Delta t_i Omega_h^-1 (G P_i + y_G(t_i))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where (a_i j)_i j are the Butcher tableau coefficients of the RK-method, with the convention c_i = sum_j = 1^i a_i j.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, we set U = U_s. If U_0 = u_h(t_0), we get the accuracy U = u_h(t) + mathcalO(Delta t^r + 1), where r is the order of the RK-method. If we perform n RK time steps instead of one, starting at exact initial conditions U^0 = u_h(0), then U^n = u_h(t^n) + mathcalO(Delta t^r) for all n in 1 dots N. Note that for a given U, the corresponding pressure P can be calculated to the same accuracy as U by doing an additional pressure projection after each outer time step Delta t (if we know fracmathrmd y_Mmathrmd t(t)), or to first order accuracy by simply taking P = P_s.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Note that each of the sub-step velocities U_i is divergence free, after projecting the tentative velocities V_i. This is ensured due to the judiciously chosen replacement of fracmathrmd y_Mmathrmd t(t_i) with (y_M(t_i) - y_M(t_0))  Delta t_i. The space-discrete divergence-freeness is thus perfectly preserved, even though the time discretization introduces other errors.","category":"page"},{"location":"equations/time/#Implicit-Runge-Kutta-methods","page":"Time discretization","title":"Implicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [6].","category":"page"},{"location":"equations/time/#Adams-Bashforth-Crank-Nicolson-method","page":"Time discretization","title":"Adams-Bashforth Crank-Nicolson method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. This methods uses Adams-Bashforth for the convective terms and Crank-Nicolson stepping for the diffusion and body force terms. Given the velocity field U_0 = u_h(t_0) at a time t_0 and its previous value U_-1 = u_h(t_0 - Delta t) at the previous time t_-1 = t_0 - Delta t, the predicted velocity field U at the time t = t_0 + Delta t is defined by first computing a tentative velocity:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nfracV - U_0Delta t\n = - (alpha_0 C(U_0 t_0) + alpha_-1 C(U_-1 t_-1)) \n + theta (D U_0 + y_D(t_0)) + (1 - theta) (D V + y_D(t)) \n + theta f(t_0) + (1 - theta) f(t) \n - (G p_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where theta in 0 1 is the Crank-Nicolson parameter (theta = frac12 for second order convergence), (alpha_0 alpha_-1) = left( frac32 -frac12 right) are the Adams-Bashforth coefficients, and V is a tentative velocity yet to be made divergence free. We can group the terms containing V on the left hand side, to obtain","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nleft( frac1Delta t I - theta D right) V\n = left(frac1Delta t I - (1 - theta) D right) U_0 \n - (alpha_0 C(U_0 t_0) + alpha_-1 C(U_-1 t_-1)) \n + theta y_D(t_0) + (1 - theta) y_D(t) \n + theta f(t_0) + (1 - theta) f(t) \n - (G P_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We can compute V by inverting the positive definite matrix left( frac1Delta t I - theta D right) for the given right hand side using a suitable linear solver. Assuming Delta t is constant, we can precompute a Cholesky factorization of this matrix before starting time stepping.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We then compute the pressure difference Delta P by solving","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta P = fracM V + y_M(t)Delta t - M (y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"after which a divergence free velocity U can be enforced:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"U = V - Delta t Omega_h^-1 (G Delta P + y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A first order accurate prediction of the corresponding pressure is P = P_0 + Delta P. However, since this pressure is reused in the next time step, we perform an additional pressure solve to avoid accumulating first order errors. The resulting pressure P is then accurate to the same order as U.","category":"page"},{"location":"equations/time/#One-leg-beta-method","page":"Time discretization","title":"One-leg beta method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Verstappen and Veldman [8] [9].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. Given the velocity U_0 and pressure P_0 at the current time t_0 and their previous values U_-1 and P_-1 at the time t_-1 = t_0 - Delta t, we start by computing the \"offstep\" values V = (1 + beta) V_0 - beta V_-1 and Q = (1 + beta) P_0 - beta P_-1 for some beta = frac12.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A tentative velocity field W is then computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"W = frac1beta + frac12 left( 2 beta U_0 - left( beta -\nfrac12 right) U_-1 + Delta t Omega_h^-1 F(V t) - Delta t\nOmega_h^-1 (G Q + y_G(t)) right)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A pressure correction Delta P is obtained by solving the Poisson equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta P = fracbeta + frac12Delta t (M W + y_M(t))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, the divergence free velocity field is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"U = W - fracDelta tbeta + frac12 Omega_h^-1 G Delta P","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"while the second order accurate pressure is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"P = 2 P_0 - P_-1 + frac43 Delta P","category":"page"},{"location":"features/gpu/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"If an Nvidia GPU is available, the default CPU solve call","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"solve_unsteady(setup, V₀, p₀, tlims; kwargs...)","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"can now be replaced with the following:","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\nsolve_unsteady(\n    setup, V₀, p₀, tlims;\n    device = cu,\n    kwargs...\n)","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"This moves the arrays and sparse operators to the GPU, outsourcing all array operations to the GPU.","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"Limitations:","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"DirectPressureSolver is currently not supported on the GPU. Use CGPressureSolver instead.\nUnsteady boundary conditions are currently not supported on the GPU.\nThe code uses sparse matrices for discretization. For finer grids, these can take up a lot of memory on the GPU.\nThis has not been tested with other GPU interfaces, such as\nAMDGPU.jl\nMetal.jl\noneAPI.jl\nIf they start supporting sparse matrices and fast Fourier transforms they could also be used. Alternatively, IncompressibleNavierStokes may also be refactored to apply the operators without assembling any sparse arrays.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"EditURL = \"../../../examples/LidDrivenCavity2D.jl\"","category":"page"},{"location":"generated/LidDrivenCavity2D/#Tutorial:-Lid-Driven-Cavity-2D","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity - 2D","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In this example we consider a box with a moving lid. The velocity is initially at rest. The solution should reach at steady state equilibrium after a certain time. The same steady state should be obtained when solving a steady state problem.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"name = \"LidDrivenCavity2D\"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The code allows for using different floating point number types, including single precision (Float32) and double precision (Float64). On the CPU, the speed is not really different, but double precision uses twice as much memory as single precision. When running on the GPU, single precision is preferred. Half precision (Float16) is also an option, but then the values should be scaled judiciously to avoid vanishing digits when applying differential operators of the form \"right minus left divided by small distance\".","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# T = Float16\n# T = Float32\nT = Float64","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Note how floating point type hygiene is enforced in the following using T to avoid mixing different precisions.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can also choose to do the computations on a different device. By default, the computations are performed on the host (CPU). An optional device keyword allows for moving arrays and operator to a different device such as a GPU. Currently, only Nvidia GPUs with CUDA support sparse operators and fast Fourier transform used by IncompressibleNavierStokes.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"For CPU","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"device = identity","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"For GPU (note that cu converts to Float32)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# using CUDA\n# device = cu","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Here we choose a moderate Reynolds number. Note how we pass the floating point type.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Re = T(1_000)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Dirichlet boundary conditions are specified as plain Julia functions. They are marked by the :dirichlet symbol. Other possible BC types are :periodic, :symmetric, and :pressure.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"u_bc(x, y, t) = y ≈ 1 ? T(1) : T(0)\nv_bc(x, y, t) = T(0)\nbc_type = (;\n    u = (; x = (:dirichlet, :dirichlet), y = (:dirichlet, :dirichlet)),\n    v = (; x = (:dirichlet, :dirichlet), y = (:dirichlet, :dirichlet)),\n)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We create a two-dimensional domain with a box of size [1, 1]. The grid is created as a Cartesian product between two vectors. We add a refinement near the walls.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"n = 40\nlims = (T(0), T(1))\nx = cosine_grid(lims..., n)\ny = cosine_grid(lims..., n)\nplot_grid(x, y)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can now build the setup and assemble operators. A 3D setup is built if we also provide a vector of z-coordinates.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"setup = Setup(x, y; Re, u_bc, v_bc, bc_type);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The pressure solver is used to solve the pressure Poisson equation. Available solvers are","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"DirectPressureSolver (only for CPU with Float64)\nCGPressureSolver\nSpectralPressureSolver (only for periodic boundary conditions and uniform grids)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"pressure_solver = DirectPressureSolver(setup)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We will solve for a time interval of ten seconds.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"t_start, t_end = tlims = (T(0), T(10))","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The initial conditions are defined as plain Julia functions.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"initial_velocity_u(x, y) = zero(x)\ninitial_velocity_v(x, y) = zero(x)\ninitial_pressure(x, y) = zero(x)\nV₀, p₀ = create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    t_start;\n    initial_pressure,\n    pressure_solver,\n)","category":"page"},{"location":"generated/LidDrivenCavity2D/#Solve-problems","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Solve problems","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Problems can be solved.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The solve_steady_state function is for computing a state where the right hand side of the momentum equation is zero.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"V, p = solve_steady_state(setup, V₀, p₀)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"For this test case, the same steady state may be obtained by solving an unsteady problem for a sufficiently long time.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Iteration processors are called after every nupdate time steps. This can be useful for logging, plotting, or saving results. Their respective outputs are later returned by solve_unsteady.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"processors = (\n    field_plotter(device(setup); nupdate = 50),\n    # energy_history_plotter(device(setup); nupdate = 1),\n    # energy_spectrum_plotter(device(setup); nupdate = 100),\n    # animator(device(setup), \"vorticity.mkv\"; nupdate = 4),\n    vtk_writer(setup; nupdate = 100, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 1000),\n);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"By default, a standard fourth order Runge-Kutta method is used. If we don't provide the time step explicitly, an adaptive time step is used.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"V, p, outputs =\n    solve_unsteady(setup, V₀, p₀, tlims; Δt = T(0.001), processors, pressure_solver, device);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/#Post-process","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We may visualize or export the computed fields (V, p)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Export fields to VTK. The file output/solution.vti may be opened for visulization in ParaView. This is particularly useful for inspecting results from 3D simulations.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot pressure","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"plot_pressure(setup, p)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot velocity. Note the time stamp used for computing boundary conditions, if any.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"plot_velocity(setup, V, t_end)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot vorticity (with custom levels)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"levels = [-7, -5, -4, -3, -2, -1, -0.5, 0, 0.5, 1, 2, 3, 7]\nplot_vorticity(setup, V, t_end; levels)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot streamfunction. Note the time stamp used for computing boundary conditions, if any","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"plot_streamfunction(setup, V, t_end)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In addition, the tuple outputs contains quantities from our processors.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The field_plotter returns the field plot figure.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"outputs[1]","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The vtk_writer returns the file name of the ParaView collection file. This allows for visualizing the solution time series in ParaView.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"outputs[2]","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The logger returns nothing.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"outputs[3]","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"EditURL = \"../../../examples/PlanarMixing2D.jl\"","category":"page"},{"location":"generated/PlanarMixing2D/#Planar-mixing-2D","page":"Planar Mixing (2D)","title":"Planar mixing - 2D","text":"","category":"section"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Planar mixing example, as presented in [3].","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"name = \"PlanarMixing2D\"","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Viscosity model","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Re = 500.0","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Boundary conditions: Unsteady BC requires time derivatives","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"ΔU = 1.0\nŪ = 1.0\nϵ = (0.082Ū, 0.012Ū)\nn = (0.4π, 0.3π)\nω = (0.22, 0.11)\nu_bc(x, y, t) =\n    x ≈ 0.0 ?\n    1.0 + ΔU / 2 * tanh(2y) + sum(@. ϵ * (1 - tanh(y / 2)^2) * cos(n * y) * sin(ω * t)) :\n    0.0\nv_bc(x, y, t) = 0.0\ndudt_bc(x, y, t) =\n    x ≈ 0.0 ? sum(@. ϵ * (1 - tanh(y / 2)^2) * cos(n * y) * ω * cos(ω * t)) : 0.0\ndvdt_bc(x, y, t) = 0.0\nbc_type = (;\n    u = (; x = (:dirichlet, :pressure), y = (:symmetric, :symmetric)),\n    v = (; x = (:dirichlet, :symmetric), y = (:pressure, :pressure)),\n)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"n = 64\n# n = 256\nx = LinRange(0.0, 256.0, 4n)\ny = LinRange(-32.0, 32.0, n)\nplot_grid(x, y)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"setup = Setup(x, y; Re, u_bc, v_bc, dudt_bc, dvdt_bc, bc_type);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Time interval","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"t_start, t_end = tlims = (0.0, 100.0)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Initial conditions","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"initial_velocity_u(x, y) = u_bc(0.0, y, 0.0)\ninitial_velocity_v(x, y) = 0.0\ninitial_pressure(x, y) = 0.0\nV₀, p₀ = create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    t_start;\n    initial_pressure,\n);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Iteration processors","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"processors = (\n    field_plotter(setup; nupdate = 1),\n    # energy_history_plotter(setup; nupdate = 1),\n    # energy_spectrum_plotter(setup; nupdate = 100),\n    # animator(setup, \"vorticity.mkv\"; nupdate = 4),\n    # vtk_writer(setup; nupdate = 10, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 1),\n);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"V, p, outputs = solve_unsteady(\n    setup,\n    V₀,\n    p₀,\n    tlims;\n    method = RK44P2(),\n    Δt = 0.1,\n    processors,\n    inplace = true,\n);\ncurrent_figure()","category":"page"},{"location":"generated/PlanarMixing2D/#Post-process","page":"Planar Mixing (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"We may visualize or export the computed fields (V, p)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Export to VTK","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Plot pressure","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"plot_pressure(setup, p)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Plot velocity","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"plot_velocity(setup, V, t_end)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"plot_vorticity(setup, V, t_end)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Plot streamfunction","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"plot_streamfunction(setup, V, t_end)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"EditURL = \"../../../examples/BackwardFacingStep2D.jl\"","category":"page"},{"location":"generated/BackwardFacingStep2D/#Backward-Facing-Step-2D","page":"Backward Facing Step (2D)","title":"Backward Facing Step - 2D","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"In this example we consider a channel with walls at the top and bottom, and a step at the left with a parabolic inflow. Initially the velocity is an extension of the inflow, but as time passes the velocity finds a new steady state.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"name = \"BackwardFacingStep2D\"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Viscosity model","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Re = 3000.0","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Boundary conditions: steady inflow on the top half","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"u_bc(x, y, t) = x ≈ 0 && y ≥ 0 ? 24y * (1 / 2 - y) : 0.0\nv_bc(x, y, t) = 0.0\nbc_type = (;\n    u = (; x = (:dirichlet, :pressure), y = (:dirichlet, :dirichlet)),\n    v = (; x = (:dirichlet, :symmetric), y = (:dirichlet, :dirichlet)),\n)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"A 2D grid is a Cartesian product of two vectors. Here we refine the grid near the walls.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"x = LinRange(0.0, 10.0, 300)\ny = cosine_grid(-0.5, 0.5, 50)\nplot_grid(x, y)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"setup = Setup(x, y; Re, u_bc, v_bc, bc_type);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Time interval","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"t_start, t_end = tlims = (0.0, 7.0)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"initial_velocity_u(x, y) = y ≥ 0.0 ? 24y * (1 / 2 - y) : 0.0\ninitial_velocity_v(x, y) = 0.0\ninitial_pressure(x, y) = 0.0\nV₀, p₀ = create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    t_start;\n    initial_pressure,\n);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Solve steady state problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"V, p = solve_steady_state(setup, V₀, p₀);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Iteration processors","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"processors = (\n    field_plotter(setup; nupdate = 5),\n    # energy_history_plotter(setup; nupdate = 10),\n    # energy_spectrum_plotter(setup; nupdate = 10),\n    # animator(setup, \"vorticity.mkv\"; nupdate = 4),\n    # vtk_writer(setup; nupdate = 20, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 1),\n);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"V, p, outputs = solve_unsteady(setup, V₀, p₀, tlims; Δt = 0.002, processors, inplace = true)\ncurrent_figure()","category":"page"},{"location":"generated/BackwardFacingStep2D/#Post-process","page":"Backward Facing Step (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"We may visualize or export the computed fields (V, p)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Export to VTK","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Plot pressure","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"plot_pressure(setup, p)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Plot velocity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"plot_velocity(setup, V, t_end)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"plot_vorticity(setup, V, t_end)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"Plot streamfunction","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"plot_streamfunction(setup, V, t_end)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Backward Facing Step (2D)","title":"Backward Facing Step (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"EditURL = \"../../../examples/DecayingTurbulence2D.jl\"","category":"page"},{"location":"generated/DecayingTurbulence2D/#Decaying-Homogeneous-Isotropic-Turbulence-2D","page":"Decaying Turbulunce (2D)","title":"Decaying Homogeneous Isotropic Turbulence - 2D","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"In this example we consider decaying homogeneous isotropic turbulence, similar to the cases considered in [1] and [2]. The initial velocity field is created randomly, but with a specific energy spectrum. Due to viscous dissipation, the turbulent features eventually group to form larger visible eddies.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"name = \"DecayingTurbulence2D\"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Floating point precision","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"T = Float32","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"To use CPU: Do not move any arrays","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"device = identity","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"To use GPU, use cu to move arrays to the GPU. Note: cu converts to Float32","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"# using CUDA\n# device = cu","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Viscosity model","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Re = T(10_000)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"n = 256\nlims = (T(0), T(1))\nx = LinRange(lims..., n + 1)\ny = LinRange(lims..., n + 1)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"plot_grid(x, y)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"setup = Setup(x, y; Re);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Since the grid is uniform and identical for x and y, we may use a specialized spectral pressure solver","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"pressure_solver = SpectralPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Initial conditions","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"V₀, p₀ = random_field(setup; A = T(1_000_000), σ = T(30), s = 5, pressure_solver);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Iteration processors","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"processors = (\n    field_plotter(device(setup); nupdate = 20),\n    energy_history_plotter(device(setup); nupdate = 20, displayfig = false),\n    energy_spectrum_plotter(device(setup); nupdate = 20, displayfig = false),\n    # animator(device(setup), \"vorticity.mp4\"; nupdate = 16),\n    # vtk_writer(setup; nupdate = 10, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 100),\n);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Time interval","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"t_start, t_end = tlims = (T(0), T(1.0))","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"V, p, outputs = solve_unsteady(\n    setup,\n    V₀,\n    p₀,\n    tlims;\n    Δt = T(0.001),\n    processors,\n    pressure_solver,\n    inplace = true,\n    device,\n);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Field plot","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs[1]","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy history plot","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs[2]","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy spectrum plot","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs[3]","category":"page"},{"location":"generated/DecayingTurbulence2D/#Post-process","page":"Decaying Turbulunce (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"We may visualize or export the computed fields (V, p)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Export to VTK","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Plot pressure","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"plot_pressure(setup, p)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Plot velocity","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"plot_velocity(setup, V, t_end)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"plot_vorticity(setup, V, t_end)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"EditURL = \"../../../examples/ShearLayer2D.jl\"","category":"page"},{"location":"generated/ShearLayer2D/#Shear-layer-2D","page":"Shear Layer (2D)","title":"Shear layer - 2D","text":"","category":"section"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Shear layer example.","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"name = \"ShearLayer2D\"","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Viscosity model","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Re = Inf","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"n = 100\nx = LinRange(0, 2π, n + 1)\ny = LinRange(0, 2π, n + 1)\nplot_grid(x, y)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"setup = Setup(x, y; Re);\nnothing #hide","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Time interval","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"t_start, t_end = tlims = (0.0, 8.0)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Initial conditions: We add 1 to u in order to make global momentum conservation less trivial","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"d = π / 15\ne = 0.05\ninitial_velocity_u(x, y) = y ≤ π ? tanh((y - π / 2) / d) : tanh((3π / 2 - y) / d)\n# initial_velocity_u(x, y) = 1.0 + (y ≤ π ? tanh((y - π / 2) / d) : tanh((3π / 2 - y) / d))\ninitial_velocity_v(x, y) = e * sin(x)\ninitial_pressure(x, y) = 0.0\nV₀, p₀ = create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    t_start;\n    initial_pressure,\n);\nnothing #hide","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Iteration processors","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"processors = (\n    field_plotter(setup; nupdate = 1),\n    # energy_history_plotter(setup; nupdate = 1),\n    # energy_spectrum_plotter(setup; nupdate = 100),\n    # animator(setup, \"vorticity.mkv\"; nupdate = 4),\n    # vtk_writer(setup; nupdate = 10, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 1),\n);\nnothing #hide","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"V, p, outputs = solve_unsteady(\n    setup,\n    V₀,\n    p₀,\n    tlims;\n    method = RK44(),\n    Δt = 0.01,\n    processors,\n    inplace = true,\n);\ncurrent_figure()","category":"page"},{"location":"generated/ShearLayer2D/#Post-process","page":"Shear Layer (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"We may visualize or export the computed fields (V, p)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Export to VTK","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Plot pressure","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"plot_pressure(setup, p)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Plot velocity","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"plot_velocity(setup, V, t_end)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"plot_vorticity(setup, V, t_end)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"Plot streamfunction","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"# plot_streamfunction(setup, V, t_end)","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"","category":"page"},{"location":"generated/ShearLayer2D/","page":"Shear Layer (2D)","title":"Shear Layer (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"equations/spatial/#Spatial-Discretization","page":"Spatial discretization","title":"Spatial Discretization","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"To discretize the incompressible Navier-Stokes equations, we will use finite volumes on a staggered Cartesian grid, as proposed by Harlow and Welsh [4]. We will use the notation of Sanderse [5] [6] [7].","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Let d in 2 3 denote the spatial dimension (2D or 3D). We will make use of the \"Cartesian\" index I = (i j) in 2D or I = (i j k) in 3D, with I(1) = i, I(2) = j, and I(3) = k. Here, the indices I, i, j, and k, represent discrete degrees of freedom, and can take integer or half values (e.g. 3 or 52). To specify a spatial dimension, we will use the symbols (alpha beta gamma) in 1 dots d^3. We will use the symbol delta(alpha) = (delta_alpha beta)_beta = 1^d in 0 1^d to indicate a perturbation in the direction alpha, where delta_alpha beta is the Kronecker symbol. The spatial variable is x = (x^1 dots x^d) in Omega subset mathbbR^d.","category":"page"},{"location":"equations/spatial/#Finite-volumes","page":"Spatial discretization","title":"Finite volumes","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We here assume that Omega = prod_alpha = 1^d 0 L^alpha has the shape of a box with side lengths L^alpha  0. This allows for partitioning Omega into the finite volumes","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Omega_I = prod_alpha = 1^d left x^alpha_I(alpha) - frac12\nx^alpha_I(alpha) + frac12 right quad I in mathcalI","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Just like Omega itself, they represent rectangles in 2D and prisms in 3D. They are fully defined by the vectors of volume face coordinates x^alpha = left( x^alpha_i right)_i = 0^N(alpha) in mathbbR^N(alpha) + 1, where N = (N(1) dots N(d)) in mathbbN^d are the numbers of finite volumes in each dimension and mathcalI = prod_alpha = 1^d left frac12 2 - frac12 dots N(alpha) - frac12 right the set of finite volume indices (note that the reference volumes are indexed by half indices only). The components x^alpha_i are not assumed to be uniformly spaced. But we do assume that they are strictly increasing with i, with x^alpha_0 = 0 and x^alpha_N(alpha) = L^alpha.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The coordinates of the volume centers are determined from the those of the volume boundaries by x^alpha_I(alpha) = frac12 (x^alpha_I(alpha) - frac12 + x_I(alpha) + frac12) for I in mathcalI. This allows for defining shifted volumes such as Omega_I + delta(alpha)  2 and Omega_I + delta(alpha)  2 + delta(beta)  2. The original volumes (with indices in mathcalI) will be referred to as the reference finite volumes.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We also define the volume widths/depths/heights Delta x^alpha_i = x^alpha_i + frac12 - x^alpha_i - frac12, where i can take half values. The volume sizes are thus  Omega_I  = prod_alpha = 1^d Delta x^alpha_I(alpha).","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In addition to the finite volumes and their shifted variants, we define the surface","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Gamma^alpha_I = prod_beta = 1^d begincases\n    left x^beta_I(beta) right  quad alpha = beta \n    left x^beta_I(beta) - 1  2 x^beta_I(beta) + 1  2 right  quad\n    textotherwise\nendcases","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where I can take integer or half-values. It is the interface between Omega_I - delta(alpha)  2 and Omega_I + delta(alpha)  2, and has surface normal delta(alpha).","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In each reference finite volume Omega_I (I in mathcalI), there are three different types of positions in which quantities of interest can be defined:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The volume center x_I = (x_I(1) dots x_I(d)), where the discrete pressure p_I is defined;\nThe right/rear/top volume face centers x_I + delta(alpha)  2, where the discrete alpha-velocity component u^alpha_I + delta(alpha)  2 is defined;\nThe right-rear-top volume corner  x_I + sum_alpha delta(alpha)  2, where the discrete vorticity omega_I + sum_alpha delta(alpha)  2 is defined.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The vectors of unknowns u^alpha_h and p_h will not contain all the half-index components, only those from their own canonical position. The unknown discrete pressure represents the average pressure in each reference volume, and the unknown discrete velocity components represent exchange of mass between neighboring volumes.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, this finite volume configuration is illustrated as follows:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(Image: Grid)","category":"page"},{"location":"equations/spatial/#Interpolation","page":"Spatial discretization","title":"Interpolation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"When a quantity is required outside of its native point, we will use interpolation. Examples:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"To compute u^alpha at the pressure point x_I, I in mathcalI:\nbeginsplit\n    u^alpha_I  = fracx^alpha_I(alpha) + 1  2 -\n    x^alpha_I(alpha)x^alpha_I(alpha) + 1  2 - x^alpha_I(alpha) - 1  2\n    u_I - delta(alpha)  2\n    + fracx^alpha_I(alpha) - x^alpha_I(alpha) - 1  2x^alpha_I(alpha) + 1  2 - x^alpha_I(alpha) - 1  2\n    u_I + delta(alpha)  2 \n     = frac12 left( u_I - delta(alpha)  2 + u_I + delta(alpha)  2 right)\nendsplit\nInterpolation weights from volume faces to volume centers are always frac12.\nTo compute u^alpha at center of edge between alpha-face and beta-face x_I + delta(alpha)  2 + delta(beta)  2:\nu^alpha_I + delta(alpha)  2 + delta(beta)  2 =\nfracx^beta_I(beta) + 1 - x^beta_I(beta) + 1  2x^beta_I(beta) + 1 - x^beta_I(beta)\nu^alpha_I + delta(alpha)  2\n+ fracx^beta_I(beta) + 1  2 - x^beta_I(beta)x^beta_I(beta) + 1 - x^beta_I(beta)\nu^alpha_I + delta(alpha)  2 + delta(beta)\nNote that the grid is allowed to be non-uniform, so the interpolation weights may unequal and different from frac12.\nTo compute p at u^alpha-points:\np_I + delta(alpha)  2 =\nfracx^alpha_I(alpha) + 1 - x^alpha_I(alpha) + 1  2x^alpha_I(alpha) + 1 - x^alpha_I(alpha)\np_I\n+ fracx^alpha_I(alpha) + 1  2 - x^alpha_I(alpha)x^alpha_I(alpha) + 1 - x^alpha_I(alpha)\np_I + delta(alpha)","category":"page"},{"location":"equations/spatial/#Finite-volume-discretization-of-the-Navier-Stokes-equations","page":"Spatial discretization","title":"Finite volume discretization of the Navier-Stokes equations","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We will consider the integral form of the Navier-Stokes equations. This has the advantage that some of the spatial derivatives dissapear, reducing the amount of finite difference approximations we need to perform.","category":"page"},{"location":"equations/spatial/#Mass-equation","page":"Spatial discretization","title":"Mass equation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The mass equation takes the form","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"int_partial mathcalO u cdot n  mathrmd Gamma = 0 quad forall\nmathcalO subset Omega","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Using the pressure volume mathcalO = Omega_I, we get","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d left( int_Gamma^alpha_I + delta(alpha)  2\nu^alpha  mathrmd Gamma - int_Gamma_I - delta(alpha)  2^alpha\nu^alpha  mathrmd Gamma\nright) = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Assuming that the flow is fully resolved, meaning that Omega_I is is sufficiently small such that u is locally linear, we can perform the local approximation (quadrature)","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"int_Gamma^alpha_I u^alpha  mathrmd Gamma approx  Gamma^alpha_I\n u^alpha_I","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This yields the discrete mass equation","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d\nleft Gamma^alpha_I right left( u^alpha_I + delta(alpha)  2 -\nu^alpha_I - delta(alpha)  2 right) = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Approximation error\nFor the mass equation, the only approximation we have performed is quadrature. No interpolation or finite difference error is present.","category":"page"},{"location":"equations/spatial/#Momentum-equations","page":"Spatial discretization","title":"Momentum equations","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Grouping the convection, pressure gradient, diffusion, and body force terms in each of their own integrals, we get, for all mathcalO subset Omega:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"fracpartial partial t int_mathcalO u^alpha  mathrmd Omega\n=\n- sum_beta = 1^d int_partial mathcalO u^alpha u^beta n^beta \nmathrmd Gamma\n- int_partial mathcalO p n^alpha  mathrmd Gamma\n+ nu sum_beta = 1^d int_partial mathcalO fracpartial\nu^alphapartial x^beta n^beta  mathrmd Gamma\n+ int_mathcalO f^alpha mathrmd Omega","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where n = (n^1 dots n^d) is the surface normal vector to partial mathcalO.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This time, we will not let mathcalO be the reference finite volume Omega_I (the p-volume), but rather the shifted u^alpha-volume. Setting mathcalO = Omega_I + delta(alpha)  2 (with right/rear/top beta-faces Gamma^beta_I + delta(alpha)  2 + delta(beta)  2) gives","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracpartial partial t\n    int_Omega_I + delta(alpha)  2\n       \n       \n       \n       \n    u^alpha  mathrmd Omega\n    =\n     -\n    sum_beta = 1^d left(\n        int_Gamma^beta_I + delta(alpha)  2 + delta(beta)  2\n               \n               \n               \n               \n        u^alpha u^beta  mathrmd Gamma \n        - int_Gamma^beta_I + delta(alpha)  2 - delta(beta)  2\n               \n               \n               \n               \n               \n               \n        u^alpha u^beta  mathrmd Gamma \n    right) \n     -\n    left(\n        int_Gamma^alpha_I + delta(alpha) p  mathrmd Gamma\n    - int_Gamma^alpha_I p  mathrmd Gamma\n    right) \n     + nu sum_beta = 1^d \n    left(\n        int_Gamma^beta_I + delta(alpha)  2 + delta(beta)  2\n        fracpartial u^alphapartial x^beta  mathrmd Gamma \n        - int_Gamma^beta_I + delta(alpha)  2 - delta(beta)  2\n        fracpartial u^alphapartial x^beta  mathrmd Gamma \n    right) \n     +\n    int_Omega_I + delta(alpha)  2\n    f^alpha  mathrmd Omega\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This equation is still exact. We now introduce some approximations on Omega_I + delta(alpha)  2 and its boundaries to remove all unknown continuous quantities.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We replace the integrals with a mid-point quadrature rule.\nThe mid-point values of derivatives are approximated using a central-like finite difference:\nfracpartial u^alphapartial x^beta(x_I) approx\nfracu^alpha_I + delta(beta)  2\n- u^alpha_I - delta(beta)  2x^beta_I(beta) + 1  2 -\nx^beta_I(beta) - 1  2\nQuantities outside their canonical positions are obtained through interpolation.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Finally, the discrete alpha-momentum equations are given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    left Omega_I + delta(alpha)  2 right\n    fracmathrmd mathrmd t u^alpha_I + delta(alpha)  2 =\n     - sum_beta = 1^d left Gamma^beta_I + delta(alpha)  2 right\n    left(\n        (u^alpha\n        u^beta)_I + delta(alpha)  2 + delta(beta)  2\n        -\n        (u^alpha\n        u^beta )_I + delta(alpha)  2 - delta(beta)  2\n    right) \n     - left Gamma^alpha_I + delta(alpha)  2 right\n    left( p_I + delta(alpha) - p_I right) \n     + nu sum_beta = 1^d left Gamma^beta_I + delta(alpha)  2\n    right\n    left( \n        fracu^alpha_I + delta(alpha)  2 + delta(beta) - u^alpha_I +\n        delta(alpha)  2x^beta_I(beta) + 1 - x^beta_I(beta)\n        - fracu^alpha_I + delta(alpha)  2 - u^alpha_I +\n        delta(alpha)  2 - delta(beta)x^beta_I(beta)\n        - x^beta_I(beta) - 1\n    right) \n     + left Omega_I + delta(alpha)  2 right f^alpha(x_I +\n    delta(alpha)  2)\nendsplit","category":"page"},{"location":"equations/spatial/#Boundary-conditions","page":"Spatial discretization","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Depending on the type of boundary conditions, certain indices used in the left- and right hand sides of the equations may not be part of the solution vectors, even if they are indeed at their canonical positions. Consider for example the alpha-left/front/bottom boundary  x in Omega  x^alpha = x^alpha_0 . Let Omega_I be one of the reference finite volumes touching this boundary, i.e. I(alpha) = frac12.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"For periodic boundary conditions, we also consider the opposite boundary. We add two \"ghost\" reference volumes, one at each side of Omega:\nThe ghost volume Omega_I - delta(alpha) has the same shape as Omega_I + (N(alpha) - 1) delta(alpha) and contains the same components:\nu^alpha_I - delta(alpha)  2 = u^alpha_I + (N(alpha) - 1  2) delta(alpha),\nu^beta_I + delta(beta)  2 - delta(alpha) = u^beta_I + delta(beta)  2 + N(alpha) delta(alpha) for beta neq alpha,\np_I - delta(alpha) = p_I + (N(alpha) - 1) delta(alpha).\nThe ghost volume Omega_I + N(alpha) delta(alpha) has the same  shape as Omega_I and contains the same pressure and velocity components.\nFor Dirichlet boundary conditions, all the veloctity components are prescribed. For the normal velocity component, this is straightforward:\nu^alpha_I - delta(alpha)  2 = u^alpha(x_I - delta(alpha)  2)\nThe parallel (beta neq alpha) velocity components u^beta_I + delta(beta)  2 - delta(alpha) appear in some of the right hand side expressions. Their alpha position x^alpha_- 1  2 has actually never been defined, so we simply define it to be on the boundary itself: x^alpha_- 1  2 = x^alpha_0. The value can then be prescribed:\nu^beta_I + delta(beta)  2 - delta(alpha) = u^beta left( x_I +\ndelta(beta)  2 - delta(alpha) right) = u^beta left( x_I +\ndelta(beta)  2 - delta(alpha)  2 right)\nThe pressure does not require any boundary modifications.\nFor a symmetric boundary, the normal component has zero Dirichlet conditions, while the parallel components have zero Neumann conditions. For this, we add a ghost volume Omega_I - delta(alpha) which has the same shape as Omega_I, meaning that x^alpha_-1 = x^alpha_0 - (x^alpha_1 - x^alpha_0) = - x^alpha_1. The pressure in this volume is never used, but we set u^alpha_I - delta(alpha)  2 = 0 and u^beta_I + delta(beta)  2 - delta(alpha) = u^beta_I + delta(beta)  2 for beta neq alpha.\nFor a pressure boundary, the value of the pressure is prescribed, while the velocity has zero Neumann boundary conditions. For this, we add an infinitely thin ghost volume Omega_I - delta(alpha), by setting x^alpha_-1 = x^alpha_0 - epsilon for some epsilon. We then let this thickness go to zero after substituting the boundary conditions in the momentum equations. The pressure is prescribed by\np_I - delta(alpha) = p(x_I - delta(alpha)) undersetepsilon to 0to p(x_I - delta(alpha)  2)\nThe Neumann boundary conditions are obtained by setting u^alpha_I - 3  2 delta(alpha) = u^alpha_I - delta(alpha)  2 and u^beta_I - delta(alpha) + delta(beta)  2 = u^beta_I + delta(beta)  2 for beta neq alpha. Note that the normal velocity component at the boundary u^alpha_I - delta(alpha)  2 is now a degree of freedom, and we need to observe that the first normal derivative in the diffusion term of its corresponding momentum equation is zero before taking the limit as epsilon to 0, to avoid dividing by zero.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"It should now be clear from the above cases which components of the discrete velocity and pressure are unknown degrees of freedom, and which components are prescribed or obtained otherwise. The unknown degrees of freedom are stored in the vectors u_h = (u^1_h dots u^d_h) and p_h using the column-major convention. Note that the d discrete velocity fields u^1_h dots u^d_h may have different numbers of elements.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Storage convention\nWe use the column-major convention (Julia, MATLAB, Fortran), and not the row-major convention (Python, C). Thus the x^1-index i will vary for one whole cycle in the vectors before the x^2-index j, x^3 index k, and component-index alpha are incremented, e.g. u_h = (u^1_(1 1 1) u^1_(2 1 1) dots u^3_(N_u^3(1) N_u^3(2) N_u^3(3))) in 3D.","category":"page"},{"location":"equations/spatial/#Matrix-representation","page":"Spatial discretization","title":"Matrix representation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We can write the mass and momentum equations in matrix form. The discrete mass equation then becomes","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"M u_h + y_M = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where M is the discrete divergence operator and y_M contains the boundary value contributions of the velocity to the divergence field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The discrete momentum equations become","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    Omega_h fracmathrmd u_hmathrmd t  = -C(u_h) + nu (D u_h +\n    y_D) + f_h - (G p_h + y_G) \n     = F(V_h) - (G p_h + y_G)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where Omega_h is a diagonal matrix containing the velocity volumes, C is the convection operator (including boundary contributions), D is the diffusion operator, y_D is boundary contribution to the diffusion term, G = M^mathsfT is the pressure gradient operator, and y_G contains the boundary contribution of the pressure to the pressure gradient (only non-zero for pressure boundary conditions). The term F refers to all the forces except for the pressure gradient.","category":"page"},{"location":"equations/spatial/#Discrete-pressure-Poisson-equation","page":"Spatial discretization","title":"Discrete pressure Poisson equation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Instead of directly discretizing the continuous pressure Poisson equation, we will rededuce it in the discrete setting, thus aiming to preserve the discrete divergence freeness instead of the continuous one. Applying the discrete divergence operator M to the discrete momentum equations yields the discrete pressure Poisson equation","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"L p_h = M Omega_h^-1 (F(V_h) - y_G) + fracmathrmd y_Mmathrmd t","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where L = M Omega_h^-1 G is a discrete Laplace operator. It is positive symmetric since G = M^mathsfT.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Unsteady Dirichlet boundary conditions\nIf the equations are prescribed with unsteady Dirichlet boundary conditions, for example an inflow that varies with time, the term fracmathrmd y_Mmathrmd t will be non-zero. If this term is not known exactly, for example if the next value of the inflow is unknown at the time of the current value, it must be computed using past values of of the velocity inflow only, for example fracmathrmd y_Mmathrmd t approx (y_M(t) - y_M(t - Delta t))  Delta t for some Delta t.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Uniqueness of pressure field\nUnless pressure boundary conditions are present, the pressure is only determined up to a constant, as L will have an eigenvalue of zero. Since only the gradient of the pressure appears in the equations, we can set the unknown constant to zero without affecting the velocity field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Pressure projection\nThe pressure field p_h can be seen as a Lagrange multiplier enforcing the constraint of discrete divergence freeness. It is also possible to write the momentum equations without the pressure by explicitly solving the discrete Poisson equation:p_h = L^-1 M Omega_h^-1 (F(u_h) - y_G) + L^-1 fracmathrmd y_Mmathrmd tThe momentum equations then becomeOmega_h fracmathrmd u_hmathrmd t = (I - G L^-1 M Omega_h^-1)\n(F(u_h) - y_G) - G L^-1 fracmathrmd y_Mmathrmd tThe matrix (I - G L^-1 M Omega^-1) is a projector onto the space of discretely divergence free velocities. However, using this formulation would require an efficient way to perform the projection without assembling the operator matrix L^-1, which would be very costly.","category":"page"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/tableaux/#API-Reference-–-Runge-Kutta-methods","page":"Runge-Kutta methods","title":"API Reference – Runge-Kutta methods","text":"","category":"section"},{"location":"api/tableaux/#Explicit-Methods","page":"Runge-Kutta methods","title":"Explicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"FE11\nSSP22\nSSP42\nSSP33\nSSP43\nSSP104\nrSSPs2\nrSSPs3\nWray3\nRK56\nDOPRI6","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.FE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.FE11","text":"FE11(; kwargs...)\n\nFE11.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP22","text":"SSP22(; kwargs...)\n\nSSP22.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP42","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP42","text":"SSP42(; kwargs...)\n\nSSP42.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP33","text":"SSP33(; kwargs...)\n\nSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP43","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP43","text":"SSP43(; kwargs...)\n\nSSP43.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP104","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP104","text":"SSP104(; kwargs...)\n\nSSP104.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.rSSPs2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.rSSPs2","text":"rSSPs2(s = 2; kwargs...)\n\nRational (optimal, low-storage) s-stage 2nd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.rSSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.rSSPs3","text":"rSSPs3(s = 4; kwargs...)\n\nRational (optimal, low-storage) s^2-stage 3rd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.Wray3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Wray3","text":"Wray3(; kwargs...)\n\nWray's RK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK56","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK56","text":"RK56(; kwargs...)\n\nRK56.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DOPRI6","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DOPRI6","text":"DOPRI6(; kwargs...)\n\nDormand-Price pair.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Implicit-Methods","page":"Runge-Kutta methods","title":"Implicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"BE11\nSDIRK34\nISSPm2\nISSPs3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.BE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.BE11","text":"BE11(; kwargs...)\n\nBackward Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SDIRK34","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SDIRK34","text":"SDIRK34(; kwargs...)\n\n3-stage, 4th order singly diagonally implicit (SSP).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.ISSPm2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.ISSPm2","text":"ISSPm2(s = 1; kwargs...)\n\nOptimal DIRK SSP schemes of order 2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.ISSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.ISSPs3","text":"ISSPs3(s = 2; kwargs...)\n\nOptimal DIRK SSP schemes of order 3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Half-explicit-methods","page":"Runge-Kutta methods","title":"Half explicit methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"HEM3\nHEM3BS\nHEM5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM3","text":"HEM3(; kwargs...)\n\nBrasey and Hairer.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM3BS","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM3BS","text":"HEM3BS(; kwargs...)\n\nHEM3BS.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM5","text":"HEM5(; kwargs...)\n\nBrasey and Hairer, 5 stage, 4th order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Classical-Methods","page":"Runge-Kutta methods","title":"Classical Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"GL1\nGL2\nGL3\nRIA1\nRIA2\nRIA3\nRIIA1\nRIIA2\nRIIA3\nLIIIA2\nLIIIA3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL1","text":"GL1(; kwargs...)\n\nGL1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL2","text":"GL2(; kwargs...)\n\nGL2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL3","text":"GL3(; kwargs...)\n\nGL3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA1","text":"RIA1(; kwargs...)\n\nThis is implicit Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA2","text":"RIA2(; kwargs...)\n\nRIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA3","text":"RIA3(; kwargs...)\n\nRIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA1","text":"RIIA1(; kwargs...)\n\nRIIA1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA2","text":"RIIA2(; kwargs...)\n\nRIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA3","text":"RIIA3(; kwargs...)\n\nRIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.LIIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.LIIIA2","text":"LIIIA2(; kwargs...)\n\nLIIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.LIIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.LIIIA3","text":"LIIIA3(; kwargs...)\n\nLIIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Chebyshev-methods","page":"Runge-Kutta methods","title":"Chebyshev methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"CHDIRK3\nCHCONS3\nCHC3\nCHC5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHDIRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHDIRK3","text":"CHDIRK3(; kwargs...)\n\nChebyshev based DIRK (not algebraically stable).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHCONS3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHCONS3","text":"CHCONS3(; kwargs...)\n\nCHCONS3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHC3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHC3","text":"CHC3(; kwargs...)\n\nChebyshev quadrature and C(3) satisfied. Note this equals Lobatto IIIA.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHC5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHC5","text":"CHC5(; kwargs...)\n\nCHC5.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Miscellaneous-Methods","page":"Runge-Kutta methods","title":"Miscellaneous Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"Mid22\nMTE22\nCN22\nHeun33\nRK33C2\nRK33P2\nRK44\nRK44C2\nRK44C23\nRK44P2","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.Mid22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Mid22","text":"Mid22(; kwargs...)\n\nMidpoint 22 method.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.MTE22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.MTE22","text":"MTE22(; kwargs...)\n\nMinimal truncation error 22 method (Heun).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CN22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CN22","text":"CN22(; kwargs...)\n\nCrank-Nicholson.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.Heun33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Heun33","text":"Heun33(; kwargs...)\n\nHeun33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK33C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK33C2","text":"RK33C2(; kwargs...)\n\nRK3 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK33P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK33P2","text":"RK33P2(; kwargs...)\n\nRK3 satisfying the second order condition for the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44","text":"RK44(; kwargs...)\n\nClassical fourth order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44C2","text":"RK44C2(; kwargs...)\n\nRK4 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44C23","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44C23","text":"RK44C23(; kwargs...)\n\nRK4 satisfying C(2) for i=3 and c2=c3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44P2","text":"RK44P2(; kwargs...)\n\nRK4 satisfying the second order condition for the pressure (but not third order).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#DSRK-Methods","page":"Runge-Kutta methods","title":"DSRK Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"DSso2\nDSRK2\nDSRK3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSso2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSso2","text":"DSso2(; kwargs...)\n\nCBM's DSRKso2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSRK2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSRK2","text":"DSRK2(; kwargs...)\n\nCBM's DSRK2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSRK3","text":"DSRK3(; kwargs...)\n\nZennaro's DSRK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#\"Non-SSP\"-Methods-of-Wong-and-Spiteri","page":"Runge-Kutta methods","title":"\"Non-SSP\" Methods of Wong & Spiteri","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"NSSP21\nNSSP32\nNSSP33\nNSSP53","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP21","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP21","text":"NSSP21(; kwargs...)\n\nNSSP21.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP32","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP32","text":"NSSP32(; kwargs...)\n\nNSSP32.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP33","text":"NSSP33(; kwargs...)\n\nNSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP53","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP53","text":"NSSP53(; kwargs...)\n\nNSSP53.\n\n\n\n\n\n","category":"function"},{"location":"features/bc/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"Various boundary conditions are supported. They are indicated by the symbols","category":"page"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":":periodic\n:dirichlet\n:symmetric\n:pressure","category":"page"},{"location":"equations/ns/#Incompressible-Navier-Stokes-equations","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Let d in 2 3 denote the spatial dimension, and Omega subset mathbbR^d some spatial domain. The incompressible Navier-Stokes equations on Omega are comprised of a mass equation and d momentum equations. In conservative form, they are given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginalign*\nnabla cdot u  = 0 \nfracpartial upartial t + nabla cdot (u u^mathsfT)  = -nabla p +\nnu nabla^2 u + f\nendalign*","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where u = (u^1 dots u^d) is the velocity field, p is the pressure, nu is the kinematic viscosity, and f = (f^1 dots f^d) is the body force per unit of volume. In scalar notation, the equations can be written as","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginalign*\nsum_beta = 1^d fracpartial u^betapartial x^beta  = 0 \nfracpartial u^alphapartial t + sum_beta = 1^d\nfracpartialpartial x^beta (u^alpha u^beta)  = -fracpartial\nppartial x^alpha + nu sum_beta = 1^d fracpartial^2 u^alphapartial\n(x^beta)^2 + f^alpha\nendalign*","category":"page"},{"location":"equations/ns/#Integral-form","page":"Incompressible Navier-Stokes equations","title":"Integral form","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"When discretizing the Navier-Stokes equations it can be useful to integrate the equations over an arbitrary control volume mathcalO. Its boundary will be denoted partial mathcalO, with normal n and surface element mathrmd Gamma.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The mass equation in integral form is given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"int_partial mathcalO u cdot n  mathrmd Gamma = 0","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where we have used the divergence theorem to convert the volume integral to a surface integral. Similarly, the momentum equations take the form","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"fracpartial partial t int_mathcalO u  mathrmd Omega\n= int_partial mathcalO left( - u u^mathsfT - P + nu S right) cdot n \nmathrmd Gamma + int_mathcalO f mathrmd Omega","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where P = p mathrmI is the hydrostatic stress tensor and S = nabla u + (nabla u)^mathsfT is the strain-rate tensor. Here we have once again used the divergence theorem.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"note: Strain-rate tensor\nThe second term in the strain rate tensor is optional, asint_partial mathcalO (nabla u)^mathsfT cdot n  mathrmd Gamma = 0due to the divergence freeness of u (mass equation).","category":"page"},{"location":"equations/ns/#Boundary-conditions","page":"Incompressible Navier-Stokes equations","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Consider a part Gamma of the total boundary partial Omega, with normal n. We allow for the following types of boundary conditions on Gamma:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Periodic boundary conditions: u(x) = u(x + tau) and p(x) = p(x + tau) for x in Gamma, where tau is a constant translation to another part of the boundary partial Omega. This usually requires Gamma and its periodic counterpart Gamma + tau to be flat and rectangular (including in this software suite).\nDirichlet boundary conditions: u = u_textBC on Gamma. A common situation here is that of a sticky wall, with \"no slip boundary conditions. Then u_textBC = 0.\nSymmetric boundary conditions: Same velocity field at each side. This implies zero Dirichlet conditions for the normal component (n cdot u = 0), and zero Neumann conditions for the parallel component: n cdot nabla (u - (n cdot u) n) = 0.\nPressure boundary conditions: The pressure is prescribed (p = p_textBC), while the velocity has zero Neumann conditions: n cdot nabla u = 0.","category":"page"},{"location":"equations/ns/#Pressure-equation","page":"Incompressible Navier-Stokes equations","title":"Pressure equation","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Taking the divergence of the momemtum equations yields a Poisson equation for the pressure:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- nabla^2 p = nabla cdot left( nabla cdot (u u^mathsfT) right) -\nnabla cdot f","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In scalar notation, this becomes","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- sum_alpha = 1^d fracpartial^2partial (x^alpha)^2 p = sum_alpha\n= 1^d sum_beta = 1^d fracpartial^2 partial x^alpha partial\nx^beta (u^alpha u^beta) - sum_alpha = 1^d fracpartial\nf^alphapartial x^alpha","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note the absence of time derivatives in the pressure equation. While the velocity field evolves in time, the pressure only changes such that the velocity stays divergence free.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"If there are no pressure boundary conditions, the pressure is only unique up to a constant. We set this constant to 1.","category":"page"},{"location":"equations/ns/#Other-quantities-of-interest","page":"Incompressible Navier-Stokes equations","title":"Other quantities of interest","text":"","category":"section"},{"location":"equations/ns/#Vorticity","page":"Incompressible Navier-Stokes equations","title":"Vorticity","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The vorticity is defined as omega = nabla times u.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 2D, it is a scalar field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = -fracpartial u^1partial x^2 + fracpartial u^2partial\nx^1","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 3D, it is a vector field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = beginpmatrix\n    - fracpartial u^2partial x^3 + fracpartial u^3partial x^2 \n    - fracpartial u^3partial x^1 + fracpartial u^1partial x^3  \n    - fracpartial u^1partial x^2 + fracpartial u^2partial x^1\nendpmatrix","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note that the 2D vorticity is equal to the x^3-component of the 3D vorticity.","category":"page"},{"location":"equations/ns/#Stream-function","page":"Incompressible Navier-Stokes equations","title":"Stream function","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The stream function psi is a field (scalar in 2D, vector in 3D) defined such that","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"u = nabla times psi","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"It is related to the vorticity as","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"nabla^2 psi = nabla times omega","category":"page"},{"location":"equations/ns/#Kinetic-energy","page":"Incompressible Navier-Stokes equations","title":"Kinetic energy","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The local and total kinetic energy are defined by k = frac12  u _2^2 and K = frac12  u _L^2(Omega)^2 = int_Omega k  mathrmd Omega.","category":"page"},{"location":"equations/ns/#Reynolds-number","page":"Incompressible Navier-Stokes equations","title":"Reynolds number","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The Reynolds number is the inverse of the viscosity: Re = frac1nu.","category":"page"},{"location":"features/steppers/#Time-steppers","page":"Time steppers","title":"Time steppers","text":"","category":"section"},{"location":"features/steppers/","page":"Time steppers","title":"Time steppers","text":"IncompressibleNavierStokes provides a collection of explicit and implicit Runge-Kutta methods, in addition to Adams-Bashforth Crank-Nicolson and one-leg beta method time steppers.","category":"page"},{"location":"features/steppers/","page":"Time steppers","title":"Time steppers","text":"The code is currently not adapted to time steppers from DifferentialEquations.jl, but they may be integrated in the future.","category":"page"},{"location":"features/pressure/#Pressure-solvers","page":"Pressure solvers","title":"Pressure solvers","text":"","category":"section"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"The discrete pressure Poisson equation","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"A p_h = g","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"enforces divergence freeness. There are three options for solving this system:","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"DirectPressureSolver factorizes the Laplace matrix A such that the system can be solved for different right hand sides. This currently only works for double precision on the CPU.\nCGPressureSolver uses conjugate gradients to solve the system for different f.\nSpectralPressureSolver solves the system in Fourier space, but only in the case of a uniform grid with periodic boundary conditions.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install IncompressibleNavierStokes, open up a Julia-REPL, type ] to get into Pkg-mode, and type:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"add IncompressibleNavierStokes","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install the package and all dependencies to your local environment. Note that IncompressibleNavierStokes requires Julia version 1.7 or above.","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"EditURL = \"../../../examples/Actuator2D.jl\"","category":"page"},{"location":"generated/Actuator2D/#Unsteady-actuator-case-2D","page":"Actuator (2D)","title":"Unsteady actuator case - 2D","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"In this example, an unsteady inlet velocity profile at encounters a wind turbine blade in a wall-less domain. The blade is modeled as a uniform body force on a thin rectangle.","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"name = \"Actuator2D\"","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Viscosity model","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Re = 100.0","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Boundary conditions: Unsteady BC requires time derivatives","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"u_bc(x, y, t) = x ≈ 0.0 ? cos(π / 6 * sin(π / 6 * t)) : 0.0\nv_bc(x, y, t) = x ≈ 0.0 ? sin(π / 6 * sin(π / 6 * t)) : 0.0\ndudt_bc(x, y, t) = x ≈ 0.0 ? -(π / 6)^2 * cos(π / 6 * t) * sin(π / 6 * sin(π / 6 * t)) : 0.0\ndvdt_bc(x, y, t) = x ≈ 0.0 ? (π / 6)^2 * cos(π / 6 * t) * cos(π / 6 * sin(π / 6 * t)) : 0.0\nbc_type = (;\n    u = (; x = (:dirichlet, :pressure), y = (:symmetric, :symmetric)),\n    v = (; x = (:dirichlet, :symmetric), y = (:pressure, :pressure)),\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"n = 40\nx = LinRange(0.0, 10.0, 5n)\ny = LinRange(-2.0, 2.0, 2n)\nplot_grid(x, y)","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Actuator body force: A thrust coefficient Cₜ distributed over a thin rectangle","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"xc, yc = 2.0, 0.0 # Disk center\nD = 1.0           # Disk diameter\nδ = 0.11          # Disk thickness\nCₜ = 5e-4         # Thrust coefficient\ncₜ = Cₜ / (D * δ)\ninside(x, y) = abs(x - xc) ≤ δ / 2 && abs(y - yc) ≤ D / 2\nbodyforce_u(x, y) = -cₜ * inside(x, y)\nbodyforce_v(x, y) = 0.0","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"setup = Setup(\n    x,\n    y;\n    Re,\n    u_bc,\n    v_bc,\n    dudt_bc,\n    dvdt_bc,\n    bc_type,\n    bodyforce_u,\n    bodyforce_v,\n);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Time interval","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"t_start, t_end = tlims = (0.0, 12.0)","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"initial_velocity_u(x, y) = 1.0\ninitial_velocity_v(x, y) = 0.0\ninitial_pressure(x, y) = 0.0\nV₀, p₀ = create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    t_start;\n    initial_pressure,\n);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Iteration processors","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"processors = (\n    field_plotter(setup; nupdate = 1),\n    # energy_history_plotter(setup; nupdate = 10),\n    # energy_spectrum_plotter(setup; nupdate = 10),\n    # animator(setup, \"vorticity.mkv\"; nupdate = 4),\n    # vtk_writer(setup; nupdate = 10, dir = \"output/$name\", filename = \"solution\"),\n    # field_saver(setup; nupdate = 10),\n    step_logger(; nupdate = 1),\n);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"V, p, outputs = solve_unsteady(\n    setup,\n    V₀,\n    p₀,\n    tlims;\n    method = RK44P2(),\n    Δt = 0.05,\n    processors,\n    inplace = true,\n);\ncurrent_figure()","category":"page"},{"location":"generated/Actuator2D/#Post-process","page":"Actuator (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"We may visualize or export the computed fields (V, p).","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"We create a box to visualize the actuator.","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"box = (\n    [xc - δ / 2, xc - δ / 2, xc + δ / 2, xc + δ / 2, xc - δ / 2],\n    [yc + D / 2, yc - D / 2, yc - D / 2, yc + D / 2, yc + D / 2],\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Export to VTK","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"save_vtk(setup, V, p, t_end, \"output/solution\")","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Plot pressure","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"fig = plot_pressure(setup, p)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Plot velocity","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"fig = plot_velocity(setup, V, t_end)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"fig = plot_vorticity(setup, V, t_end)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Plot streamfunction","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"fig = plot_streamfunction(setup, V, t_end)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"Plot force","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"fig = plot_force(setup, t_end)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"","category":"page"},{"location":"generated/Actuator2D/","page":"Actuator (2D)","title":"Actuator (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"features/les/#Large-eddy-simulation","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Depending on the problem specification, a given grid resolution may not be sufficient to resolve all spatial features of the flow. Consider the following example:","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"(Image: Resolution)","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the left, the grid spacing is too large to capt the smallest eddies in the flow. These eddies create sub-grid stresses that also affect the large scale features. The grid must be refined if we want to compute these stresses exactly.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the right, the smallest spatial feature of the flow is fully resolved, and there are no sub-grid stresses. The equations can be solved without worrying about errors from unresolved features. This is known as Direct Numerical Simulation (DNS).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"If refining the grid is too costly, a closure model can be used to predict the sub-grid stresses. The models only give an estimate for these stresses, and may need to be calibrated to the given problem. When used correctly, they can predict the evolution of the large fluid motions without computing the sub-grid motions themselves. This is known as Large Eddy Simulation (LES).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Eddy viscosity models add a local contribution to the global baseline viscosity. The baseline viscosity models transfer of energy from resolved to atomic scales. The new turbulent viscosity on the other hand, models energy transfer from resolved to unresolved scales. This non-constant field is computed from the local velocity field.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The following eddy viscosity models are available:","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"SmagorinskyModel\nQRModel\nMixingLengthModel","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In addition, the default LaminarModel assumes that there are no sub-grid stresses. It can be used if the grid is sufficiently refined for the given flow. It has the advantage of having a constant diffusion operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#IncompressibleNavierStokes","page":"Home","title":"IncompressibleNavierStokes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IncompressibleNavierStokes is a package providing energy-conserving solvers for the incompressible Navier-Stokes equations on a staggered Cartesian grid. It is based on the Matlab package INS2D/INS3D.","category":"page"},{"location":"api/api/","page":"API","title":"API","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"IncompressibleNavierStokes\nSetup","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.IncompressibleNavierStokes","page":"API","title":"IncompressibleNavierStokes.IncompressibleNavierStokes","text":"IncompressibleNavierStokes\n\nEnergy-conserving solvers for the incompressible Navier-Stokes equations.\n\n\n\n\n\n","category":"module"},{"location":"api/api/#IncompressibleNavierStokes.Setup","page":"API","title":"IncompressibleNavierStokes.Setup","text":"Setup(\n    x, y;\n    Re = 1000,\n    viscosity_model = LaminarModel(),\n    convection_model = NoRegConvectionModel(),\n    u_bc = (x, y, t) -> 0,\n    v_bc = (x, y, t) -> 0,\n    dudt_bc = nothing,\n    dvdt_bc = nothing,\n    bc_type = (;\n        u = (; x = (:periodic, :periodic), y = (:periodic, :periodic)),\n        v = (; x = (:periodic, :periodic), y = (:periodic, :periodic)),\n        ν = (; x = (:periodic, :periodic), y = (:periodic, :periodic)),\n    ),\n    order4 = false,\n    bodyforce_u = (x, y) -> 0,\n    bodyforce_v = (x, y) -> 0,\n    closure_model = nothing,\n)\n\nCreate 2D setup.\n\n\n\n\n\nSetup(\n    x, y, z;\n    Re = convert(eltype(x), 1000),\n    viscosity_model = LaminarModel(),\n    convection_model = NoRegConvectionModel(),\n    u_bc = (x, y, w, t) -> 0.0,\n    v_bc = (x, y, w, t) -> 0.0,\n    w_bc = (x, y, w, t) -> 0.0,\n    dudt_bc = nothing,\n    dvdt_bc = nothing,\n    dwdt_bc = nothing,\n    bc_type = (;\n        u = (;\n            x = (:periodic, :periodic),\n            y = (:periodic, :periodic),\n            z = (:periodic, :periodic),\n        ),\n        v = (;\n            x = (:periodic, :periodic),\n            y = (:periodic, :periodic),\n            z = (:periodic, :periodic),\n        ),\n        w = (;\n            x = (:periodic, :periodic),\n            y = (:periodic, :periodic),\n            z = (:periodic, :periodic),\n        ),\n        ν = (;\n            x = (:periodic, :periodic),\n            y = (:periodic, :periodic),\n            z = (:periodic, :periodic),\n        ),\n    ),\n    order4 = false,\n    bodyforce_u = (x, y, z) -> 0,\n    bodyforce_v = (x, y, z) -> 0,\n    bodyforce_w = (x, y, z) -> 0,\n    closure_model = nothing,\n)\n\nCreate 3D setup.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Boundary-conditions","page":"API","title":"Boundary conditions","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"BoundaryConditions\nget_bc_vectors","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.BoundaryConditions","page":"API","title":"IncompressibleNavierStokes.BoundaryConditions","text":"BoundaryConditions(u_bc, v_bc; T = Float64, bc_unsteady, bc_type, kwargs...)\n\nCreate discrete boundary condtions.\n\nValues should either be scalars or vectors. All values (u, v, p, k, e) are defined at (x, y) locations, i.e. the corners of pressure volumes, so they cover the entire domain, including corners.\n\n\n\n\n\nBoundaryConditions(u_bc, v_bc, w_bc; T = Float64, bc_unsteady, bc_type, kwargs...)\n\nCreate discrete boundary condtions.\n\nValues should either be scalars or vectors. All values (u, v, p, k, e) are defined at (x, y, z) locations, i.e. the corners of pressure volumes, so they cover the entire domain, including corners.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_bc_vectors","page":"API","title":"IncompressibleNavierStokes.get_bc_vectors","text":"get_bc_vectors(setup, t)\n\nGet boundary condition vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Force","page":"API","title":"Force","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"SteadyBodyForce","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.SteadyBodyForce","page":"API","title":"IncompressibleNavierStokes.SteadyBodyForce","text":"SteadyBodyForce(fu, fv, grid)\n\nTwo-dimensional steady body force f(x, y) = [fu(x, y), fv(x, y)]. \n\n\n\n\n\nSteadyBodyForce(fu, fv, fw, grid)\n\nThree-dimensional steady body force f(x, y, z) = [fu(x, y, z), fv(x, y, z), fw(x, y, z)]. \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Grid","page":"API","title":"Grid","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Dimension\nGrid\ncosine_grid\nmax_size\nstretched_grid","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.Dimension","page":"API","title":"IncompressibleNavierStokes.Dimension","text":"Dimension(N)\n\nRepresent an N-dimensional space. Returns N when called.\n\njulia> d = Dimension(3)\nDimension{3}()\n\njulia> d()\n3\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.Grid","page":"API","title":"IncompressibleNavierStokes.Grid","text":"Grid(x, y; boundary_conditions, order4 = false)\n\nCreate nonuniform Cartesian box mesh x × y with boundary conditions boundary_conditions. If order4 is true, a fourth order mesh is created.\n\n\n\n\n\nGrid(x, y, z; boundary_conditions, order4 = false)\n\nCreate nonuniform Cartesian box mesh x × y × z with boundary conditions boundary_conditions. If order4 is true, a fourth order mesh is created.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.cosine_grid","page":"API","title":"IncompressibleNavierStokes.cosine_grid","text":"cosine_grid(a, b, N)\n\nCreate a nonuniform grid of N + 1 points from a to b using a cosine profile, i.e.\n\nx_i = a + frac12 left( 1 - cos left( pi fracin right) right)\n(b - a) quad i = 0 dots N\n\nSee also stretched_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.max_size","page":"API","title":"IncompressibleNavierStokes.max_size","text":"max_size(grid)\n\nGet size of the largest grid element.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.stretched_grid","page":"API","title":"IncompressibleNavierStokes.stretched_grid","text":"stretched_grid(a, b, N, s = 1)\n\nCreate a nonuniform grid of N + 1 points from a to b with a stretch factor of s. If s = 1, return a uniform spacing from a to b. Otherwise, return a vector x in mathbbR^N + 1 such that x_n = a + sum_i = 1^n s^i - 1 h for n = 0 dots  N. Setting x_N = b then gives h = (b - a) frac1 - s1 - s^N, resulting in\n\nx_n = a + (b - a) frac1 - s^n1 - s^N quad n = 0 dots N\n\nNote that stretched_grid(a, b, N, s)[n] corresponds to x_n - 1.\n\nSee also cosine_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Visocosity-Models","page":"API","title":"Visocosity Models","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"AbstractViscosityModel\nLaminarModel\nMixingLengthModel\nSmagorinskyModel\nQRModel","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.AbstractViscosityModel","page":"API","title":"IncompressibleNavierStokes.AbstractViscosityModel","text":"AbstractViscosityModel\n\nAbstract viscosity model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.LaminarModel","page":"API","title":"IncompressibleNavierStokes.LaminarModel","text":"LaminarModel()\n\nLaminar model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.MixingLengthModel","page":"API","title":"IncompressibleNavierStokes.MixingLengthModel","text":"MixingLengthModel()\n\nMixing-length model with mixing length lm.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.SmagorinskyModel","page":"API","title":"IncompressibleNavierStokes.SmagorinskyModel","text":"SmagorinskyModel(Re, C_s = 0.17)\n\nSmagorinsky-Lilly model with constant C_s.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.QRModel","page":"API","title":"IncompressibleNavierStokes.QRModel","text":"QR(Re)\n\nQR-model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Convection-Models","page":"API","title":"Convection Models","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"AbstractConvectionModel\nNoRegConvectionModel\nC2ConvectionModel\nC4ConvectionModel\nLerayConvectionModel","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.AbstractConvectionModel","page":"API","title":"IncompressibleNavierStokes.AbstractConvectionModel","text":"AbstractConvectionModel\n\nAbstract convection model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.NoRegConvectionModel","page":"API","title":"IncompressibleNavierStokes.NoRegConvectionModel","text":"NoRegConvection()\n\nUnregularized convection model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.C2ConvectionModel","page":"API","title":"IncompressibleNavierStokes.C2ConvectionModel","text":"C2ConvectionModel()\n\nC2 regularization convection model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.C4ConvectionModel","page":"API","title":"IncompressibleNavierStokes.C4ConvectionModel","text":"C4ConvectionModel()\n\nC4 regularization convection model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.LerayConvectionModel","page":"API","title":"IncompressibleNavierStokes.LerayConvectionModel","text":"LerayConvectionModel()\n\nLeray regularization convection model.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Momentum","page":"API","title":"Momentum","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"MomentumCache\ncheck_symmetry\ncompute_conservation\nconvection\nconvection!\nconvection_components\nconvection_components!\ndiffusion\ndiffusion!\nmomentum\nmomentum!\nmomentum_allstage\nmomentum_allstage!\nstrain_tensor\nturbulent_K\nturbulent_viscosity","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.MomentumCache","page":"API","title":"IncompressibleNavierStokes.MomentumCache","text":"MomentumCache(setup)\n\nPreallocation structure for terms in the momentum equations.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.check_symmetry","page":"API","title":"IncompressibleNavierStokes.check_symmetry","text":"check_symmetry(V, t, setup, ϵ = 1e-14)\n\nCheck symmetry of convection operator.\n\nflag = 0: no symmetry error flag = 1: symmetry error\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.compute_conservation","page":"API","title":"IncompressibleNavierStokes.compute_conservation","text":"compute_conservation(V, t, setup; bc_vectors = nothing)\n\nCompute mass, momentum and energy conservation properties of velocity field.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.convection","page":"API","title":"IncompressibleNavierStokes.convection","text":"convection(\n    model, V, ϕ, setup;\n    bc_vectors,\n    get_jacobian = false,\n    newton_factor = false,\n)\n\nEvaluate convective terms c and, optionally, Jacobian ∇c = ∂c/∂V, using the convection model model. The convected quantity is ϕ (usually ϕ = V).\n\nNon-mutating/allocating/out-of-place version.\n\nSee also convection!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.convection!","page":"API","title":"IncompressibleNavierStokes.convection!","text":"convection!(\n    model, c, ∇c, V, ϕ, setup, cache;\n    bc_vectors,\n    get_jacobian = false,\n    newton_factor = false,\n)\n\nEvaluate convective terms c and, optionally, Jacobian ∇c = ∂c/∂V, using the convection model model. The convected quantity is ϕ (usually ϕ = V).\n\nMutating/non-allocating/in-place version.\n\nSee also convection.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.convection_components","page":"API","title":"IncompressibleNavierStokes.convection_components","text":"convection_components(\n    V, ϕ, setup;\n    bc_vectors,\n    get_jacobian = false,\n    newton_factor = false,\n    order4 = false,\n)\n\nCompute convection components.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also convection_components!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.convection_components!","page":"API","title":"IncompressibleNavierStokes.convection_components!","text":"convection_components!(\n    c, ∇c, V, ϕ, setup, cache;\n    bc_vectors,\n    get_jacobian = false,\n    newton_factor = false,\n    order4 = false,\n)\n\nCompute convection components.\n\nMutating/non-allocating/in-place version.\n\nSee also convection_components.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.diffusion","page":"API","title":"IncompressibleNavierStokes.diffusion","text":"diffusion!(model, V, setup; bc_vectors, get_jacobian = false)\n\nEvaluate diffusive terms d and optionally Jacobian ∇d = ∂d/∂V using viscosity model model.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also diffusion!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.diffusion!","page":"API","title":"IncompressibleNavierStokes.diffusion!","text":"diffusion!(model, d, ∇d, V, setup; bc_vectors, get_jacobian = false)\n\nEvaluate diffusive terms d and optionally Jacobian ∇d = ∂d/∂V using viscosity model model.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.momentum","page":"API","title":"IncompressibleNavierStokes.momentum","text":"momentum(\n    V, ϕ, p, t, setup;\n    bc_vectors = nothing,\n    get_jacobian = false,\n    nopressure = false,\n    newton_factor = false,\n)\n\nCalculate RHS of momentum equations and, optionally, Jacobian with respect to velocity field.\n\nV: velocity field\nϕ: convected field: e.g. fracpartial (phi_x V)partial x + fracpartial (phi_y V)partial y; usually ϕ = V (so ϕx = u, ϕy = v)\np: pressure\nbc_vectors: boundary condition vectors y\nget_jacobian: return ∇F = ∂F/∂V\nnopressure: exclude pressure gradient; in this case input argument p is not used\nnewton_factor\n\nNon-mutating/allocating/out-of-place version.\n\nSee also momentum!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.momentum!","page":"API","title":"IncompressibleNavierStokes.momentum!","text":"momentum!(F, ∇F, V, ϕ, p, t, setup, cache; get_jacobian = false, nopressure = false)\n\nCalculate rhs of momentum equations and, optionally, Jacobian with respect to velocity field.\n\nV: velocity field\nϕ: convected field: e.g. fracpartial (phi_x V)partial x + fracpartial (phi_y V)partial y; usually ϕ = V (so ϕx = u, ϕy = v)\np: pressure\nbc_vectors: boundary condition vectors y\nget_jacobian: return ∇F = ∂F/∂V\nnopressure: exclude pressure gradient; in this case input argument p is not used\nnewton_factor\n\nMutating/non-allocating/in-place version.\n\nSee also momentum.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.momentum_allstage","page":"API","title":"IncompressibleNavierStokes.momentum_allstage","text":"momentum_allstage(Vⱼ, ϕⱼ, pⱼ, tⱼ, setup; bc_vectors, nstage, get_jacobian = false)\n\nCall momentum for multiple (Vⱼ, pⱼ) pairs, as required in implicit RK methods.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also momentum_allstage!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.momentum_allstage!","page":"API","title":"IncompressibleNavierStokes.momentum_allstage!","text":"momentum_allstage!(\n    Fⱼ,\n    ∇Fⱼ,\n    Vⱼ,\n    ϕⱼ,\n    pⱼ,\n    tⱼ,\n    setup,\n    cache,\n    momentum_cache;\n    bc_vectors,\n    nstage,\n    get_jacobian = false,\n)\n\nCall momentum for multiple (V, p) pairs, as required in implicit RK methods.\n\nMutating/non-allocating/in-place version.\n\nSee also momentum_allstage.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.strain_tensor","page":"API","title":"IncompressibleNavierStokes.strain_tensor","text":"strain_tensor(V, setup; bc_vectors, get_jacobian = false, get_S_abs = false)\n\nEvaluate rate of strain tensor S(V) and its magnitude.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.turbulent_K","page":"API","title":"IncompressibleNavierStokes.turbulent_K","text":"turbulent_K(model, setup)\n\nCompute the constant part of the turbulent viscosity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.turbulent_viscosity","page":"API","title":"IncompressibleNavierStokes.turbulent_viscosity","text":"turbulent_viscosity(model, setup, S_abs)\n\nCompute turbulent viscosity based on S_abs.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Operators","page":"API","title":"Operators","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Operators\noperator_averaging\noperator_convection_diffusion\noperator_divergence\noperator_interpolation\noperator_postprocessing\noperator_regularization\noperator_turbulent_diffusion\noperator_viscosity\noperator_filter","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.Operators","page":"API","title":"IncompressibleNavierStokes.Operators","text":"Operators(grid, boundary_conditions, viscosity_model)\n\nBuild operators.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_averaging","page":"API","title":"IncompressibleNavierStokes.operator_averaging","text":"operator_averaging(grid, boundary_conditions)\n\nConstruct averaging operators.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_convection_diffusion","page":"API","title":"IncompressibleNavierStokes.operator_convection_diffusion","text":"operator_convection_diffusion(grid, boundary_conditions)\n\nConstruct convection and diffusion operators.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_divergence","page":"API","title":"IncompressibleNavierStokes.operator_divergence","text":"operator_divergence(grid, boundary_conditions)\n\nConstruct divergence and gradient operator.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_interpolation","page":"API","title":"IncompressibleNavierStokes.operator_interpolation","text":"operator_interpolation(grid, boundary_conditions)\n\nConstruct interpolation operators.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_postprocessing","page":"API","title":"IncompressibleNavierStokes.operator_postprocessing","text":"operator_postprocessing(grid, boundary_conditions)\n\nConstruct postprocessing operators such as vorticity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_regularization","page":"API","title":"IncompressibleNavierStokes.operator_regularization","text":"operator_regularization(grid, operators)\n\nBuild regularization matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_turbulent_diffusion","page":"API","title":"IncompressibleNavierStokes.operator_turbulent_diffusion","text":"operator_turbulent_diffusion(grid, boundary_conditions)\n\nAverage (turbulent) viscosity to cell faces: from ν at xp, yp to ν at ux, uy, vx, vy locations.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_viscosity","page":"API","title":"IncompressibleNavierStokes.operator_viscosity","text":"operator_viscosity(viscosity_model, grid, boundary_conditions)\n\nClassical turbulence modelling via the diffusive term\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.operator_filter","page":"API","title":"IncompressibleNavierStokes.operator_filter","text":"operator_filter(grid, boundary_conditions)\n\nConstruct filtering operator.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Postprocess","page":"API","title":"Postprocess","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_streamfunction\nget_velocity\nget_vorticity\nvorticity!\nplot_force\nplot_grid\nplot_pressure\nplot_streamfunction\nplot_velocity\nplot_vorticity\nsave_vtk","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.get_streamfunction","page":"API","title":"IncompressibleNavierStokes.get_streamfunction","text":"get_streamfunction(setup, V, t)\n\nCompute streamfunction psi from a Poisson equation nabla^2 psi = -omega.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_velocity","page":"API","title":"IncompressibleNavierStokes.get_velocity","text":"get_velocity(setup, V, t)\n\nGet velocity values at pressure points. Interpolate velocities to pressure positions using BMx and BMy (and BMz), constructed in operator_divergence.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_vorticity","page":"API","title":"IncompressibleNavierStokes.get_vorticity","text":"get_vorticity(setup, V, t)\n\nGet vorticity from velocity field.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.vorticity!","page":"API","title":"IncompressibleNavierStokes.vorticity!","text":"vorticity!(ω, V, t, setup)\n\nCompute vorticity values at pressure midpoints. This should be consistent with operator_postprocessing.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_force","page":"API","title":"IncompressibleNavierStokes.plot_force","text":"plot_force(setup, t; kwargs...)\n\nPlot body force.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_grid","page":"API","title":"IncompressibleNavierStokes.plot_grid","text":"plot_grid(x, y)\nplot_grid(x, y, z)\nplot_grid(grid)\n\nPlot nonuniform Cartesian grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_pressure","page":"API","title":"IncompressibleNavierStokes.plot_pressure","text":"plot_pressure(setup, p; kwargs...)\n\nPlot pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_streamfunction","page":"API","title":"IncompressibleNavierStokes.plot_streamfunction","text":"plot_streamfunction(setup, V, t; kwargs...)\n\nPlot streamfunction.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_velocity","page":"API","title":"IncompressibleNavierStokes.plot_velocity","text":"plot_velocity(setup, V, t; kwargs...)\n\nPlot velocity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plot_vorticity","page":"API","title":"IncompressibleNavierStokes.plot_vorticity","text":"plot_vorticity(setup, V, t; kwargs...)\n\nPlot vorticity field.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.save_vtk","page":"API","title":"IncompressibleNavierStokes.save_vtk","text":"save_vtk(setup, V, p, t, filename = \"output/solution\")\n\nSave velocity and pressure field to a VTK file.\n\nIn the case of a 2D setup, the velocity field is saved as a 3D vector with a z-component of zero, as this seems to be preferred by ParaView.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Preprocess","page":"API","title":"Preprocess","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"create_initial_conditions\nrandom_field","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.create_initial_conditions","page":"API","title":"IncompressibleNavierStokes.create_initial_conditions","text":"create_initial_conditions(\n    setup,\n    initial_velocity_u,\n    initial_velocity_v,\n    [initial_velocity_w,]\n    t;\n    initial_pressure = nothing,\n    pressure_solver = DirectPressureSolver(setup),\n)\n\nCreate initial vectors at starting time t. If p_initial is a function instead of nothing, calculate compatible IC for the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.random_field","page":"API","title":"IncompressibleNavierStokes.random_field","text":"random_field(\n    setup, K;\n    A = 1_000_000,\n    σ = 30,\n    s = 5,\n    pressure_solver = DirectPressureSolver(setup),\n)\n\nCreate random field.\n\nK: Maximum wavenumber\nA: Eddy amplitude\nσ: Variance\ns Wavenumber offset before energy starts decaying\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Processors","page":"API","title":"Processors","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"step_logger\nvtk_writer\nfield_saver\nfield_plotter\nenergy_history_plotter\nenergy_spectrum_plotter\nanimator","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.step_logger","page":"API","title":"IncompressibleNavierStokes.step_logger","text":"step_logger(; nupdate = 1)\n\nCreate processor that logs time step information.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.vtk_writer","page":"API","title":"IncompressibleNavierStokes.vtk_writer","text":"vtk_writer(\n    setup;\n    nupdate = 1,\n    dir = \"output\",\n    filename = \"solution\",\n    fields = (:velocity, :pressure, :vorticity),\n)\n\nCreate processor that writes the solution every nupdate time steps to a VTK file. The resulting Paraview data collection file is stored in \"$dir/$filename.pvd\".\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.field_saver","page":"API","title":"IncompressibleNavierStokes.field_saver","text":"field_saver(setup; nupdate = 1)\n\nCreate processor that stores the solution every nupdate time step to the vector of vectors V and p. The solution times are stored in the vector t.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.field_plotter","page":"API","title":"IncompressibleNavierStokes.field_plotter","text":"field_plotter(\n    setup;\n    fieldname = :vorticity,\n    type = nothing,\n    sleeptime = 0.001,\n    alpha = 0.05,\n)\n\nPlot the solution every time the state o is updated.\n\nThe sleeptime is slept at every update, to give Makie time to update the plot. Set this to nothing to skip sleeping.\n\nAvailable fieldnames are:\n\n:velocity,\n:vorticity,\n:streamfunction,\n:pressure.\n\nAvailable plot types for 2D are:\n\nheatmap (default),\ncontour,\ncontourf.\n\nAvailable plot types for 3D are:\n\ncontour (default).\n\nThe alpha value gets passed to contour in 3D.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_history_plotter","page":"API","title":"IncompressibleNavierStokes.energy_history_plotter","text":"energy_history_plotter(setup)\n\nCreate energy history plot, with a history point added every time step_observer is updated.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_spectrum_plotter","page":"API","title":"IncompressibleNavierStokes.energy_spectrum_plotter","text":"energy_spectrum_plotter(setup; nupdate = 1)\n\nCreate energy spectrum plot, redrawn every time step_observer is updated.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.animator","page":"API","title":"IncompressibleNavierStokes.animator","text":"animator(setup, path; nupdate = 1, plotter = field_plotter(setup); kwargs...)\n\nAnimate a plot of the solution every update iteration. The animation is saved to path, which should have one of the following extensions:\n\n\".mkv\"\n\".mp4\"\n\".webm\"\n\".gif\"\n\nThe plot is determined by a plotter processsor. Addtional kwargs are passed to Makie's VideoStream.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Solvers","page":"API","title":"Solvers","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_timestep\nsolve_unsteady\nsolve_steady_state","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.get_timestep","page":"API","title":"IncompressibleNavierStokes.get_timestep","text":"get_timestep(stepper, cfl; bc_vectors)\n\nEstimate time step based on eigenvalues of operators, using Gershgorin.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_unsteady","page":"API","title":"IncompressibleNavierStokes.solve_unsteady","text":"function solve_unsteady(\n    setup, V₀, p₀, tlims;\n    method = RK44(; T = eltype(V₀)),\n    pressure_solver = DirectPressureSolver(setup),\n    Δt = nothing,\n    cfl = 1,\n    n_adapt_Δt = 1,\n    inplace = false,\n    processors = (),\n    device = identity,\n)\n\nSolve unsteady problem using method.\n\nIf Δt is a real number, it is rounded such that (t_end - t_start) / Δt is an integer. If Δt = nothing, the time step is chosen every n_adapt_Δt iteration with CFL-number cfl .\n\nEach processor is called after every processor.nupdate time step.\n\nAll arrays and operators are passed through the device function. This allows for performing computations on a different device than the host (CPU). To compute on an Nvidia GPU using CUDA, change\n\nsolve_unsteady(setup, V₀, p₀, tlims; kwargs...)\n\nto the following:\n\nusing CUDA\nsolve_unsteady(\n    setup, V₀, p₀, tlims;\n    device = cu,\n    kwargs...\n)\n\nNote that the state observable passed to the processor.initialize function contains vector living on the device, and you may have to move them back to the host using Array(V) and Array(p) in the processor.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_steady_state","page":"API","title":"IncompressibleNavierStokes.solve_steady_state","text":"function solve_steady_state(\n    setup, V₀, p₀;\n    jacobian_type = :newton,\n    npicard = 2,\n    abstol = 1e-10,\n    maxiter = 10,\n)\n\nSolve steady state problem of the Navier-Stokes equations. This saddlepoint system arises from linearization of the convective terms.\n\nEach processor is called after every processor.nupdate iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Pressure-solvers","page":"API","title":"Pressure solvers","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"AbstractPressureSolver\nDirectPressureSolver\nCGPressureSolver\nSpectralPressureSolver\npressure_additional_solve\npressure_additional_solve!\npressure_poisson\npressure_poisson!","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.AbstractPressureSolver","page":"API","title":"IncompressibleNavierStokes.AbstractPressureSolver","text":"AbstractPressureSolver\n\nPressure solver for the Poisson equation.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.DirectPressureSolver","page":"API","title":"IncompressibleNavierStokes.DirectPressureSolver","text":"DirectPressureSolver()\n\nDirect pressure solver using a LU decomposition.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.CGPressureSolver","page":"API","title":"IncompressibleNavierStokes.CGPressureSolver","text":"CGPressureSolver(setup; [abstol], [reltol], [maxiter])\n\nConjugate gradients iterative pressure solver.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.SpectralPressureSolver","page":"API","title":"IncompressibleNavierStokes.SpectralPressureSolver","text":"SpectralPressureSolver(setup)\n\nBuild spectral pressure solver from setup.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.pressure_additional_solve","page":"API","title":"IncompressibleNavierStokes.pressure_additional_solve","text":"pressure_additional_solve(pressure_solver, V, p, t, setup; bc_vectors = nothing)\n\nDo additional pressure solve. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.pressure_additional_solve!","page":"API","title":"IncompressibleNavierStokes.pressure_additional_solve!","text":"pressure_additional_solve!(pressure_solver, V, p, t, setup, momentum_cache, F, f; bc_vectors)\n\nDo additional pressure solve. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.pressure_poisson","page":"API","title":"IncompressibleNavierStokes.pressure_poisson","text":"pressure_poisson(solver, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also pressure_poisson!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.pressure_poisson!","page":"API","title":"IncompressibleNavierStokes.pressure_poisson!","text":"pressure_poisson!(solver, p, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nMutating/non-allocating/in-place version.\n\nSee also pressure_poisson.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Time-steppers","page":"API","title":"Time steppers","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"AbstractODEMethod\nAbstractRungeKuttaMethod\nAdamsBashforthCrankNicolsonMethod\nOneLegMethod\nExplicitRungeKuttaMethod\nImplicitRungeKuttaMethod\n\nisexplicit\nlambda_conv_max\nlambda_diff_max\nnstage\node_method_cache\nrunge_kutta_method\nstep\nstep!","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.AbstractODEMethod","page":"API","title":"IncompressibleNavierStokes.AbstractODEMethod","text":"AbstractODEMethod\n\nAbstract ODE method.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.AbstractRungeKuttaMethod","page":"API","title":"IncompressibleNavierStokes.AbstractRungeKuttaMethod","text":"AbstractRungeKuttaMethod\n\nAbstract Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","page":"API","title":"IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","text":"AdamsBashforthCrankNicolsonMethod(\n    T = Float64;\n    α₁ = T(3 // 2),\n    α₂ = T(-1 // 2),\n    θ = T(1 // 2),\n    p_add_solve = true,\n    method_startup = RK44(; T),\n)\n\nIMEX AB-CN: Adams-Bashforth for explicit convection (parameters α₁ and α₂) and Crank-Nicolson for implicit diffusion (implicitness θ). The method is second order for θ = 1/2.\n\nThe LU decomposition of the LHS matrix is computed every time the time step changes.\n\nNote that, in constrast to explicit methods, the pressure from previous time steps has an influence on the accuracy of the velocity.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.OneLegMethod","page":"API","title":"IncompressibleNavierStokes.OneLegMethod","text":"OneLegMethod(\n    T = Float64;\n    β = T(1 // 2),\n    p_add_solve = true,\n    method_startup = RK44(; T),\n)\n\nExplicit one-leg β-method following symmetry-preserving discretization of turbulent flow. See Verstappen and Veldman [8] [9] for details.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.ExplicitRungeKuttaMethod","page":"API","title":"IncompressibleNavierStokes.ExplicitRungeKuttaMethod","text":"ExplicitRungeKuttaMethod(; A, b, c, r, p_add_solve = true)\n\nExplicit Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.ImplicitRungeKuttaMethod","page":"API","title":"IncompressibleNavierStokes.ImplicitRungeKuttaMethod","text":"ImplicitRungeKuttaMethod(;\n    A,\n    b,\n    c,\n    r,\n    newton_type = :full,\n    maxiter = 10,\n    abstol = 1e-14,\n    reltol = 1e-14,\n    p_add_solve = true,\n)\n\nImplicit Runge Kutta method.\n\nThe implicit linear system is solved at each time step using Newton's method. The newton_type may be one of the following:\n\n:no: Replace iteration matrix with I/Δt (no Jacobian)\n:approximate: Build Jacobian once before iterations only\n:full: Build Jacobian at each iteration\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.isexplicit","page":"API","title":"IncompressibleNavierStokes.isexplicit","text":"isexplicit(method)\n\nReturn true if method is explicit, i.e. the value at a certain time step is given explicitly as a function of the previous time steps only.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.lambda_conv_max","page":"API","title":"IncompressibleNavierStokes.lambda_conv_max","text":"lambda_conv_max(method)\n\nGet maximum value of stability region for the convection operator (not a very good indication for the methods that do not include the imaginary axis)\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.lambda_diff_max","page":"API","title":"IncompressibleNavierStokes.lambda_diff_max","text":"lambda_diff_max(method)\n\nGet maximum value of stability region for the diffusion operator.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.nstage","page":"API","title":"IncompressibleNavierStokes.nstage","text":"nstage(rk_method)\n\nGet number of stages of the Runge-Kutta method.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.ode_method_cache","page":"API","title":"IncompressibleNavierStokes.ode_method_cache","text":"ode_method_cache(method, setup)\n\nGet time stepper cache for the given ODE method.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.runge_kutta_method","page":"API","title":"IncompressibleNavierStokes.runge_kutta_method","text":"runge_kutta_method(A, b, c, r; [p_add_solve], [newton_type], [maxiter], [abstol], [reltol])\n\nGet Runge Kutta method. The function checks whether the method is explicit.\n\np_add_solve: whether to add a pressure solve step to the method.\n\nFor implicit RK methods: newton_type, maxiter, abstol, reltol.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.step","page":"API","title":"IncompressibleNavierStokes.step","text":"step(stepper, Δt; bc_vectors = nothing)\n\nPerform one time step.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also step!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.step!","page":"API","title":"IncompressibleNavierStokes.step!","text":"step!(stepper, Δt; cache, momentum_cache, bc_vectors = nothing)\n\nPerform one time step>\n\nMutating/non-allocating/in-place version.\n\nSee also step.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"filter_convection\nfilter_convection!\nget_lims","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.filter_convection","page":"API","title":"IncompressibleNavierStokes.filter_convection","text":"filter_convection(u, diff_matrix, bc, α)\n\nConstruct filter for convective terms.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also filter_convection!.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.filter_convection!","page":"API","title":"IncompressibleNavierStokes.filter_convection!","text":"filter_convection!(ū, u, diff_matrix, bc, α)\n\nConstruct filter for convective terms.\n\nMutating/non-allocating/in-place version.\n\nSee also filter_convection.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_lims","page":"API","title":"IncompressibleNavierStokes.get_lims","text":"get_lims(x, n = 1.5)\n\nGet approximate lower and upper limits of a field x based on the mean and standard deviation (mu pm n sigma). If x is constant, a margin of 1e-4 is enforced. This is required for contour plotting functions that require a certain range.\n\n\n\n\n\n","category":"function"},{"location":"features/precision/#Floating-point-precision","page":"Floating point precision","title":"Floating point precision","text":"","category":"section"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"IncompressibleNavierStokes generates efficient code for different floating point precisions, such as","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"Double precision (Float64)\nSingle precision (Float32)\nHalf precision (Float16)","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"To use single or half precision, all user input floats should be converted to the desired type. Mixing different precisions causes unnecessary conversions and may break the code. See the tutorial for an example on how to enforce floating point type hygiene.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: GPU precision\nFor GPUs, single precision is preferred. CUDA.jls cu converts to single precision.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: Pressure solvers\nSparseArrays.jls sparse matrix factorizations only support double precision. DirectPressureSolver only works for Float64. Consider using an iterative solver such as CGPressureSolver when using single or half precision.","category":"page"}]
}
