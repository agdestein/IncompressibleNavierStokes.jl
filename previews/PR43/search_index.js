var documenterSearchIndex = {"docs":
[{"location":"features/closure/#Neural-closure-models","page":"Neural closure models","title":"Neural closure models","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"For large eddy simulation (LES), a closure model is required. With IncompressibleNavierStokes, a neural closure model can be trained on filtered DNS data. The discrete DNS equations are given by","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM u  = 0 \nfracmathrmd umathrmd t  = F(u) - G p\nendsplit","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"Applying a spatial filter Phi, the extracted large scale components baru = Phi u are governed by the equation","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM baru  = 0 \nfracmathrmd barumathrmd t  = F(baru) + c - G barp\nendsplit","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"where the discretizations M, F, and G are adapted to the size of their inputs and c = overlineF(u) - F(baru) is a commutator error. We here assumed that M and Phi commute, which is the case for face averaging filters. Replacing c with a parameterized closure model m(baru theta) approx c gives the LES equations for the approximate large scale velocity barv approx baru","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM barv  = 0 \nfracmathrmd barvmathrmd t  = F(barv) + m(barv theta) - G barq\nendsplit","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"IncompressibleNavierStokes.FaceAverage\nIncompressibleNavierStokes.VolumeAverage","category":"page"},{"location":"features/closure/#IncompressibleNavierStokes.FaceAverage","page":"Neural closure models","title":"IncompressibleNavierStokes.FaceAverage","text":"(::FaceAverage)(v, u, setup_les)\n\nAverage fine grid u over coarse volume face. Put result in v.\n\n\n\n\n\n","category":"type"},{"location":"features/closure/#IncompressibleNavierStokes.VolumeAverage","page":"Neural closure models","title":"IncompressibleNavierStokes.VolumeAverage","text":"(::VolumeAverage)(v, u, setup_les, comp)\n\nAverage fine grid u over coarse volume. Put result in v.\n\n\n\n\n\n","category":"type"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.NeuralClosure\nNeuralClosure.filtersaver\nNeuralClosure.create_les_data\nNeuralClosure.create_io_arrays","category":"page"},{"location":"features/closure/#NeuralClosure.NeuralClosure","page":"Neural closure models","title":"NeuralClosure.NeuralClosure","text":"Neural closure modelling tools.\n\n\n\n\n\n","category":"module"},{"location":"features/closure/#NeuralClosure.filtersaver","page":"Neural closure models","title":"NeuralClosure.filtersaver","text":"filtersaver(dns, les, filters, compression, psolver_dns, psolver_les; nupdate = 1)\n\nSave filtered DNS data.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_les_data","page":"Neural closure models","title":"NeuralClosure.create_les_data","text":"create_les_data(\n    D = 2,\n    Re = 2e3,\n    lims = ntuple(α -> (typeof(Re)(0), typeof(Re)(1)), D),\n    nles = [ntuple(α -> 64, D)],\n    ndns = ntuple(α -> 256, D),\n    filters = (FaceAverage(),),\n    tburn = typeof(Re)(0.1),\n    tsim = typeof(Re)(0.1),\n    Δt = typeof(Re)(1e-4),\n    PSolver = SpectralPressureSolver,\n    savefreq = 1,\n    ArrayType = Array,\n    icfunc = (setup, psolver) -> random_field(setup, typeof(Re)(0); psolver),\n    rng,\n    kwargs...,\n)\n\nCreate filtered DNS data.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_io_arrays","page":"Neural closure models","title":"NeuralClosure.create_io_arrays","text":"create_io_arrays(data, setups)\n\nCreate (baru c) pairs for training.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#Training","page":"Neural closure models","title":"Training","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"To improve the model parameters, we exploit exact filtered DNS data baru and exact commutator errors c obtained through DNS. The model is trained by minimizing the a priori loss function","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"L^textprior(theta) =  m(baru theta) - c ^2","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"or the a posteriori loss function","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"L^textpost(theta) =  barv_theta - baru ^2","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"where barv_theta is the solution to the LES equation for the given parameters theta. The prior loss is easy to evaluate and easy to differentiate, as it does not involve solving the ODE. However, minimizing L^textprior does not take into account the effect of the prediction error on the LES solution error. The posterior loss does, but has a longer computational chain involving solving the LES ODE.","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.create_dataloader_prior\nNeuralClosure.create_dataloader_post\nNeuralClosure.train\nNeuralClosure.create_loss_prior\nNeuralClosure.create_relerr_prior\nNeuralClosure.mean_squared_error\nNeuralClosure.create_loss_post\nNeuralClosure.create_relerr_post\nNeuralClosure.create_callback","category":"page"},{"location":"features/closure/#NeuralClosure.create_dataloader_prior","page":"Neural closure models","title":"NeuralClosure.create_dataloader_prior","text":"createdataloader(data; nuse = 50, device = identity, rng)\n\nCreate dataloader that uses a batch of batchsize random samples from data at each evaluation. The batch is moved to device.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_dataloader_post","page":"Neural closure models","title":"NeuralClosure.create_dataloader_post","text":"create_dataloader_post(trajectories; nunroll = 10, device = identity, rng)\n\nCreate trajectory dataloader.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.train","page":"Neural closure models","title":"NeuralClosure.train","text":"train(\n    dataloaders,\n    loss,\n    opt,\n    θ;\n    niter = 100,\n    ncallback = 1,\n    callback = (i, θ) -> println(\"Iteration $i of $niter\"),\n)\n\nUpdate parameters θ to minimize loss(dataloader(), θ) using the optimiser opt for niter iterations.\n\nReturn the a new named tuple (; opt, θ, callbackstate) with updated state and parameters.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_loss_prior","page":"Neural closure models","title":"NeuralClosure.create_loss_prior","text":"createloss_prior(loss, f)\n\nWrap loss function loss(batch, θ).\n\nThe function loss should take inputs like loss(f, x, y, θ).\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_relerr_prior","page":"Neural closure models","title":"NeuralClosure.create_relerr_prior","text":"create_relerr_prior(f, x, y)\n\nCreate a-priori error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.mean_squared_error","page":"Neural closure models","title":"NeuralClosure.mean_squared_error","text":"mean_squared_error(f, x, y, θ; normalize = y -> sum(abs2, y), λ = sqrt(eps(eltype(x))))\n\nCompute MSE between f(x, θ) and y.\n\nThe MSE is further divided by normalize(y).\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_loss_post","page":"Neural closure models","title":"NeuralClosure.create_loss_post","text":"create_loss_post(;\n    setup,\n    method = RK44(; T = eltype(setup.grid.x[1])),\n    psolver,\n    closure,\n    nupdate = 1,\n    projectorder = :last,\n)\n\nCreate a-posteriori loss function.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_relerr_post","page":"Neural closure models","title":"NeuralClosure.create_relerr_post","text":"create_relerr_post(;\n    data,\n    setup,\n    method = RK44(; T = eltype(setup.grid.x[1])),\n    psolver,\n    closure_model,\n    nupdate = 1,\n)\n\nCreate a-posteriori relative error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_callback","page":"Neural closure models","title":"NeuralClosure.create_callback","text":"create_callback(\n    f,\n    x,\n    y;\n    state = Point2f[],\n    display_each_iteration = false,\n)\n\nCreate convergence plot for relative error between f(x, θ) and y. At each callback, plot is updated and current error is printed.\n\nIf state is nonempty, it also plots previous convergence.\n\nIf not using interactive GLMakie window, set display_each_iteration to true.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#Neural-architectures","page":"Neural closure models","title":"Neural architectures","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"We provide two neural architectures: A convolutional neural network (CNN) and a Fourier neural operator (FNO).","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.wrappedclosure\nNeuralClosure.create_closure\nNeuralClosure.create_tensorclosure\nNeuralClosure.collocate\nNeuralClosure.decollocate\nNeuralClosure.cnn\nNeuralClosure.fno\nNeuralClosure.FourierLayer","category":"page"},{"location":"features/closure/#NeuralClosure.wrappedclosure","page":"Neural closure models","title":"NeuralClosure.wrappedclosure","text":"wrappedclosure(m, setup)\n\nWrap closure model and parameters so that it can be used in the solver.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_closure","page":"Neural closure models","title":"NeuralClosure.create_closure","text":"create_closure(layers...; rng)\n\nCreate neural closure model from layers.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_tensorclosure","page":"Neural closure models","title":"NeuralClosure.create_tensorclosure","text":"create_tensorclosure(layers...; setup, rng)\n\nCreate tensor basis closure.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.collocate","page":"Neural closure models","title":"NeuralClosure.collocate","text":"collocate(u)\n\nInterpolate velocity components to volume centers.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.decollocate","page":"Neural closure models","title":"NeuralClosure.decollocate","text":"decollocate(u)\n\nInterpolate closure force from volume centers to volume faces.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.cnn","page":"Neural closure models","title":"NeuralClosure.cnn","text":"cnn(;\n    setup,\n    radii,\n    channels,\n    activations,\n    use_bias,\n    channel_augmenter = identity,\n    rng = Random.default_rng(),\n)\n\nCreate CNN closure model. Return a tuple (closure, θ) where θ are the initial parameters and closure(u, θ) predicts the commutator error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.fno","page":"Neural closure models","title":"NeuralClosure.fno","text":"fno(; setup, kmax, c, σ, ψ, rng = Random.default_rng(), kwargs...)\n\nCreate FNO closure model. Return a tuple (closure, θ) where θ are the initial parameters and closure(V, θ) predicts the commutator error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.FourierLayer","page":"Neural closure models","title":"NeuralClosure.FourierLayer","text":"FourierLayer(dimension, kmax, cin => cout; σ = identity, init_weight = glorot_uniform)\n\nFourier layer operating on uniformly discretized functions.\n\nSome important sizes:\n\ndimension: Spatial dimension, e.g. Dimension(2) or Dimension(3).\n(nx..., cin, nsample): Input size\n(nx..., cout, nsample): Output size\nnx = fill(n, dimension()): Number of points in each spatial dimension\nn ≥ kmax: Same number of points in each spatial dimension, must be larger than cut-off wavenumber\nkmax: Cut-off wavenumber\nnsample: Number of input samples (treated independently)\n\n\n\n\n\n","category":"type"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"D. Kochkov, J. A. Smith, A. Alieva, Q. Wang, M. P. Brenner and S. Hoyer. Machine learning-accelerated computational fluid dynamics. Proceedings of the National Academy of Sciences 118 (2021).\n\n\n\nM. Kurz, P. Offenhäuser and A. Beck. Deep Reinforcement Learning for Turbulence Modeling in Large Eddy Simulations, arXiv (2022).\n\n\n\nB. List, L.-W. Chen and N. Thuerey. Learned Turbulence Modelling with Differentiable Fluid Solvers, arxiv:2202.06988 (2022).\n\n\n\nF. H. Harlow and J. E. Welch. *         Numerical Calculation of Time‐Dependent Viscous Incompressible Flow         of Fluid with Free Surface     *. The Physics of Fluids 8, 2182–2189 (1965), arXiv:https://aip.scitation.org/doi/pdf/10.1063/1.1761178.\n\n\n\nB. Sanderse and B. Koren. Accuracy analysis of explicit Runge–Kutta methods applied to the incompressible Navier–Stokes equations. Journal of Computational Physics 231, 3041–3063 (2012).\n\n\n\nB. Sanderse. Energy-conserving Runge–Kutta methods for the incompressible Navier–Stokes equations. Journal of Computational Physics 233, 100–131 (2013).\n\n\n\nB. Sanderse, R. Verstappen and B. Koren. Boundary treatment for fourth-order staggered mesh discretizations of the incompressible Navier–Stokes equations. Journal of Computational Physics 257, 1472–1505 (2014). Physics-compatible numerical methods.\n\n\n\nR. W. Verstappen and A. E. Veldman. Symmetry-Preserving Discretization of Turbulent Flow. J. Comput. Phys. 187, 343–368 (2003).\n\n\n\nR. Verstappen and A. Veldman. Direct Numerical Simulation of Turbulence at Lower Costs. Journal of Engineering Mathematics 32, 143–159 (1997).\n\n\n\nJ. Li and P. M. Carrica. A simple approach for vortex core visualization, arXiv:1910.06998 (2019), arXiv:1910.06998 [physics.flu-dyn].\n\n\n\nJ. Jeong and F. Hussain. On the identification of a vortex. J. Fluid. Mech. 285, 69–94 (1995).\n\n\n\nB. Sanderse and F. X. Trias. Energy-consistent discretization of viscous dissipation with application       to natural convection flow (Jul 2023), arXiv:2307.10874v1 [physics.flu-dyn].\n\n\n\nM. H. Silvis, R. A. Remmerswaal and R. Verstappen. Physical consistency of subgrid-scale models for large-eddy simulation of incompressible turbulent flows. Physics of Fluids 29 (2017).\n\n\n\nP. Orlandi. Fluid flow phenomena: a numerical toolkit. Vol. 55 (Springer Science & Business Media, 2000).\n\n\n\nO. San and A. E. Staples. High-order methods for decaying two-dimensional homogeneous isotropic turbulence. Computers & Fluids 63, 105–127 (2012).\n\n\n\n","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"equations/time/#Time-discretization","page":"Time discretization","title":"Time discretization","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"The spatially discretized Navier-Stokes equations form a differential-algebraic system, with an ODE for the velocity","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"fracmathrmd umathrmd t = F(u t) - (G p + y_G)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"subject to the algebraic constraint formed by the mass equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"M u + y_M = 0","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"In the end of the previous section, we differentiated the mass equation in time to obtain a discrete pressure Poisson equation. This equation includes the term fracmathrmd y_Mmathrmd t, which is non-zero if an unsteady flow of mass is added to the domain (Dirichlet boundary conditions). This term ensures that the time-continuous discrete velocity field u(t) stays divergence free (conserves mass). However, if we directly discretize this system in time, the mass preservation may actually not be respected. For this, we will change the definition of the pressure such that the time-discretized velocity field is divergence free at each time step and each time sub-step (to be defined in the following).","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the interval 0 T for some simulation time T. We will divide it into N sub-intervals t^n t^n + 1 for n = 0 dots N - 1, with t^0 = 0, t^N = T, and increment Delta t^n = t^n + 1 - t^n. We define u^n approx u(t^n) as an approximation to the exact discrete velocity field u(t^n), with u^0 = u(0) starting from the exact initial conditions. We say that the time integration scheme (definition of u^n) is accurate to the order r if u^n = u(t^n) + mathcalO(Delta t^r) for all n.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"IncompressibleNavierStokes provides a collection of explicit and implicit Runge-Kutta methods, in addition to Adams-Bashforth Crank-Nicolson and one-leg beta method time steppers.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"The code is currently not adapted to time steppers from DifferentialEquations.jl, but they may be integrated in the future.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"AbstractODEMethod\nAbstractRungeKuttaMethod\nisexplicit\nlambda_conv_max\nlambda_diff_max\node_method_cache\nnstage\nrunge_kutta_method\ntimestep\ntimestep!","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.AbstractODEMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AbstractODEMethod","text":"AbstractODEMethod\n\nAbstract ODE method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#IncompressibleNavierStokes.AbstractRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AbstractRungeKuttaMethod","text":"AbstractRungeKuttaMethod\n\nAbstract Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#IncompressibleNavierStokes.isexplicit","page":"Time discretization","title":"IncompressibleNavierStokes.isexplicit","text":"isexplicit(method)\n\nReturn true if method is explicit, i.e. the value at a certain time step is given explicitly as a function of the previous time steps only.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.lambda_conv_max","page":"Time discretization","title":"IncompressibleNavierStokes.lambda_conv_max","text":"lambda_conv_max(method)\n\nGet maximum value of stability region for the convection operator (not a very good indication for the methods that do not include the imaginary axis)\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.lambda_diff_max","page":"Time discretization","title":"IncompressibleNavierStokes.lambda_diff_max","text":"lambda_diff_max(method)\n\nGet maximum value of stability region for the diffusion operator.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.ode_method_cache","page":"Time discretization","title":"IncompressibleNavierStokes.ode_method_cache","text":"ode_method_cache(method, setup)\n\nGet time stepper cache for the given ODE method.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.nstage","page":"Time discretization","title":"IncompressibleNavierStokes.nstage","text":"nstage(rk_method)\n\nGet number of stages of the Runge-Kutta method.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.runge_kutta_method","page":"Time discretization","title":"IncompressibleNavierStokes.runge_kutta_method","text":"runge_kutta_method(A, b, c, r; [p_add_solve], [newton_type], [maxiter], [abstol], [reltol])\n\nGet Runge Kutta method. The function checks whether the method is explicit.\n\np_add_solve: whether to add a pressure solve step to the method.\n\nFor implicit RK methods: newton_type, maxiter, abstol, reltol.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.timestep","page":"Time discretization","title":"IncompressibleNavierStokes.timestep","text":"step(stepper, Δt; bc_vectors = nothing)\n\nPerform one time step.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also timestep!.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.timestep!","page":"Time discretization","title":"IncompressibleNavierStokes.timestep!","text":"step!(stepper, Δt; cache, momentum_cache, bc_vectors = nothing)\n\nPerform one time step>\n\nMutating/non-allocating/in-place version.\n\nSee also timestep.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#Explicit-Runge-Kutta-methods","page":"Time discretization","title":"Explicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [5].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the velocity field u_0 at a certain time t_0. We will now perform one time step to t = t_0 + Delta t. For explicit Runge-Kutta methods, this time step is divided into s sub-steps t_i = t_0 + Delta t_i with increment Delta t_i = c_i Delta t. The final substep performs the full time step Delta t_s = Delta t such that t_s = t.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"For i = 1 dots s, the intermediate velocity u_i and pressure p_i are computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nk_i  = F(u_i - 1 t_i - 1) - y_G(t_i - 1) \nv_i  = u_0 + Delta t sum_j = 1^i a_i j k_j \nL p_i  = W M frac1c_i sum_j = 1^i a_i j k_j +\nW fracy_M(t_i) - y_M(t_0)Delta t_i \n = W frac(M v_i + y_M(t_i)) - (M u_0 + y_M(t_0))Delta t_i^n \n = W fracM v_i + y_M(t_i)Delta t_i^n \nu_i  = v_i - Delta t_i G p_i\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where (a_i j)_i j are the Butcher tableau coefficients of the RK-method, with the convention c_i = sum_j = 1^i a_i j.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, we return u_s. If u_0 = u(t_0), we get the accuracy u_s = u(t) + mathcalO(Delta t^r + 1), where r is the order of the RK-method. If we perform n RK time steps instead of one, starting at exact initial conditions u^0 = u(0), then u^n = u(t^n) + mathcalO(Delta t^r) for all n in 1 dots N. Note that for a given u, the corresponding pressure p can be calculated to the same accuracy as u by doing an additional pressure projection after each outer time step Delta t (if we know fracmathrmd y_Mmathrmd t(t)), or to first order accuracy by simply returning p_s.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Note that each of the sub-step velocities u_i is divergence free, after projecting the tentative velocities v_i. This is ensured due to the judiciously chosen replacement of fracmathrmd y_Mmathrmd t(t_i) with (y_M(t_i) - y_M(t_0))  Delta t_i. The space-discrete divergence-freeness is thus perfectly preserved, even though the time discretization introduces other errors.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"ExplicitRungeKuttaMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.ExplicitRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.ExplicitRungeKuttaMethod","text":"ExplicitRungeKuttaMethod(; A, b, c, r, p_add_solve = true)\n\nExplicit Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#Implicit-Runge-Kutta-methods","page":"Time discretization","title":"Implicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [6].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"ImplicitRungeKuttaMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.ImplicitRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.ImplicitRungeKuttaMethod","text":"ImplicitRungeKuttaMethod(;\n    A,\n    b,\n    c,\n    r,\n    newton_type = :full,\n    maxiter = 10,\n    abstol = 1e-14,\n    reltol = 1e-14,\n    p_add_solve = true,\n)\n\nImplicit Runge Kutta method.\n\nThe implicit linear system is solved at each time step using Newton's method. The newton_type may be one of the following:\n\n:no: Replace iteration matrix with I/Δt (no Jacobian)\n:approximate: Build Jacobian once before iterations only\n:full: Build Jacobian at each iteration\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#Adams-Bashforth-Crank-Nicolson-method","page":"Time discretization","title":"Adams-Bashforth Crank-Nicolson method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. This methods uses Adams-Bashforth for the convective terms and Crank-Nicolson stepping for the diffusion and body force terms. Given the velocity field u_0 = u(t_0) at a time t_0 and its previous value u_-1 = u(t_0 - Delta t) at the previous time t_-1 = t_0 - Delta t, the predicted velocity field u at the time t = t_0 + Delta t is defined by first computing a tentative velocity:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nfracv - u_0Delta t\n = - (alpha_0 C(u_0 t_0) + alpha_-1 C(u_-1 t_-1)) \n + theta (D u_0 + y_D(t_0)) + (1 - theta) (D v + y_D(t)) \n + theta f(t_0) + (1 - theta) f(t) \n - (G p_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where theta in 0 1 is the Crank-Nicolson parameter (theta = frac12 for second order convergence), (alpha_0 alpha_-1) = left( frac32 -frac12 right) are the Adams-Bashforth coefficients, and v is a tentative velocity yet to be made divergence free. We can group the terms containing v on the left hand side, to obtain","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nleft( frac1Delta t I - (1 - theta) D right) v\n = left(frac1Delta t I - theta D right) u_0 \n - (alpha_0 C(u_0 t_0) + alpha_-1 C(u_-1 t_-1)) \n + theta y_D(t_0) + (1 - theta) y_D(t) \n + theta f(t_0) + (1 - theta) f(t) \n - (G p_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We can compute v by inverting the positive definite matrix left( frac1Delta t I - theta D right) for the given right hand side using a suitable linear solver. Assuming Delta t is constant, we can precompute a Cholesky factorization of this matrix before starting time stepping.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We then compute the pressure difference Delta p by solving","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta p = W fracM v + y_M(t)Delta t - W M (y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"after which a divergence free velocity u can be enforced:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"u = v - Delta t (G Delta p + y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A first order accurate prediction of the corresponding pressure is p = p_0 + Delta p. However, since this pressure is reused in the next time step, we perform an additional pressure solve to avoid accumulating first order errors. The resulting pressure p is then accurate to the same order as u.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"AdamsBashforthCrankNicolsonMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","text":"AdamsBashforthCrankNicolsonMethod(\n    T = Float64;\n    α₁ = T(3 // 2),\n    α₂ = T(-1 // 2),\n    θ = T(1 // 2),\n    p_add_solve = true,\n    method_startup = RK44(; T),\n)\n\nIMEX AB-CN: Adams-Bashforth for explicit convection (parameters α₁ and α₂) and Crank-Nicolson for implicit diffusion (implicitness θ). The method is second order for θ = 1/2.\n\nThe LU decomposition of the LHS matrix is computed every time the time step changes.\n\nNote that, in contrast to explicit methods, the pressure from previous time steps has an influence on the accuracy of the velocity.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#One-leg-beta-method","page":"Time discretization","title":"One-leg beta method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Verstappen and Veldman [8] [9].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. Given the velocity u_0 and pressure p_0 at the current time t_0 and their previous values u_-1 and p_-1 at the time t_-1 = t_0 - Delta t, we start by computing the \"offstep\" values v = (1 + beta) v_0 - beta v_-1 and Q = (1 + beta) p_0 - beta p_-1 for some beta = frac12.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A tentative velocity field tildev is then computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"tildev = frac1beta + frac12 left( 2 beta u_0 - left( beta -\nfrac12 right) u_-1 + Delta t F(v t) - Delta t\n(G Q + y_G(t)) right)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A pressure correction Delta p is obtained by solving the Poisson equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta p = fracbeta + frac12Delta t W (M tildev + y_M(t))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, the divergence free velocity field is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"u = tildev - fracDelta tbeta + frac12 G Delta p","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"while the second order accurate pressure is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"p = 2 p_0 - p_-1 + frac43 Delta p","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"OneLegMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.OneLegMethod","page":"Time discretization","title":"IncompressibleNavierStokes.OneLegMethod","text":"OneLegMethod(\n    T = Float64;\n    β = T(1 // 2),\n    p_add_solve = true,\n    method_startup = RK44(; T),\n)\n\nExplicit one-leg β-method following symmetry-preserving discretization of turbulent flow. See Verstappen and Veldman [8] [9] for details.\n\n\n\n\n\n","category":"type"},{"location":"features/gpu/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"IncompressibleNavierStokes supports various array types. The desired array type only has to be passed to the Setup function. All operators have been made are backend agnostic by using KernelAbstractions.jl. Even if a GPU is not available, the operators are multithreaded if  Julia is started with multiple threads (e.g. julia -t 4)","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"Limitations:","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"DirectPressureSolver is currently used on the CPU with double precision. CGPressureSolver works on the GPU.\nThis has not been tested with other GPU interfaces, such as\nAMDGPU.jl\nMetal.jl\noneAPI.jl\nIf they start supporting sparse matrices and fast Fourier transforms they could also be used. ","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"EditURL = \"../../../examples/LidDrivenCavity2D.jl\"","category":"page"},{"location":"generated/LidDrivenCavity2D/#Tutorial:-Lid-Driven-Cavity-2D","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity - 2D","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In this example we consider a box with a moving lid. The velocity is initially at rest. The solution should reach at steady state equilibrium after a certain time. The same steady state should be obtained when solving a steady state problem.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We start by loading packages. A Makie plotting backend is needed","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"output = \"output/LidDrivenCavity2D\"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The code allows for using different floating point number types, including single precision (Float32) and double precision (Float64). On the CPU, the speed is not really different, but double precision uses twice as much memory as single precision. When running on the GPU, single precision is preferred. Half precision (Float16) is also an option, but then the values should be scaled judiciously to avoid vanishing digits when applying differential operators of the form \"right minus left divided by small distance\".","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Note how floating point type hygiene is enforced in the following using T to avoid mixing different precisions.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"T = Float64\n# T = Float32\n# T = Float16","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can also choose to do the computations on a different device. By default, the computations are performed on the host (CPU). An optional ArrayType allows for moving arrays to a different device such as a GPU.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Note: For GPUs, single precision is preferred.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Here we choose a moderate Reynolds number. Note how we pass the floating point type.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Re = T(1_000)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Non-zero Dirichlet boundary conditions are specified as plain Julia functions. Note that time derivatives are required.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"boundary_conditions = (\n    # x left, x right\n    (DirichletBC(), DirichletBC()),\n\n    # y bottom, y top\n    (\n        DirichletBC(),\n        DirichletBC(\n            (dim, x, y, t) -> dim() == 1 ? one(x) : zero(x),\n            (dim, x, y, t) -> zero(x),\n        ),\n    ),\n)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We create a two-dimensional domain with a box of size [1, 1]. The grid is created as a Cartesian product between two vectors. We add a refinement near the walls.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"n = 32\nlims = T(0), T(1)\nx = cosine_grid(lims..., n)\ny = cosine_grid(lims..., n)\nplotgrid(x, y)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can now build the setup and assemble operators. A 3D setup is built if we also provide a vector of z-coordinates.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"setup = Setup(x, y; boundary_conditions, Re, ArrayType);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The pressure solver is used to solve the pressure Poisson equation. Available solvers are","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"DirectPressureSolver (only for CPU with Float64)\nCGPressureSolver\nSpectralPressureSolver (only for periodic boundary conditions and uniform grids)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"psolver = DirectPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The initial conditions are provided in function. The value dim() determines the velocity component.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"u₀ = create_initial_conditions(setup, (dim, x, y) -> zero(x); psolver);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/#Solve-problems","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Solve problems","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Problems can be solved.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The solve_steady_state function is for computing a state where the right hand side of the momentum equation is zero.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# u, p = solve_steady_state(setup, u₀, p₀)\nnothing","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"For this test case, the same steady state may be obtained by solving an unsteady problem for a sufficiently long time.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Iteration processors are called after every nupdate time steps. This can be useful for logging, plotting, or saving results. Their respective outputs are later returned by solve_unsteady.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"processors = (\n    # rtp = realtimeplotter(; setup, plot = fieldplot, nupdate = 50),\n    # ehist = realtimeplotter(; setup, plot = energy_history_plot, nupdate = 10),\n    # espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 10),\n    # anim = animator(; setup, path = \"$output/solution.mkv\", nupdate = 20),\n    # vtk = vtk_writer(; setup, nupdate = 100, dir = output, filename = \"solution\"),\n    # field = fieldsaver(; setup, nupdate = 10),\n    log = timelogger(; nupdate = 1000),\n);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"By default, a standard fourth order Runge-Kutta method is used. If we don't provide the time step explicitly, an adaptive time step is used.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"tlims = (T(0), T(10))\nstate, outputs = solve_unsteady(setup, u₀, tlims; Δt = T(1e-3), psolver, processors);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/#Post-process","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We may visualize or export the computed fields","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Export fields to VTK. The file output/solution.vti may be opened for visualization in ParaView. This is particularly useful for inspecting results from 3D simulations.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\"; psolver)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot pressure","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :pressure)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot velocity. Note the time stamp used for computing boundary conditions, if any.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :velocity)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :vorticity)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In addition, the named tuple outputs contains quantities from our processors. The logger returns nothing.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# outputs.rtp\n# outputs.ehist\n# outputs.espec\n# outputs.anim\n# outputs.vtk\n# outputs.field\noutputs.log","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"EditURL = \"../../../examples/PlanarMixing2D.jl\"","category":"page"},{"location":"generated/PlanarMixing2D/#Planar-mixing-2D","page":"Planar Mixing (2D)","title":"Planar mixing - 2D","text":"","category":"section"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Planar mixing example, as presented in [3].","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Output directory","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"output = \"output/PlanarMixing2D\"","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Viscosity model","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Re = 500.0","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Boundary conditions: Unsteady BC requires time derivatives","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"ΔU = 1.0\nUbar = 1.0\nϵ = (0.082Ubar, 0.012Ubar)\nn = (0.4π, 0.3π)\nω = (0.22, 0.11)\nU(dim, x, y, t) =\n    dim() == 1 ?\n    1.0 + ΔU / 2 * tanh(2y) + sum(@. ϵ * (1 - tanh(y / 2)^2) * cos(n * y) * sin(ω * t)) :\n    0.0\ndUdt(dim, x, y, t) =\n    dim() == 1 ? sum(@. ϵ * (1 - tanh(y / 2)^2) * cos(n * y) * ω * cos(ω * t)) : 0.0\nboundary_conditions = (\n    # x left, x right\n    (DirichletBC(U, dUdt), PressureBC()),\n\n    # y rear, y front\n    (PressureBC(), PressureBC()),\n)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"n = 64\n# n = 256\nx = LinRange(0.0, 256.0, 4n)\ny = LinRange(-32.0, 32.0, n)\nplotgrid(x, y)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"setup = Setup(x, y; Re, boundary_conditions);\npsolver = DirectPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"u₀ = create_initial_conditions(setup, (dim, x, y) -> U(dim, x, y, 0.0); psolver);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"state, outputs = solve_unsteady(\n    setup,\n    u₀,\n    (0.0, 100.0);\n    psolver,\n    method = RK44P2(),\n    Δt = 0.1,\n    processors = (\n        rtp = realtimeplotter(;\n            setup,\n            plot = fieldplot,\n            # plot = energy_history_plot,\n            # plot = energy_spectrum_plot,\n            nupdate = 1,\n        ),\n        # anim = animator(; setup, path = \"$output/vorticity.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = output, filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 1),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/PlanarMixing2D/#Post-process","page":"Planar Mixing (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"We may visualize or export the computed fields (u, p)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"outputs.rtp","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"Export to VTK","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\"; psolver)","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"","category":"page"},{"location":"generated/PlanarMixing2D/","page":"Planar Mixing (2D)","title":"Planar Mixing (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"EditURL = \"../../../examples/BackwardFacingStep2D.jl\"","category":"page"},{"location":"generated/BackwardFacingStep2D/#Backward-Facing-Step-2D","page":"Walls: Backward Facing Step (2D)","title":"Backward Facing Step - 2D","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"In this example we consider a channel with walls at the top and bottom, and a step at the left with a parabolic inflow. Initially the velocity is an extension of the inflow, but as time passes the velocity finds a new steady state.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Output directory","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"output = \"output/BackwardFacingStep2D\"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Floating point type","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"T = Float64","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Array type","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Reynolds number","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Re = T(3_000)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Boundary conditions: steady inflow on the top half","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"U(dim, x, y, t) =\n    dim() == 1 && y ≥ 0 ? 24y * (one(x) / 2 - y) : zero(x) + randn(typeof(x)) / 1_000\ndUdt(dim, x, y, t) = zero(x)\nboundary_conditions = (\n    # x left, x right\n    (DirichletBC(U, dUdt), PressureBC()),\n\n    # y rear, y front\n    (DirichletBC(), DirichletBC()),\n)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"A 2D grid is a Cartesian product of two vectors. Here we refine the grid near the walls.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"x = LinRange(T(0), T(10), 301)\ny = cosine_grid(-T(0.5), T(0.5), 51)\nplotgrid(x, y)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"setup = Setup(x, y; Re, boundary_conditions, ArrayType);\n\npsolver = DirectPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"u₀ = create_initial_conditions(setup, (dim, x, y) -> U(dim, x, y, zero(x)); psolver);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Solve steady state problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"# u, p = solve_steady_state(setup, u₀, p₀);\nnothing","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"state, outputs = solve_unsteady(\n    setup,\n    u₀,\n    (T(0), T(7));\n    Δt = T(0.002),\n    psolver,\n    processors = (\n        rtp = realtimeplotter(;\n            setup,\n            plot = fieldplot,\n            # plot = energy_history_plot,\n            # plot = energy_spectrum_plot,\n            nupdate = 1,\n        ),\n        # anim = animator(; setup, path = \"$output/vorticity.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = output, filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 1),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/#Post-process","page":"Walls: Backward Facing Step (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"We may visualize or export the computed fields","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Export to VTK","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\"; psolver)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot pressure","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :pressure)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot velocity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :velocity)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :vorticity)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"EditURL = \"../../../examples/DecayingTurbulence2D.jl\"","category":"page"},{"location":"generated/DecayingTurbulence2D/#Decaying-Homogeneous-Isotropic-Turbulence-2D","page":"Decaying Turbulunce (2D)","title":"Decaying Homogeneous Isotropic Turbulence - 2D","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"In this example we consider decaying homogeneous isotropic turbulence, similar to the cases considered in [1] and [2]. The initial velocity field is created randomly, but with a specific energy spectrum. Due to viscous dissipation, the turbulent features eventually group to form larger visible eddies.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Output directory","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"output = \"output/DecayingTurbulence2D\"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Floating point precision","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"T = Float64","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Array type","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Viscosity model","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Re = T(10_000)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"n = 256\nlims = T(0), T(1)\nx = LinRange(lims..., n + 1), LinRange(lims..., n + 1)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"setup = Setup(x...; Re, ArrayType);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Since the grid is uniform and identical for x and y, we may use a specialized spectral pressure solver","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"psolver = SpectralPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Create random initial conditions","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"u₀ = random_field(setup, T(0); psolver);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"state, outputs = solve_unsteady(\n    setup,\n    u₀,\n    (T(0), T(1));\n    Δt = T(1e-3),\n    psolver,\n    processors = (\n        # rtp = realtimeplotter(; setup, nupdate = 1),\n        ehist = realtimeplotter(;\n            setup,\n            plot = energy_history_plot,\n            nupdate = 10,\n            displayfig = false,\n        ),\n        espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 10),\n        # anim = animator(; setup, path = \"$output/solution.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = output, filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 100),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/#Post-process","page":"Decaying Turbulunce (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"We may visualize or export the computed fields (u, p)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy history","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs.ehist","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy spectrum","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs.espec","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Export to VTK","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\"; psolver)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Plot field","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"fieldplot(state; setup)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"equations/spatial/#Spatial-Discretization","page":"Spatial discretization","title":"Spatial Discretization","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"To discretize the incompressible Navier-Stokes equations, we will use finite volumes on a staggered Cartesian grid, as proposed by Harlow and Welsh [4]. We will use the notation of Sanderse [5] [6] [7].","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Let d in 2 3 denote the spatial dimension (2D or 3D). We will make use of the \"Cartesian\" index I = (i j) in 2D or I = (i j k) in 3D, with I(1) = i, I(2) = j, and I(3) = k. Here, the indices I, i, j, and k, represent discrete degrees of freedom, and can take integer or half values (e.g. 3 or 52). To specify a spatial dimension, we will use the symbols (alpha beta gamma) in 1 dots d^3. We will use the symbol delta(alpha) = (delta_alpha beta)_beta = 1^d in 0 1^d to indicate a perturbation in the direction alpha, where delta_alpha beta is the Kronecker symbol. The spatial variable is x = (x^1 dots x^d) in Omega subset mathbbR^d.","category":"page"},{"location":"equations/spatial/#Finite-volumes","page":"Spatial discretization","title":"Finite volumes","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We here assume that Omega = prod_alpha = 1^d 0 L^alpha has the shape of a box with side lengths L^alpha  0. This allows for partitioning Omega into the finite volumes","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Omega_I = prod_alpha = 1^d left x^alpha_I(alpha) - frac12\nx^alpha_I(alpha) + frac12 right quad I in mathcalI","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Just like Omega itself, they represent rectangles in 2D and prisms n 3D. They are fully defined by the vectors of volume face coordinates x^alpha = left( x^alpha_i right)_i = 0^N(alpha) in mathbbR^N(alpha) + 1, where N = (N(1) dots N(d)) in mathbbN^d are the numbers of finite volumes in each dimension and mathcalI = prod_alpha = 1^d left frac12 2 - frac12 dots N(alpha) - frac12 right the set of finite volume indices (note that the reference volumes are indexed by half indices only). The components x^alpha_i are not assumed to be uniformly spaced. But we do assume that they are strictly increasing with i, with x^alpha_0 = 0 and x^alpha_N(alpha) = L^alpha.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The coordinates of the volume centers are determined from the those of the volume boundaries by x^alpha_I(alpha) = frac12 (x^alpha_I(alpha) - frac12 + x_I(alpha) + frac12) for I in mathcalI. This allows for defining shifted volumes such as Omega_I + delta(alpha)  2 and Omega_I + delta(alpha)  2 + delta(beta)  2. The original volumes (with indices in mathcalI) will be referred to as the reference finite volumes.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We also define the volume widths/depths/heights Delta x^alpha_i = x^alpha_i + frac12 - x^alpha_i - frac12, where i can take half values. The volume sizes are thus  Omega_I  = prod_alpha = 1^d Delta x^alpha_I(alpha). In addition to the finite volumes and their shifted variants, we define the interface Gamma^alpha_I = Omega_I - delta(alpha)  2 cup Omega_I + delta(alpha)  2.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In each reference finite volume Omega_I (I in mathcalI), there are three different types of positions in which quantities of interest can be defined:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The volume center x_I = (x_I(1) dots x_I(d)), where the discrete pressure p_I is defined;\nThe right/rear/top volume face centers x_I + delta(alpha)  2, where the discrete alpha-velocity component u^alpha_I + delta(alpha)  2 is defined;\nThe right-rear-top volume corner  x_I + sum_alpha delta(alpha)  2, where the discrete vorticity omega_I + sum_alpha delta(alpha)  2 is defined.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The vectors of unknowns u^alpha_h and p_h will not contain all the half-index components, only those from their own canonical position. The unknown discrete pressure represents the average pressure in each reference volume, and the unknown discrete velocity components represent exchange of mass between neighboring volumes.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, this finite volume configuration is illustrated as follows:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(Image: Grid)","category":"page"},{"location":"equations/spatial/#Interpolation","page":"Spatial discretization","title":"Interpolation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"When a quantity is required outside of its native point, we will use interpolation. Examples:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"To compute u^alpha at the pressure point x_I, I in mathcalI:\nbeginsplit\n    u^alpha_I  = fracx^alpha_I(alpha) + 1  2 -\n    x^alpha_I(alpha)x^alpha_I(alpha) + 1  2 - x^alpha_I(alpha) - 1  2\n    u_I - delta(alpha)  2\n    + fracx^alpha_I(alpha) - x^alpha_I(alpha) - 1  2x^alpha_I(alpha) + 1  2 - x^alpha_I(alpha) - 1  2\n    u_I + delta(alpha)  2 \n     = frac12 left( u_I - delta(alpha)  2 + u_I + delta(alpha)  2 right)\nendsplit\nInterpolation weights from volume faces to volume centers are always frac12.\nTo compute u^alpha at center of edge between alpha-face and beta-face x_I + delta(alpha)  2 + delta(beta)  2:\nu^alpha_I + delta(alpha)  2 + delta(beta)  2 =\nfracx^beta_I(beta) + 1 - x^beta_I(beta) + 1  2x^beta_I(beta) + 1 - x^beta_I(beta)\nu^alpha_I + delta(alpha)  2\n+ fracx^beta_I(beta) + 1  2 - x^beta_I(beta)x^beta_I(beta) + 1 - x^beta_I(beta)\nu^alpha_I + delta(alpha)  2 + delta(beta)\nNote that the grid is allowed to be non-uniform, so the interpolation weights may unequal and different from frac12.\nTo compute p at u^alpha-points:\np_I + delta(alpha)  2 =\nfracx^alpha_I(alpha) + 1 - x^alpha_I(alpha) + 1  2x^alpha_I(alpha) + 1 - x^alpha_I(alpha)\np_I\n+ fracx^alpha_I(alpha) + 1  2 - x^alpha_I(alpha)x^alpha_I(alpha) + 1 - x^alpha_I(alpha)\np_I + delta(alpha)","category":"page"},{"location":"equations/spatial/#Finite-volume-discretization-of-the-Navier-Stokes-equations","page":"Spatial discretization","title":"Finite volume discretization of the Navier-Stokes equations","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We will consider the integral form of the Navier-Stokes equations. This has the advantage that some of the spatial derivatives disappear, reducing the amount of finite difference approximations we need to perform.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We define the finite difference operator partial_alpha equivalent to the continuous operator fracpartialpartial x^alpha. For all fields discrete fields varphi, it is given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(partial_alpha varphi)_I = fracvarphi_I + delta(alpha)  2 - varphi_I -\ndelta(alpha)  2Delta^alpha_I(alpha)","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where varphi is interpolated first if necessary.","category":"page"},{"location":"equations/spatial/#Mass-equation","page":"Spatial discretization","title":"Mass equation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The mass equation takes the form","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"frac1 mathcalO \nint_partial mathcalO u cdot n  mathrmd Gamma = 0\nquad forall mathcalO subset Omega","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Using the pressure volume mathcalO = Omega_I, we get","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d\nfrac1 Omega_I \nleft( int_Gamma^alpha_I + delta(alpha)  2\nu^alpha  mathrmd Gamma - int_Gamma_I - delta(alpha)  2^alpha\nu^alpha  mathrmd Gamma\nright) = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Assuming that the flow is fully resolved, meaning that Omega_I is is sufficiently small such that u is locally linear, we can perform the local approximation (quadrature)","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"int_Gamma^alpha_I u^alpha  mathrmd Gamma approx  Gamma^alpha_I\n u^alpha_I","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This yields the discrete mass equation","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d (partial_alpha u^alpha)_I = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Approximation error\nFor the mass equation, the only approximation we have performed is quadrature. No interpolation or finite difference error is present.","category":"page"},{"location":"equations/spatial/#Momentum-equations","page":"Spatial discretization","title":"Momentum equations","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Grouping the convection, pressure gradient, diffusion, and body force terms in each of their own integrals, we get, for all mathcalO subset Omega:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\nfracmathrmdmathrmd t\nfrac1 mathcalO \nint_mathcalO u^alpha  mathrmd Omega\n=\n - sum_beta = 1^d\nfrac1 mathcalO \nint_partial mathcalO\nu^alpha u^beta n^beta\n mathrmd Gamma \n + nu sum_beta = 1^d\nfrac1 mathcalO \nint_partial mathcalO\nfracpartial u^alphapartial x^beta n^beta\n mathrmd Gamma \n + frac1 mathcalO \nint_mathcalO f^alpha mathrmd Omega \n - frac1 mathcalO \nint_partial mathcalO p n^alpha  mathrmd Gamma\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where n = (n^1 dots n^d) is the surface normal vector to partial mathcalO.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This time, we will not let mathcalO be the reference finite volume Omega_I (the p-volume), but rather the shifted u^alpha-volume. Setting mathcalO = Omega_I + delta(alpha)  2 (with right/rear/top beta-faces Gamma^beta_I + delta(alpha)  2 + delta(beta)  2) gives","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracmathrmdmathrmd t\n    frac1 Omega_I + delta(alpha)  2 \n    int_Omega_I + delta(alpha)  2\n       \n       \n       \n       \n    u^alpha  mathrmd Omega\n    =\n     -\n    sum_beta = 1^d\n    frac1 Omega_I + delta(alpha)  2 \n    left(\n        int_Gamma^beta_I + delta(alpha)  2 + delta(beta)  2\n               \n               \n               \n               \n        u^alpha u^beta  mathrmd Gamma \n        - int_Gamma^beta_I + delta(alpha)  2 - delta(beta)  2\n               \n               \n               \n               \n               \n               \n        u^alpha u^beta  mathrmd Gamma \n    right) \n     + nu sum_beta = 1^d \n    frac1 Omega_I + delta(alpha)  2 \n    left(\n        int_Gamma^beta_I + delta(alpha)  2 + delta(beta)  2\n        fracpartial u^alphapartial x^beta  mathrmd Gamma \n        - int_Gamma^beta_I + delta(alpha)  2 - delta(beta)  2\n        fracpartial u^alphapartial x^beta  mathrmd Gamma \n    right) \n     +\n    frac1 Omega_I + delta(alpha)  2 \n    int_Omega_I + delta(alpha)  2\n    f^alpha  mathrmd Omega \n     -\n    frac1 Omega_I + delta(alpha)  2 \n    left(\n        int_Gamma^alpha_I + delta(alpha) p  mathrmd Gamma -\n        int_Gamma^alpha_I p  mathrmd Gamma\n    right)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"This equation is still exact. We now introduce some approximations on Omega_I + delta(alpha)  2 and its boundaries to remove all unknown continuous quantities.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We replace the integrals with a mid-point quadrature rule.\nThe mid-point values of derivatives are approximated using a central-like finite difference:\nfracpartial u^alphapartial x^beta(x_I) approx (partial_beta u^alpha)_I\nQuantities outside their canonical positions are obtained through interpolation.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Finally, the discrete alpha-momentum equations are given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracmathrmd mathrmd t u^alpha_I + delta(alpha)  2 =\n    -  sum_beta = 1^d\n    (partial_beta (u^alpha u^beta))_I + delta(alpha)  2 \n    +  nu sum_beta = 1^d\n    (partial_beta partial_beta u^alpha)_I + delta(alpha)  2 \n    +  f^alpha(x_I + delta(alpha)  2 t)\n    - (partial_alpha p)_I + delta(alpha)  2\nendsplit","category":"page"},{"location":"equations/spatial/#Boundary-conditions","page":"Spatial discretization","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Depending on the type of boundary conditions, certain indices used in the left- and right hand sides of the equations may not be part of the solution vectors, even if they are indeed at their canonical positions. Consider for example the alpha-left/front/bottom boundary  x in Omega  x^alpha = x^alpha_0 . Let Omega_I be one of the reference finite volumes touching this boundary, i.e. I(alpha) = frac12.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"For periodic boundary conditions, we also consider the opposite boundary. We add two \"ghost\" reference volumes, one at each side of Omega:\nThe ghost volume Omega_I - delta(alpha) has the same shape as Omega_I + (N(alpha) - 1) delta(alpha) and contains the same components:\nu^alpha_I - delta(alpha)  2 = u^alpha_I + (N(alpha) - 1  2) delta(alpha),\nu^beta_I + delta(beta)  2 - delta(alpha) = u^beta_I + delta(beta)  2 + N(alpha) delta(alpha) for beta neq alpha,\np_I - delta(alpha) = p_I + (N(alpha) - 1) delta(alpha).\nThe ghost volume Omega_I + N(alpha) delta(alpha) has the same  shape as Omega_I and contains the same pressure and velocity components.\nFor Dirichlet boundary conditions, all the veloctity components are prescribed. For the normal velocity component, this is straightforward:\nu^alpha_I - delta(alpha)  2 = u^alpha(x_I - delta(alpha)  2)\nThe parallel (beta neq alpha) velocity components u^beta_I + delta(beta)  2 - delta(alpha) appear in some of the right hand side expressions. Their alpha position x^alpha_- 1  2 has actually never been defined, so we simply define it to be on the boundary itself: x^alpha_- 1  2 = x^alpha_0. The value can then be prescribed:\nu^beta_I + delta(beta)  2 - delta(alpha) = u^beta left( x_I +\ndelta(beta)  2 - delta(alpha) right) = u^beta left( x_I +\ndelta(beta)  2 - delta(alpha)  2 right)\nThe pressure does not require any boundary modifications.\nFor a symmetric boundary, the normal component has zero Dirichlet conditions, while the parallel components have zero Neumann conditions. For this, we add a ghost volume Omega_I - delta(alpha) which has the same shape as Omega_I, meaning that x^alpha_-1 = x^alpha_0 - (x^alpha_1 - x^alpha_0) = - x^alpha_1. The pressure in this volume is never used, but we set u^alpha_I - delta(alpha)  2 = 0 and u^beta_I + delta(beta)  2 - delta(alpha) = u^beta_I + delta(beta)  2 for beta neq alpha.\nFor a pressure boundary, the value of the pressure is prescribed, while the velocity has zero Neumann boundary conditions. For this, we add an infinitely thin ghost volume Omega_I - delta(alpha), by setting x^alpha_-1 = x^alpha_0 - epsilon for some epsilon. We then let this thickness go to zero after substituting the boundary conditions in the momentum equations. The pressure is prescribed by\np_I - delta(alpha) = p(x_I - delta(alpha)) undersetepsilon to 0to p(x_I - delta(alpha)  2)\nThe Neumann boundary conditions are obtained by setting u^alpha_I - 3  2 delta(alpha) = u^alpha_I - delta(alpha)  2 and u^beta_I - delta(alpha) + delta(beta)  2 = u^beta_I + delta(beta)  2 for beta neq alpha. Note that the normal velocity component at the boundary u^alpha_I - delta(alpha)  2 is now a degree of freedom, and we need to observe that the first normal derivative in the diffusion term of its corresponding momentum equation is zero before taking the limit as epsilon to 0, to avoid dividing by zero.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"It should now be clear from the above cases which components of the discrete velocity and pressure are unknown degrees of freedom, and which components are prescribed or obtained otherwise. The unknown degrees of freedom are stored in the vectors u_h = (u^1_h dots u^d_h) and p_h using the column-major convention. Note that the d discrete velocity fields u^1_h dots u^d_h may have different numbers of elements.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Storage convention\nWe use the column-major convention (Julia, MATLAB, Fortran), and not the row-major convention (Python, C). Thus the x^1-index i will vary for one whole cycle in the vectors before the x^2-index j, x^3 index k, and component-index alpha are incremented, e.g. u_h = (u^1_(1 1 1) u^1_(2 1 1) dots u^3_(N_u^3(1) N_u^3(2) N_u^3(3))) in 3D.","category":"page"},{"location":"equations/spatial/#Fourth-order-accurate-discretization","page":"Spatial discretization","title":"Fourth order accurate discretization","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The above discretization is second order accurate. A fourth order accurate discretization can be obtained by judiciously combining the second order discretization with itself on a grid with three times larger cells in each dimension [8] [7]. The coarse discretization is identical, but the mass equation is derived for the three times coarser control volume","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Omega^3_I =\nbigcup_alpha = 1^d Omega_I - delta(alpha) cup\nOmega_I cup Omega_I + delta(alpha)","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"while the momentum equation is derived for its shifted variant Omega^3_I + delta(alpha)  2. The resulting fourth order accurate equations are given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d\n(partial_alpha u^alpha)_I\n-\nfrac Omega^3_I 3^2 + d  Omega_I \nsum_alpha = 1^d\n(partial^3_alpha u^alpha)_I\n= 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"and","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracmathrmd mathrmd t u^alpha_I + delta(alpha)  2 =\n    -  sum_beta = 1^d\n    (partial_beta (u^alpha u^beta))_I + delta(alpha)  2 \n    +  nu sum_beta = 1^d\n    (partial_beta partial_beta u^alpha)_I + delta(alpha)  2 \n    +  f^alpha(x_I + delta(alpha)  2 t)\n    - (partial_alpha p)_I + delta(alpha)  2 \n    +  textfourth order\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(partial^3_alpha varphi)_I =\nfracvarphi_I + 3 delta(alpha)  2 -\nvarphi_I - 3 delta(alpha)  2Delta^alpha_I(alpha) - 1 +\nDelta^alpha_I(alpha) + Delta^alpha_I(alpha) + 1","category":"page"},{"location":"equations/spatial/#Matrix-representation","page":"Spatial discretization","title":"Matrix representation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We can write the mass and momentum equations in matrix form. We will use the same matrix notation for the second- and fourth order accurate discretizations. The discrete mass equation becomes","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"M u_h + y_M = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where M is the discrete divergence operator and y_M contains the boundary value contributions of the velocity to the divergence field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The discrete momentum equations become","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracmathrmd u_hmathrmd t  = -C(u_h) + nu (D u_h +\n    y_D) + f_h - (G p_h + y_G) \n     = F(u_h) - (G p_h + y_G)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where C is she convection operator (including boundary contributions), D is the diffusion operator, y_D is boundary contribution to the diffusion term, G = W_u^-1 M^mathsfT W is the pressure gradient operator, y_G contains the boundary contribution of the pressure to the pressure gradient (only non-zero for pressure boundary conditions), W_u is a diagonal matrix containing the velocity volume sizes  Omega_I + delta(alpha)  2 , and W is a diagonal matrix containing the reference volume sizes  Omega_I . The term F refers to all the forces except for the pressure gradient.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Volume normalization\nAll the operators have been divided by the velocity volume sizes. As a result, the operators have the same units as their continuous counterparts.","category":"page"},{"location":"equations/spatial/#Discrete-pressure-Poisson-equation","page":"Spatial discretization","title":"Discrete pressure Poisson equation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Instead of directly discretizing the continuous pressure Poisson equation, we will rededuce it in the discrete setting, thus aiming to preserve the discrete divergence freeness instead of the continuous one. Applying the discrete divergence operator M to the discrete momentum equations yields the discrete pressure Poisson equation","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"L p_h = W M (F(u_h) - y_G) + W fracmathrmd y_Mmathrmd t","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where L = W M G = W M W_u^-1 M^mathsfT W is a discrete Laplace operator. It is positive symmetric.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Unsteady Dirichlet boundary conditions\nIf the equations are prescribed with unsteady Dirichlet boundary conditions, for example an inflow that varies with time, the term fracmathrmd y_Mmathrmd t will be non-zero. If this term is not known exactly, for example if the next value of the inflow is unknown at the time of the current value, it must be computed using past values of of the velocity inflow only, for example fracmathrmd y_Mmathrmd t approx (y_M(t) - y_M(t - Delta t))  Delta t for some Delta t.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Uniqueness of pressure field\nUnless pressure boundary conditions are present, the pressure is only determined up to a constant, as L will have an eigenvalue of zero. Since only the gradient of the pressure appears in the equations, we can set the unknown constant to zero without affecting the velocity field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Pressure projection\nThe pressure field p_h can be seen as a Lagrange multiplier enforcing the constraint of discrete divergence freeness. It is also possible to write the momentum equations without the pressure by explicitly solving the discrete Poisson equation:p_h = L^-1 W M (F(u_h) - y_G) + L^-1 W fracmathrmd y_Mmathrmd tThe momentum equations then becomefracmathrmd u_hmathrmd t = (I - G L^-1 W M)\n(F(u_h) - y_G) - G L^-1 W fracmathrmd y_Mmathrmd tThe matrix (I - G L^-1 W M) is a projector onto the space of discretely divergence free velocities. However, using this formulation would require an efficient way to perform the projection without assembling the operator matrix L^-1, which would be very costly.","category":"page"},{"location":"equations/spatial/#Discrete-output-quantities","page":"Spatial discretization","title":"Discrete output quantities","text":"","category":"section"},{"location":"equations/spatial/#Kinetic-energy","page":"Spatial discretization","title":"Kinetic energy","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The local kinetic energy is defined by k = frac12  u _2^2 = frac12 sum_alpha = 1^d u^alpha u^alpha. On the staggered grid however, the different velocity components are not located at the same point. We will therefore interpolate the velocity to the pressure point before summing the squares.","category":"page"},{"location":"equations/spatial/#Vorticity","page":"Spatial discretization","title":"Vorticity","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, the vorticity is a scalar. Integrating the vorticity omega = -fracpartial u^1partial x^2 + fracpartial u^2partial x^1 over the vorticity volume Omega_I + delta(1)  2 + delta(2)  2 gives","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\nint_Omega_I + delta(1)  2 + delta(2)  2 omega  mathrmd Omega\n=  - left(\nint_Gamma^2_I + delta(1)  2 + delta(2) u^1  mathrmd Gamma\n- int_Gamma^2_I + delta(1)  2 u^1  mathrmd Gamma\nright) \n + left(\nint_Gamma^1_I + delta(1) + delta(2)  2 u^2  mathrmd Gamma\n- int_Gamma^1_I + delta(2)  2 u^2  mathrmd Gamma\nright)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Using quadrature, and dividing by the vorticity volume  Omega_I + delta(1)  2 + delta(2)  2 , the discrete vorticity in the corner is given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"omega_I + delta(1)  2 + delta(2)  2 =\n- fracu^1_I + delta(1)  2 + delta(2) -\nu^1_I + delta(1)  2Delta^2_I(2) + 1  2\n+ fracu^2_I + delta(1) + delta(2)  2 -\nu^2_I + delta(2)  2Delta^1_I(1) + 1  2","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The 3D vorticity is a vector field (omega^1 omega^2 omega^3). Noting alpha^+ = operatornamemod_3(alpha + 1) and alpha^- = operatornamemod_3(alpha - 1), the vorticity is obtained through","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\nint_Omega_I + delta(alpha^+)  2 + delta(alpha^-)  2 omega  mathrmd Omega\n=  - left(\nint_Gamma^alpha^-_I + delta(alpha^+)  2 + delta(alpha^-) u^alpha^+  mathrmd Gamma\n- int_Gamma^alpha^-_I + delta(alpha^+)  2 u^alpha^+  mathrmd Gamma\nright) \n + left(\nint_Gamma^alpha^+_I + delta(alpha^+) + delta(alpha^-)  2 u^alpha^-  mathrmd Gamma\n- int_Gamma^alpha^+_I + delta(alpha^-)  2 u^alpha^-  mathrmd Gamma\nright)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Using quadrature, and dividing by the vorticity volume  Omega_I + delta(alpha^+)  2 + delta(alpha^-)  2 , the discrete vorticity around the alpha-edge is given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"omega_I + delta(alpha^+)  2 + delta(alpha^-)  2 =\n- fracu^alpha^+_I + delta(alpha^+)  2 + delta(alpha^-) -\nu^alpha^+_I + delta(alpha^+)  2Delta^alpha^-_I(alpha^-) + 1  2\n+ fracu^alpha^-_I + delta(alpha^+) + delta(alpha^-)  2 -\nu^alpha^-_I + delta(alpha^-)  2Delta^alpha^+_I(alpha^+) + 1 \n2","category":"page"},{"location":"equations/spatial/#Stream-function","page":"Spatial discretization","title":"Stream function","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, the stream function is defined at the corners with the vorticity. Integrating the stream function Poisson equation over the vorticity volume yields","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n- int_Omega_I + delta(1)  2 + delta(2)  2 omega  mathrmd Omega\n = int_Omega_I + delta(1)  2 + delta(2)  2 nabla^2 psi \nmathrmd Omega \n = int_Gamma^1_I + delta(1) + delta(2)  2 fracpartial psipartial x^1\n mathrmd Gamma\n- int_Gamma^1_I + delta(2)  2 fracpartial psipartial x^1\n mathrmd Gamma \n + int_Gamma^2_I + delta(1)  2 + delta(2) fracpartial psipartial x^2\n mathrmd Gamma\n- int_Gamma^2_I + delta(1)  2 fracpartial psipartial x^2\n mathrmd Gamma\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Replacing the integrals with the mid-point quadrature rule and the spatial derivatives with central finite differences yields the discrete Poisson equation for the stream function at the vorticity point:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\nleft Gamma^1_I + delta(1)  2 + delta(2)  2 right\nleft(\n  fracpsi_I + 3  2 delta(1) + delta(2)  2 - psi_I + delta(1)  2 + delta(2)  2x^1_I(1) + 3  2 - x^1_I(1) + 1 2\n- fracpsi_I + delta(1)  2 + delta(2)  2 - psi_I - delta(1)  2 + delta(2)  2x^1_I(1) + 1  2 - x^1_I(1) - 1  2\nright)  + \nleft Gamma^2_I + delta(1)  2 + delta(2)  2 right\nleft(\nfracpsi_I + delta(1)  2 + 3  2 delta(2) - psi_I + delta(1)  2 + delta(2)  2x^2_I(1) + 3  2 - x^2_I(1) + 1  2\n-fracpsi_I + delta(1)  2 + delta(2)  2 - psi_I + delta(1)  2 - delta(2)  2x^2_I(2) + 1  2 - x^2_I(2) - 1  2\nright)  = \nleft Omega_I + delta(1)  2 + delta(2)  2 right\nomega_I + delta(1)  2 + delta(2)  2 \nendsplit","category":"page"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/tableaux/#API-Reference-–-Runge-Kutta-methods","page":"Runge-Kutta methods","title":"API Reference – Runge-Kutta methods","text":"","category":"section"},{"location":"api/tableaux/#Explicit-Methods","page":"Runge-Kutta methods","title":"Explicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"FE11\nSSP22\nSSP42\nSSP33\nSSP43\nSSP104\nrSSPs2\nrSSPs3\nWray3\nRK56\nDOPRI6","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.FE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.FE11","text":"FE11(; kwargs...)\n\nFE11.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP22","text":"SSP22(; kwargs...)\n\nSSP22.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP42","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP42","text":"SSP42(; kwargs...)\n\nSSP42.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP33","text":"SSP33(; kwargs...)\n\nSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP43","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP43","text":"SSP43(; kwargs...)\n\nSSP43.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SSP104","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SSP104","text":"SSP104(; kwargs...)\n\nSSP104.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.rSSPs2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.rSSPs2","text":"rSSPs2(s = 2; kwargs...)\n\nRational (optimal, low-storage) s-stage 2nd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.rSSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.rSSPs3","text":"rSSPs3(s = 4; kwargs...)\n\nRational (optimal, low-storage) s^2-stage 3rd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.Wray3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Wray3","text":"Wray3(; kwargs...)\n\nWray's RK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK56","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK56","text":"RK56(; kwargs...)\n\nRK56.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DOPRI6","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DOPRI6","text":"DOPRI6(; kwargs...)\n\nDormand-Price pair.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Implicit-Methods","page":"Runge-Kutta methods","title":"Implicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"BE11\nSDIRK34\nISSPm2\nISSPs3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.BE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.BE11","text":"BE11(; kwargs...)\n\nBackward Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.SDIRK34","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.SDIRK34","text":"SDIRK34(; kwargs...)\n\n3-stage, 4th order singly diagonally implicit (SSP).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.ISSPm2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.ISSPm2","text":"ISSPm2(s = 1; kwargs...)\n\nOptimal DIRK SSP schemes of order 2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.ISSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.ISSPs3","text":"ISSPs3(s = 2; kwargs...)\n\nOptimal DIRK SSP schemes of order 3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Half-explicit-methods","page":"Runge-Kutta methods","title":"Half explicit methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"HEM3\nHEM3BS\nHEM5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM3","text":"HEM3(; kwargs...)\n\nBrasey and Hairer.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM3BS","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM3BS","text":"HEM3BS(; kwargs...)\n\nHEM3BS.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.HEM5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.HEM5","text":"HEM5(; kwargs...)\n\nBrasey and Hairer, 5 stage, 4th order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Classical-Methods","page":"Runge-Kutta methods","title":"Classical Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"GL1\nGL2\nGL3\nRIA1\nRIA2\nRIA3\nRIIA1\nRIIA2\nRIIA3\nLIIIA2\nLIIIA3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL1","text":"GL1(; kwargs...)\n\nGL1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL2","text":"GL2(; kwargs...)\n\nGL2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.GL3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.GL3","text":"GL3(; kwargs...)\n\nGL3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA1","text":"RIA1(; kwargs...)\n\nThis is implicit Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA2","text":"RIA2(; kwargs...)\n\nRIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIA3","text":"RIA3(; kwargs...)\n\nRIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA1","text":"RIIA1(; kwargs...)\n\nRIIA1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA2","text":"RIIA2(; kwargs...)\n\nRIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RIIA3","text":"RIIA3(; kwargs...)\n\nRIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.LIIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.LIIIA2","text":"LIIIA2(; kwargs...)\n\nLIIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.LIIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.LIIIA3","text":"LIIIA3(; kwargs...)\n\nLIIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Chebyshev-methods","page":"Runge-Kutta methods","title":"Chebyshev methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"CHDIRK3\nCHCONS3\nCHC3\nCHC5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHDIRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHDIRK3","text":"CHDIRK3(; kwargs...)\n\nChebyshev based DIRK (not algebraically stable).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHCONS3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHCONS3","text":"CHCONS3(; kwargs...)\n\nCHCONS3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHC3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHC3","text":"CHC3(; kwargs...)\n\nChebyshev quadrature and C(3) satisfied. Note this equals Lobatto IIIA.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CHC5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CHC5","text":"CHC5(; kwargs...)\n\nCHC5.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Miscellaneous-Methods","page":"Runge-Kutta methods","title":"Miscellaneous Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"Mid22\nMTE22\nCN22\nHeun33\nRK33C2\nRK33P2\nRK44\nRK44C2\nRK44C23\nRK44P2","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.Mid22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Mid22","text":"Mid22(; kwargs...)\n\nMidpoint 22 method.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.MTE22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.MTE22","text":"MTE22(; kwargs...)\n\nMinimal truncation error 22 method (Heun).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.CN22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.CN22","text":"CN22(; kwargs...)\n\nCrank-Nicholson.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.Heun33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.Heun33","text":"Heun33(; kwargs...)\n\nHeun33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK33C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK33C2","text":"RK33C2(; kwargs...)\n\nRK3 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK33P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK33P2","text":"RK33P2(; kwargs...)\n\nRK3 satisfying the second order condition for the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44","text":"RK44(; kwargs...)\n\nClassical fourth order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44C2","text":"RK44C2(; kwargs...)\n\nRK4 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44C23","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44C23","text":"RK44C23(; kwargs...)\n\nRK4 satisfying C(2) for i=3 and c2=c3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RK44P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RK44P2","text":"RK44P2(; kwargs...)\n\nRK4 satisfying the second order condition for the pressure (but not third order).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#DSRK-Methods","page":"Runge-Kutta methods","title":"DSRK Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"DSso2\nDSRK2\nDSRK3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSso2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSso2","text":"DSso2(; kwargs...)\n\nCBM's DSRKso2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSRK2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSRK2","text":"DSRK2(; kwargs...)\n\nCBM's DSRK2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.DSRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.DSRK3","text":"DSRK3(; kwargs...)\n\nZennaro's DSRK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#\"Non-SSP\"-Methods-of-Wong-and-Spiteri","page":"Runge-Kutta methods","title":"\"Non-SSP\" Methods of Wong & Spiteri","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"NSSP21\nNSSP32\nNSSP33\nNSSP53","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP21","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP21","text":"NSSP21(; kwargs...)\n\nNSSP21.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP32","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP32","text":"NSSP32(; kwargs...)\n\nNSSP32.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP33","text":"NSSP33(; kwargs...)\n\nNSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.NSSP53","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.NSSP53","text":"NSSP53(; kwargs...)\n\nNSSP53.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"All discrete operators are built using KernelAbstractions.jl and Cartesian indices, similar to WaterLily.jl. This allows for dimension- and backend-agnostic code. See this blog post for how to write kernels. IncompressibleNavierStokes previously relied on assembling sparse operators to perform the same operations. While being very efficient and also compatible with CUDA (CUSPARSE), storing these matrices in memory is expensive for large 3D problems.","category":"page"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"Offset\ndivergence!\ndivergence\nvorticity\nvorticity!\nconvection!\ndiffusion!\nbodyforce!\nmomentum!\nmomentum\nlaplacian!\nlaplacian\npressuregradient!\npressuregradient\ninterpolate_u_p\ninterpolate_u_p!\ninterpolate_ω_p\ninterpolate_ω_p!\nDfield!\nDfield\nQfield!\nQfield\neig2field!\neig2field\nkinetic_energy\nkinetic_energy!\ntotal_kinetic_energy\ntensorbasis\nsmagtensor!\nsmagorinsky_closure\ndivoftensor!\ntensorbasis!\nreconstruct!","category":"page"},{"location":"features/operators/#IncompressibleNavierStokes.Offset","page":"Operators","title":"IncompressibleNavierStokes.Offset","text":"δ = Offset{D}()\n\nCartesian index unit vector in D = 2 or D = 3 dimensions. Calling δ(α) returns a Cartesian index with 1 in the dimension α and zeros elsewhere.\n\nSee https://b-fg.github.io/2023/05/07/waterlily-on-gpu.html for writing kernel loops using Cartesian indices.\n\n\n\n\n\n","category":"type"},{"location":"features/operators/#IncompressibleNavierStokes.divergence!","page":"Operators","title":"IncompressibleNavierStokes.divergence!","text":"divergence!(div, u, setup)\n\nCompute divergence of velocity field (in-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.divergence","page":"Operators","title":"IncompressibleNavierStokes.divergence","text":"divergence(u, setup)\n\nCompute divergence of velocity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.vorticity","page":"Operators","title":"IncompressibleNavierStokes.vorticity","text":"vorticity(u, setup)\n\nCompute vorticity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.vorticity!","page":"Operators","title":"IncompressibleNavierStokes.vorticity!","text":"vorticity!(ω, u, setup)\n\nCompute vorticity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.convection!","page":"Operators","title":"IncompressibleNavierStokes.convection!","text":"convection!(F, u, setup)\n\nCompute convective term.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.diffusion!","page":"Operators","title":"IncompressibleNavierStokes.diffusion!","text":"diffusion!(F, u, setup)\n\nCompute diffusive term.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.bodyforce!","page":"Operators","title":"IncompressibleNavierStokes.bodyforce!","text":"bodyforce!(F, u, t, setup)\n\nCompute body force.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.momentum!","page":"Operators","title":"IncompressibleNavierStokes.momentum!","text":"momentum!(F, u, t, setup)\n\nRight hand side of momentum equations, excluding pressure gradient. Put the result in F.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.momentum","page":"Operators","title":"IncompressibleNavierStokes.momentum","text":"momentum(u, t, setup)\n\nRight hand side of momentum equations, excluding pressure gradient.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.laplacian!","page":"Operators","title":"IncompressibleNavierStokes.laplacian!","text":"laplacian!(L, p, setup)\n\nCompute Laplacian of pressure field (in-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.laplacian","page":"Operators","title":"IncompressibleNavierStokes.laplacian","text":"laplacian(p, setup)\n\nCompute Laplacian of pressure field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.pressuregradient!","page":"Operators","title":"IncompressibleNavierStokes.pressuregradient!","text":"pressuregradient!(G, p, setup)\n\nCompute pressure gradient (in-place).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.pressuregradient","page":"Operators","title":"IncompressibleNavierStokes.pressuregradient","text":"pressuregradient(p, setup)\n\nCompute pressure gradient.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_u_p","page":"Operators","title":"IncompressibleNavierStokes.interpolate_u_p","text":"interpolate_u_p(u, setup)\n\nInterpolate velocity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_u_p!","page":"Operators","title":"IncompressibleNavierStokes.interpolate_u_p!","text":"interpolate_u_p!(up, u, setup)\n\nInterpolate velocity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_ω_p","page":"Operators","title":"IncompressibleNavierStokes.interpolate_ω_p","text":"interpolate_ω_p(ω, setup)\n\nInterpolate vorticity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_ω_p!","page":"Operators","title":"IncompressibleNavierStokes.interpolate_ω_p!","text":"interpolate_ω_p!(ωp, ω, setup)\n\nInterpolate vorticity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Dfield!","page":"Operators","title":"IncompressibleNavierStokes.Dfield!","text":"Dfield!(d, G, p, setup; ϵ = eps(eltype(p)))\n\nCompute the D-field [10] given by\n\nD = frac2  nabla p nabla^2 p\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Dfield","page":"Operators","title":"IncompressibleNavierStokes.Dfield","text":"Dfield(p, setup)\n\nCompute the D-field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Qfield!","page":"Operators","title":"IncompressibleNavierStokes.Qfield!","text":"Qfield!(Q, u, setup)\n\nCompute Q-field [11] given by\n\nQ = - frac12 sum_α β fracpartial u^αpartial x^β\nfracpartial u^βpartial x^α\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Qfield","page":"Operators","title":"IncompressibleNavierStokes.Qfield","text":"Qfield(u, setup)\n\nCompute the Q-field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.eig2field!","page":"Operators","title":"IncompressibleNavierStokes.eig2field!","text":"eig2field!(λ, u, setup; ϵ = eps(eltype(λ)))\n\nCompute the second eigenvalue of S^2 + Omega^2, as proposed by Jeong and Hussain [11].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.eig2field","page":"Operators","title":"IncompressibleNavierStokes.eig2field","text":"eig2field(u, setup)\n\nCompute the second eigenvalue of S^2 + Omega^2, as proposed by Jeong and Hussain [11].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.kinetic_energy","page":"Operators","title":"IncompressibleNavierStokes.kinetic_energy","text":"kinetic_energy(u, setup; kwargs...)\n\nCompute kinetic energy field e (out-of-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.kinetic_energy!","page":"Operators","title":"IncompressibleNavierStokes.kinetic_energy!","text":"kinetic_energy!(e, u, setup; interpolate_first = false)\n\nCompute kinetic energy field e (in-place version). If interpolate_first is true, it is given by\n\ne_I = frac18 sum_alpha (u^alpha_I + delta(alpha)  2 + u^alpha_I - delta(alpha)  2)^2\n\nOtherwise, it is given by\n\ne_I = frac14 sum_alpha (u^alpha_I + delta(alpha)  2^2 + u^alpha_I - delta(alpha)  2^2)\n\nas in [12].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.total_kinetic_energy","page":"Operators","title":"IncompressibleNavierStokes.total_kinetic_energy","text":"total_kinetic_energy(setup, u; kwargs...)\n\nCompute total kinetic energy. The velocity components are interpolated to the volume centers and squared.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.tensorbasis","page":"Operators","title":"IncompressibleNavierStokes.tensorbasis","text":"tensorbasis(u, setup)\n\nCompute symmetry tensor basis T[1]-T[11] and invariants V[1]-V[5].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.smagtensor!","page":"Operators","title":"IncompressibleNavierStokes.smagtensor!","text":"smagtensor!(σ, u, θ, setup)\n\nCompute Smagorinsky stress tensors σ[I]. The Smagorinsky constant θ should be a scalar between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.smagorinsky_closure","page":"Operators","title":"IncompressibleNavierStokes.smagorinsky_closure","text":"m = smagorinsky_closure(setup)\n\nCreate Smagorinsky closure model m. The model is called as m(u, θ), where the Smagorinsky constant θ should be a scalar between 0 and 1 (for example θ = 0.1).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.divoftensor!","page":"Operators","title":"IncompressibleNavierStokes.divoftensor!","text":"divoftensor!(s, σ, setup)\n\nCompute divergence of a tensor with all components in the pressure points. The stress tensors should be precomputed and stored in σ.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.tensorbasis!","page":"Operators","title":"IncompressibleNavierStokes.tensorbasis!","text":"tensorbasis!(B, V, u, setup)\n\nCompute symmetry tensor basis B[1]-B[11] and invariants V[1]-V[5], as specified in [13] in equations (9) and (11). Note that B[1] corresponds to T_0 in the paper, and V to I.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.reconstruct!","page":"Operators","title":"IncompressibleNavierStokes.reconstruct!","text":"reconstruct!(u, v, setup_dns, setup_les)\n\nAverage fine grid u over coarse volume face. Put result in v.\n\n\n\n\n\n","category":"function"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/bc/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"Each boundary has exactly one type of boundary conditions. For periodic boundary conditions, the opposite boundary must also be periodic. The available boundary conditions are given below.","category":"page"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"PeriodicBC\nDirichletBC\nSymmetricBC\nPressureBC","category":"page"},{"location":"features/bc/#IncompressibleNavierStokes.PeriodicBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.PeriodicBC","text":"PeriodicBC()\n\nPeriodic boundary conditions. Must be periodic on both sides.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.DirichletBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.DirichletBC","text":"DirichletBC()\n\nNo slip boundary conditions, where all velocity components are zero.\n\nDirichletBC(u, dudt)\n\nDirichlet boundary conditions for the velocity, where u[1] = (x..., t) -> u1_BC up to u[d] = (x..., t) -> ud_BC, where d is the dimension.\n\nTo make the pressure the same order as velocity, also provide dudt.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.SymmetricBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.SymmetricBC","text":"SymmetricBC()\n\nSymmetric boundary conditions. The parallel velocity and pressure is the same at each side of the boundary. The normal velocity is zero.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.PressureBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.PressureBC","text":"PressureBC()\n\nPressure boundary conditions. The pressure is prescribed on the boundary (usually an \"outlet\"). The velocity has zero Neumann conditions.\n\nNote: Currently, the pressure is prescribed with the constant value of zero on the entire boundary.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"offset_p\noffset_u","category":"page"},{"location":"features/bc/#IncompressibleNavierStokes.offset_p","page":"Boundary conditions","title":"IncompressibleNavierStokes.offset_p","text":"offset_p(bc)\n\nNumber of non-DOF pressure components at boundary.\n\n\n\n\n\n","category":"function"},{"location":"features/bc/#IncompressibleNavierStokes.offset_u","page":"Boundary conditions","title":"IncompressibleNavierStokes.offset_u","text":"offset_u(bc, isnormal, isright)\n\nNumber of non-DOF velocity components at boundary. If isnormal, then the velocity is normal to the boundary, else parallel. If isright, it is at the end/right/rear/top boundary, otherwise beginning.\n\n\n\n\n\n","category":"function"},{"location":"equations/ns/#Incompressible-Navier-Stokes-equations","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Let d in 2 3 denote the spatial dimension, and Omega subset mathbbR^d some spatial domain. The incompressible Navier-Stokes equations on Omega are comprised of a mass equation and d momentum equations. In conservative form, they are given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginalign*\nnabla cdot u  = 0 \nfracpartial upartial t + nabla cdot (u u^mathsfT)  = -nabla p +\nnu nabla^2 u + f\nendalign*","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where u = (u^1 dots u^d) is the velocity field, p is the pressure, nu is the kinematic viscosity, and f = (f^1 dots f^d) is the body force per unit of volume. In scalar notation, the equations can be written as","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginalign*\nsum_beta = 1^d fracpartial u^betapartial x^beta  = 0 \nfracpartial u^alphapartial t + sum_beta = 1^d\nfracpartialpartial x^beta (u^alpha u^beta)  = -fracpartial\nppartial x^alpha + nu sum_beta = 1^d fracpartial^2 u^alphapartial\nx^beta partial x^beta + f^alpha\nendalign*","category":"page"},{"location":"equations/ns/#Integral-form","page":"Incompressible Navier-Stokes equations","title":"Integral form","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"When discretizing the Navier-Stokes equations it can be useful to integrate the equations over an arbitrary control volume mathcalO. Its boundary will be denoted partial mathcalO, with normal n and surface element mathrmd Gamma.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The mass equation in integral form is given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"frac1 mathcalO \nint_partial mathcalO u cdot n  mathrmd Gamma = 0","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where we have used the divergence theorem to convert the volume integral to a surface integral. Similarly, the momentum equations take the form","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"fracmathrmdmathrmd t\nfrac1 mathcalO \nint_mathcalO u  mathrmd Omega\n=\nfrac1 mathcalO \nint_partial mathcalO\nleft( - u u^mathsfT - P + nu S right) cdot n\n mathrmd Gamma +\nfrac1 mathcalO \nint_mathcalO f mathrmd Omega","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where P = p mathrmI is the hydrostatic stress tensor and S = nabla u + (nabla u)^mathsfT is the strain-rate tensor. Here we have once again used the divergence theorem.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"note: Strain-rate tensor\nThe second term in the strain rate tensor is optional, asint_partial mathcalO (nabla u)^mathsfT cdot n  mathrmd Gamma = 0due to the divergence freeness of u (mass equation).","category":"page"},{"location":"equations/ns/#Boundary-conditions","page":"Incompressible Navier-Stokes equations","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Consider a part Gamma of the total boundary partial Omega, with normal n. We allow for the following types of boundary conditions on Gamma:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Periodic boundary conditions: u(x) = u(x + tau) and p(x) = p(x + tau) for x in Gamma, where tau is a constant translation to another part of the boundary partial Omega. This usually requires Gamma and its periodic counterpart Gamma + tau to be flat and rectangular (including in this software suite).\nDirichlet boundary conditions: u = u_textBC on Gamma. A common situation here is that of a sticky wall, with \"no slip boundary conditions. Then u_textBC = 0.\nSymmetric boundary conditions: Same velocity field at each side. This implies zero Dirichlet conditions for the normal component (n cdot u = 0), and zero Neumann conditions for the parallel component: n cdot nabla (u - (n cdot u) n) = 0.\nPressure boundary conditions: The pressure is prescribed (p = p_textBC), while the velocity has zero Neumann conditions: n cdot nabla u = 0.","category":"page"},{"location":"equations/ns/#Pressure-equation","page":"Incompressible Navier-Stokes equations","title":"Pressure equation","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Taking the divergence of the momemtum equations yields a Poisson equation for the pressure:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- nabla^2 p = nabla cdot left( nabla cdot (u u^mathsfT) right) -\nnabla cdot f","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In scalar notation, this becomes","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- sum_alpha = 1^d fracpartial^2partial x^alpha partial x^alpha p = sum_alpha\n= 1^d sum_beta = 1^d fracpartial^2 partial x^alpha partial\nx^beta (u^alpha u^beta) - sum_alpha = 1^d fracpartial\nf^alphapartial x^alpha","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note the absence of time derivatives in the pressure equation. While the velocity field evolves in time, the pressure only changes such that the velocity stays divergence free.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"If there are no pressure boundary conditions, the pressure is only unique up to a constant. We set this constant to 1.","category":"page"},{"location":"equations/ns/#Other-quantities-of-interest","page":"Incompressible Navier-Stokes equations","title":"Other quantities of interest","text":"","category":"section"},{"location":"equations/ns/#Reynolds-number","page":"Incompressible Navier-Stokes equations","title":"Reynolds number","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The Reynolds number is the inverse of the viscosity: Re = frac1nu. It is the only flow parameter governing the incompressible Navier-Stokes equations.","category":"page"},{"location":"equations/ns/#Kinetic-energy","page":"Incompressible Navier-Stokes equations","title":"Kinetic energy","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The local and total kinetic energy are defined by k = frac12  u _2^2 and K = frac12  u _L^2(Omega)^2 = int_Omega k  mathrmd Omega.","category":"page"},{"location":"equations/ns/#Vorticity","page":"Incompressible Navier-Stokes equations","title":"Vorticity","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The vorticity is defined as omega = nabla times u.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 2D, it is a scalar field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = -fracpartial u^1partial x^2 + fracpartial u^2partial\nx^1","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 3D, it is a vector field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = beginpmatrix\n    - fracpartial u^2partial x^3 + fracpartial u^3partial x^2 \n    - fracpartial u^3partial x^1 + fracpartial u^1partial x^3  \n    - fracpartial u^1partial x^2 + fracpartial u^2partial x^1\nendpmatrix","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note that the 2D vorticity is equal to the x^3-component of the 3D vorticity.","category":"page"},{"location":"equations/ns/#Stream-function","page":"Incompressible Navier-Stokes equations","title":"Stream function","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 2D, the stream function psi is a scalar field such that","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"u^1 = fracpartial psipartial x^2 quad\nu^2 = -fracpartial psipartial x^1","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"It can be found by solving","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"nabla^2 psi = - omega","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 3D, the stream function is a vector field such that","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"u = nabla times psi","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"It can be found by solving","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"nabla^2 psi = nabla times omega","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"EditURL = \"../../../examples/TaylorGreenVortex2D.jl\"","category":"page"},{"location":"generated/TaylorGreenVortex2D/#Convergence-study:-Taylor-Green-vortex-(2D)","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence study: Taylor-Green vortex (2D)","text":"","category":"section"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"In this example we consider the Taylor-Green vortex. In 2D, it has an analytical solution, given by","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"beginsplit\n    u^1(x y t)  = - sin(x) cos(y) mathrme^-2 t  Re \n    u^2(x y t)  = + cos(x) sin(y) mathrme^-2 t  Re\nendsplit","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"This allows us to test the convergence of our solver.","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes\nusing LinearAlgebra\n\n\"\"\"\nCompare numerical solution with analytical solution at final time.\n\"\"\"\nfunction compute_convergence(; D, nlist, lims, Re, tlims, Δt, uref, ArrayType = Array)\n    T = typeof(lims[1])\n    e = zeros(T, length(nlist))\n    for (i, n) in enumerate(nlist)\n        @info \"Computing error for n = $n\"\n        x = ntuple(α -> LinRange(lims..., n + 1), D)\n        setup = Setup(x...; Re, ArrayType)\n        psolver = SpectralPressureSolver(setup)\n        u₀ = create_initial_conditions(\n            setup,\n            (dim, x...) -> uref(dim, x..., tlims[1]),\n            tlims[1];\n            psolver,\n        )\n        ut = create_initial_conditions(\n            setup,\n            (dim, x...) -> uref(dim, x..., tlims[2]),\n            tlims[2];\n            psolver,\n            doproject = false,\n        )\n        (; u, t), outputs = solve_unsteady(setup, u₀, tlims; Δt, psolver)\n        (; Ip) = setup.grid\n        a, b = T(0), T(0)\n        for α = 1:D\n            a += sum(abs2, u[α][Ip] - ut[α][Ip])\n            b += sum(abs2, ut[α][Ip])\n        end\n        e[i] = sqrt(a) / sqrt(b)\n    end\n    e\nend","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Analytical solution for 2D Taylor-Green vortex","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"solution(Re) =\n    (dim, x, y, t) -> (dim() == 1 ? -sin(x) * cos(y) : cos(x) * sin(y)) * exp(-2t / Re)","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Compute error for different resolutions","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Re = 2.0e3\nnlist = [2, 4, 8, 16, 32, 64, 128, 256]\ne = compute_convergence(;\n    D = 2,\n    nlist,\n    lims = (0.0, 2π),\n    Re,\n    tlims = (0.0, 2.0),\n    Δt = 0.01,\n    uref = solution(Re),\n)","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Plot convergence","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"fig = Figure()\nax = Axis(\n    fig[1, 1];\n    xscale = log10,\n    yscale = log10,\n    xticks = nlist,\n    xlabel = \"n\",\n    title = \"Relative error\",\n)\nscatterlines!(ax, nlist, e; label = \"Data\")\nlines!(ax, collect(extrema(nlist)), n -> n^-2.0; linestyle = :dash, label = \"n^-2\")\naxislegend(ax)\nfig","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/pressure/#Pressure-solvers","page":"Pressure solvers","title":"Pressure solvers","text":"","category":"section"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"The discrete pressure Poisson equation","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"L p = W M F(u)","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"enforces divergence freeness. There are multiple options for solving this system.","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"AbstractPressureSolver\nDirectPressureSolver\nCUDSSPressureSolver\nCGPressureSolver\nCGMatrixPressureSolver\nSpectralPressureSolver\nLowMemorySpectralPressureSolver\npressure\npressure!\npoisson\npoisson!\napplypressure!\nproject\nproject!","category":"page"},{"location":"features/pressure/#IncompressibleNavierStokes.AbstractPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.AbstractPressureSolver","text":"AbstractPressureSolver\n\nPressure solver for the Poisson equation.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.DirectPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.DirectPressureSolver","text":"DirectPressureSolver()\n\nDirect pressure solver using a LU decomposition.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.CUDSSPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.CUDSSPressureSolver","text":"CUDSSPressureSolver()\n\nDirect pressure solver using a CUDSS LDLt decomposition.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.CGPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.CGPressureSolver","text":"CGPressureSolver(setup; [abstol], [reltol], [maxiter])\n\nConjugate gradients iterative pressure solver.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.CGMatrixPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.CGMatrixPressureSolver","text":"CGMatrixPressureSolver(setup; [abstol], [reltol], [maxiter])\n\nConjugate gradients iterative pressure solver.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.SpectralPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.SpectralPressureSolver","text":"SpectralPressureSolver(setup)\n\nBuild spectral pressure solver from setup.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.LowMemorySpectralPressureSolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.LowMemorySpectralPressureSolver","text":"LowMemorySpectralPressureSolver(setup)\n\nBuild spectral pressure solver from setup. This one is slower than SpectralPressureSolver but occupies less memory.\n\n\n\n\n\n","category":"type"},{"location":"features/pressure/#IncompressibleNavierStokes.pressure","page":"Pressure solvers","title":"IncompressibleNavierStokes.pressure","text":"pressure(u, t, setup; psolver)\n\nDo additional pressure solve. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.pressure!","page":"Pressure solvers","title":"IncompressibleNavierStokes.pressure!","text":"pressure!(p, u, t, setup; psolver, F, div)\n\nCompute pressure from velocity field. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.poisson","page":"Pressure solvers","title":"IncompressibleNavierStokes.poisson","text":"poisson(solver, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also poisson!.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.poisson!","page":"Pressure solvers","title":"IncompressibleNavierStokes.poisson!","text":"poisson!(solver, p, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nMutating/non-allocating/in-place version.\n\nSee also poisson.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.applypressure!","page":"Pressure solvers","title":"IncompressibleNavierStokes.applypressure!","text":"applypressure!(u, p, setup)\n\nSubtract pressure gradient (in-place).\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.project","page":"Pressure solvers","title":"IncompressibleNavierStokes.project","text":"project(u, setup; psolver)\n\nProject velocity field onto divergence-free space.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.project!","page":"Pressure solvers","title":"IncompressibleNavierStokes.project!","text":"project!(u, setup; psolver, div, p)\n\nProject velocity field onto divergence-free space.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install IncompressibleNavierStokes, open up a Julia-REPL, type ] to get into Pkg-mode, and type:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"add IncompressibleNavierStokes","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install the package and all dependencies to your local environment. Note that IncompressibleNavierStokes requires Julia version 1.7 or above.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"EditURL = \"../../../examples/Actuator2D.jl\"","category":"page"},{"location":"generated/Actuator2D/#Unsteady-actuator-case-2D","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady actuator case - 2D","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"In this example, an unsteady inlet velocity profile at encounters a wind turbine blade in a wall-less domain. The blade is modeled as a uniform body force on a thin rectangle.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Output directory","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"output = \"output/Actuator2D\"","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"n = 40\nx = LinRange(0.0, 10.0, 5n + 1)\ny = LinRange(-2.0, 2.0, 2n + 1)\nplotgrid(x, y)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Boundary conditions","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"boundary_conditions = (\n    # x left, x right\n    (\n        # Unsteady BC requires time derivatives\n        DirichletBC(\n            (dim, x, y, t) -> sin(π / 6 * sin(π / 6 * t) + π / 2 * (dim() == 1)),\n            (dim, x, y, t) ->\n                (π / 6)^2 *\n                cos(π / 6 * t) *\n                cos(π / 6 * sin(π / 6 * t) + π / 2 * (dim() == 1)),\n        ),\n        PressureBC(),\n    ),\n\n    # y rear, y front\n    (PressureBC(), PressureBC()),\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Actuator body force: A thrust coefficient Cₜ distributed over a thin rectangle","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"xc, yc = 2.0, 0.0 # Disk center\nD = 1.0           # Disk diameter\nδ = 0.11          # Disk thickness\nCₜ = 0.2          # Thrust coefficient\ncₜ = Cₜ / (D * δ)\ninside(x, y) = abs(x - xc) ≤ δ / 2 && abs(y - yc) ≤ D / 2\nbodyforce(dim, x, y, t) = dim() == 1 ? -cₜ * inside(x, y) : 0.0","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"setup = Setup(x, y; Re = 100.0, boundary_conditions, bodyforce);\npsolver = DirectPressureSolver(setup);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"u₀ = create_initial_conditions(setup, (dim, x, y) -> dim() == 1 ? 1.0 : 0.0; psolver);\nu = u₀","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"state, outputs = solve_unsteady(\n    setup,\n    u₀,\n    (0.0, 12.0);\n    psolver,\n    method = RK44P2(),\n    Δt = 0.05,\n    processors = (\n        rtp = realtimeplotter(; setup, plot = fieldplot, nupdate = 1),\n        # ehist = realtimeplotter(; setup, plot = energy_history_plot, nupdate = 1),\n        # espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 1),\n        # anim = animator(; setup, path = \"$output/vorticity.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = \"$output\", filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 1),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/#Post-process","page":"Unsteady inflow: Actuator (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We may visualize or export the computed fields (u, p).","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Export to VTK","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\"; psolver)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We create a box to visualize the actuator.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"box = (\n    [xc - δ / 2, xc - δ / 2, xc + δ / 2, xc + δ / 2, xc - δ / 2],\n    [yc + D / 2, yc - D / 2, yc - D / 2, yc + D / 2, yc + D / 2],\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot pressure","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :pressure)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot velocity","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :velocity)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :vorticity)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/les/#Large-eddy-simulation","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Depending on the problem specification, a given grid resolution may not be sufficient to resolve all spatial features of the flow. Consider the following example:","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"(Image: Resolution)","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the left, the grid spacing is too large to capt the smallest eddies in the flow. These eddies create sub-grid stresses that also affect the large scale features. The grid must be refined if we want to compute these stresses exactly.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the right, the smallest spatial feature of the flow is fully resolved, and there are no sub-grid stresses. The equations can be solved without worrying about errors from unresolved features. This is known as Direct Numerical Simulation (DNS).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"If refining the grid is too costly, a closure model can be used to predict the sub-grid stresses. The models only give an estimate for these stresses, and may need to be calibrated to the given problem. When used correctly, they can predict the evolution of the large fluid motions without computing the sub-grid motions themselves. This is known as Large Eddy Simulation (LES).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Eddy viscosity models add a local contribution to the global baseline viscosity. The baseline viscosity models transfer of energy from resolved to atomic scales. The new turbulent viscosity on the other hand, models energy transfer from resolved to unresolved scales. This non-constant field is computed from the local velocity field.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The following eddy viscosity models are available:","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"AbstractViscosityModel\nLaminarModel\nSmagorinskyModel\nQRModel\nMixingLengthModel","category":"page"},{"location":"features/les/#IncompressibleNavierStokes.AbstractViscosityModel","page":"Large eddy simulation","title":"IncompressibleNavierStokes.AbstractViscosityModel","text":"AbstractViscosityModel\n\nAbstract viscosity model.\n\n\n\n\n\n","category":"type"},{"location":"features/les/#IncompressibleNavierStokes.LaminarModel","page":"Large eddy simulation","title":"IncompressibleNavierStokes.LaminarModel","text":"LaminarModel()\n\nLaminar model. This model assumes that there are no sub-grid stresses. It can be used if the grid is sufficiently refined for the given flow. It has the advantage of having a constant diffusion operator.\n\n\n\n\n\n","category":"type"},{"location":"features/les/#IncompressibleNavierStokes.SmagorinskyModel","page":"Large eddy simulation","title":"IncompressibleNavierStokes.SmagorinskyModel","text":"SmagorinskyModel(C_s = 0.17)\n\nSmagorinsky-Lilly model with constant C_s.\n\n\n\n\n\n","category":"type"},{"location":"features/les/#IncompressibleNavierStokes.QRModel","page":"Large eddy simulation","title":"IncompressibleNavierStokes.QRModel","text":"QR(Re)\n\nQR-model.\n\n\n\n\n\n","category":"type"},{"location":"features/les/#IncompressibleNavierStokes.MixingLengthModel","page":"Large eddy simulation","title":"IncompressibleNavierStokes.MixingLengthModel","text":"MixingLengthModel()\n\nMixing-length model with mixing length lm.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#IncompressibleNavierStokes","page":"Home","title":"IncompressibleNavierStokes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IncompressibleNavierStokes is a package providing energy-conserving solvers for the incompressible Navier-Stokes equations on a staggered Cartesian grid. It is based on the Matlab package INS2D/INS3D.","category":"page"},{"location":"api/api/","page":"API","title":"API","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"IncompressibleNavierStokes\nSetup","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.IncompressibleNavierStokes","page":"API","title":"IncompressibleNavierStokes.IncompressibleNavierStokes","text":"IncompressibleNavierStokes\n\nEnergy-conserving solvers for the incompressible Navier-Stokes equations.\n\n\n\n\n\n","category":"module"},{"location":"api/api/#IncompressibleNavierStokes.Setup","page":"API","title":"IncompressibleNavierStokes.Setup","text":"Setup(\n    x...;\n    boundary_conditions = ntuple(d -> (PeriodicBC(), PeriodicBC()), length(x)),\n    Re = convert(eltype(x[1]), 1_000),\n    viscosity_model = LaminarModel(),\n    bodyforce = nothing,\n    issteadybodyforce = true,\n    closure_model = nothing,\n    ArrayType = Array,\n    workgroupsize = 64,\n)\n\nCreate setup.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Grid","page":"API","title":"Grid","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Dimension\nGrid\ncosine_grid\nmax_size\nstretched_grid","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.Dimension","page":"API","title":"IncompressibleNavierStokes.Dimension","text":"Dimension(N)\n\nRepresent an N-dimensional space. Returns N when called.\n\njulia> d = Dimension(3)\nDimension{3}()\n\njulia> d()\n3\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.Grid","page":"API","title":"IncompressibleNavierStokes.Grid","text":"Grid(x, boundary_conditions)\n\nCreate nonuniform Cartesian box mesh x[1] × ... × x[d] with boundary conditions boundary_conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.cosine_grid","page":"API","title":"IncompressibleNavierStokes.cosine_grid","text":"cosine_grid(a, b, N)\n\nCreate a nonuniform grid of N + 1 points from a to b using a cosine profile, i.e.\n\nx_i = a + frac12 left( 1 - cos left( pi fracin right) right)\n(b - a) quad i = 0 dots N\n\nSee also stretched_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.max_size","page":"API","title":"IncompressibleNavierStokes.max_size","text":"max_size(grid)\n\nGet size of the largest grid element.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.stretched_grid","page":"API","title":"IncompressibleNavierStokes.stretched_grid","text":"stretched_grid(a, b, N, s = 1)\n\nCreate a nonuniform grid of N + 1 points from a to b with a stretch factor of s. If s = 1, return a uniform spacing from a to b. Otherwise, return a vector x in mathbbR^N + 1 such that x_n = a + sum_i = 1^n s^i - 1 h for n = 0 dots  N. Setting x_N = b then gives h = (b - a) frac1 - s1 - s^N, resulting in\n\nx_n = a + (b - a) frac1 - s^n1 - s^N quad n = 0 dots N\n\nNote that stretched_grid(a, b, N, s)[n] corresponds to x_n - 1.\n\nSee also cosine_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Preprocess","page":"API","title":"Preprocess","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"create_initial_conditions\nrandom_field","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.create_initial_conditions","page":"API","title":"IncompressibleNavierStokes.create_initial_conditions","text":"create_initial_conditions(\n    setup,\n    initial_velocity,\n    t = 0;\n    psolver = DirectPressureSolver(setup),\n    doproject = true,\n)\n\nCreate divergence free initial velocity field u at starting time t. The initial conditions of u[α] are specified by the function initial_velocity(Dimension(α), x...).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.random_field","page":"API","title":"IncompressibleNavierStokes.random_field","text":"random_field(\n    setup, t = 0;\n    A = 1,\n    kp = 10,\n    psolver = SpectralPressureSolver(setup),\n    rng = Random.default_rng(),\n)\n\nCreate random field, as in [14].\n\nK: Maximum wavenumber\nA: Eddy amplitude scaling\nkp: Peak energy wavenumber\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Processors","page":"API","title":"Processors","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"processor\ntimelogger\nvtk_writer\nfieldsaver\nrealtimeplotter\nfieldplot\nenergy_history_plot\nenergy_spectrum_plot\nanimator","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.processor","page":"API","title":"IncompressibleNavierStokes.processor","text":"processor(initialize, finalize = (initialized, state) -> initialized)\n\nProcess results from time stepping. Before time stepping, the initialize function is called on an observable of the time stepper state, returning initialized. The observable is updated every time step.\n\nAfter timestepping, the finalize function is called on initialized and the final state.\n\nSee the following example:\n\nfunction initialize(state)\n    s = 0\n    println(\"Let's sum up the time steps\")\n    on(state) do (; n, t)\n        println(\"The summand is $n, the time is $t\")\n        s = s + n\n    end\n    s\nend\n\nfinalize(i, state) = println(\"The final sum (at time t=$(state.t)) is $s\")\np = processor(initialize, finalize)\n\nWhen solved for 6 time steps from t=0 to t=2 the displayed output is\n\nLet's sum up the time steps\nThe summand is 0, the time is 0.0\nThe summand is 1, the time is 0.4\nThe summand is 2, the time is 0.8\nThe summand is 3, the time is 1.2\nThe summand is 4, the time is 1.6\nThe summand is 5, the time is 2.0\nThe final sum (at time t=2.0) is 15\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.timelogger","page":"API","title":"IncompressibleNavierStokes.timelogger","text":"timelogger(; nupdate = 1)\n\nCreate processor that logs time step information.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.vtk_writer","page":"API","title":"IncompressibleNavierStokes.vtk_writer","text":"vtk_writer(;\n    setup,\n    nupdate = 1,\n    dir = \"output\",\n    filename = \"solution\",\n    fields = (:velocity, :pressure, :vorticity),\n)\n\nCreate processor that writes the solution every nupdate time steps to a VTK file. The resulting Paraview data collection file is stored in \"$dir/$filename.pvd\".\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.fieldsaver","page":"API","title":"IncompressibleNavierStokes.fieldsaver","text":"fieldsaver(; setup, nupdate = 1)\n\nCreate processor that stores the solution and time every nupdate time step.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.realtimeplotter","page":"API","title":"IncompressibleNavierStokes.realtimeplotter","text":"realtimeplotter(;\n    setup,\n    plot = fieldplot,\n    nupdate = 1,\n    displayfig = true,\n    displayupdates = false,\n    sleeptime = nothing,\n    kwargs...,\n)\n\nProcessor for plotting the solution every nupdate time step.\n\nThe sleeptime is slept at every update, to give Makie time to update the plot. Set this to nothing to skip sleeping.\n\nAdditional kwargs are passed to the plot function.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.fieldplot","page":"API","title":"IncompressibleNavierStokes.fieldplot","text":"fieldplot(\n    state;\n    setup,\n    fieldname = :vorticity,\n    type = nothing,\n    kwargs...,\n)\n\nPlot state field in pressure points. If state is Observable, then the plot is interactive.\n\nAvailable fieldnames are:\n\n:velocity,\n:vorticity,\n:streamfunction,\n:pressure.\n\nAvailable plot types for 2D are:\n\nheatmap (default),\nimage,\ncontour,\ncontourf.\n\nAvailable plot types for 3D are:\n\ncontour (default).\n\nThe alpha value gets passed to contour in 3D.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_history_plot","page":"API","title":"IncompressibleNavierStokes.energy_history_plot","text":"energy_history_plot(state; setup)\n\nCreate energy history plot.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_spectrum_plot","page":"API","title":"IncompressibleNavierStokes.energy_spectrum_plot","text":"energy_spectrum_plot(state; setup)\n\nCreate energy spectrum plot. The energy at a scalar wavenumber level kappa in mathbbN is defined by\n\nhate(kappa) = int_kappa leq  k _2  kappa + 1  hate(k)  mathrmd k\n\nas in San and Staples [15].\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.animator","page":"API","title":"IncompressibleNavierStokes.animator","text":"animator(; setup, path, plot = fieldplot, nupdate = 1, kwargs...)\n\nAnimate a plot of the solution every update iteration. The animation is saved to path, which should have one of the following extensions:\n\n\".mkv\"\n\".mp4\"\n\".webm\"\n\".gif\"\n\nThe plot is determined by a plotter processor. Additional kwargs are passed to plot.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Solvers","page":"API","title":"Solvers","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_timestep\nsolve_unsteady\nsolve_steady_state","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.get_timestep","page":"API","title":"IncompressibleNavierStokes.get_timestep","text":"get_timestep(stepper, cfl; bc_vectors)\n\nEstimate time step based on eigenvalues of operators, using Gershgorin.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_unsteady","page":"API","title":"IncompressibleNavierStokes.solve_unsteady","text":"solve_unsteady(\n    setup,\n    u₀,\n    tlims;\n    method = RK44(; T = eltype(u₀[1])),\n    psolver = DirectPressureSolver(setup),\n    Δt = zero(eltype(u₀[1])),\n    cfl = 1,\n    n_adapt_Δt = 1,\n    docopy = true,\n    processors = (;),\n)\n\nSolve unsteady problem using method.\n\nIf Δt is a real number, it is rounded such that (t_end - t_start) / Δt is an integer. If Δt = nothing, the time step is chosen every n_adapt_Δt iteration with CFL-number cfl .\n\nThe processors are called after every time step.\n\nNote that the state observable passed to the processor.initialize function contains vector living on the device, and you may have to move them back to the host using Array(u) in the processor.\n\nReturn (; u, t), outputs, where outputs is a  named tuple with the outputs of processors with the same field names.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_steady_state","page":"API","title":"IncompressibleNavierStokes.solve_steady_state","text":"function solve_steady_state(\n    setup, V₀, p₀;\n    jacobian_type = :newton,\n    npicard = 2,\n    abstol = 1e-10,\n    maxiter = 10,\n)\n\nSolve steady state problem of the Navier-Stokes equations. This saddlepoint system arises from linearization of the convective terms.\n\nEach processor is called after every processor.nupdate iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"save_vtk\nplotgrid\nget_lims\nplotmat","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.save_vtk","page":"API","title":"IncompressibleNavierStokes.save_vtk","text":"save_vtk(setup, u, filename = \"output/solution\"; fieldnames = [:velocity], psolver)\n\nSave velocity and pressure field to a VTK file.\n\nIn the case of a 2D setup, the velocity field is saved as a 3D vector with a z-component of zero, as this seems to be preferred by ParaView.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plotgrid","page":"API","title":"IncompressibleNavierStokes.plotgrid","text":"plotgrid(x...)\n\nPlot nonuniform Cartesian grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_lims","page":"API","title":"IncompressibleNavierStokes.get_lims","text":"get_lims(x, n = 1.5)\n\nGet approximate lower and upper limits of a field x based on the mean and standard deviation (mu pm n sigma). If x is constant, a margin of 1e-4 is enforced. This is required for contour plotting functions that require a certain range.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plotmat","page":"API","title":"IncompressibleNavierStokes.plotmat","text":"plotmat(A)\n\nPlot matrix.\n\n\n\n\n\n","category":"function"},{"location":"features/precision/#Floating-point-precision","page":"Floating point precision","title":"Floating point precision","text":"","category":"section"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"IncompressibleNavierStokes generates efficient code for different floating point precisions, such as","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"Double precision (Float64)\nSingle precision (Float32)\nHalf precision (Float16)","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"To use single or half precision, all user input floats should be converted to the desired type. Mixing different precisions causes unnecessary conversions and may break the code. See the tutorial for an example on how to enforce floating point type hygiene.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: GPU precision\nFor GPUs, single precision is preferred. CUDA.jls cu converts to single precision.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: Pressure solvers\nSparseArrays.jls sparse matrix factorizations only support double precision. DirectPressureSolver only works for Float64. Consider using an iterative solver such as CGPressureSolver when using single or half precision.","category":"page"}]
}
