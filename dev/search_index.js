var documenterSearchIndex = {"docs":
[{"location":"features/closure/#Neural-closure-models","page":"Neural closure models","title":"Neural closure models","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"note: `NeuralClorusure`\nThese features are experimental, and require cloning IncompressibleNavierStokes from GitHub:git clone https://github.com/agdestein/IncompressibleNavierStokes.jl\ncd IncompressibleNavierStokes/lib/NeuralClosure","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"For large eddy simulation (LES), a closure model is required. With IncompressibleNavierStokes, a neural closure model can be trained on filtered DNS data. The discrete DNS equations are given by","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM u  = 0 \nfracmathrmd umathrmd t  = F(u) - G p\nendsplit","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"Applying a spatial filter Phi, the extracted large scale components baru = Phi u are governed by the equation","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM baru  = 0 \nfracmathrmd barumathrmd t  = F(baru) + c - G barp\nendsplit","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"where the discretizations M, F, and G are adapted to the size of their inputs and c = overlineF(u) - F(baru) is a commutator error. We here assumed that M and Phi commute, which is the case for face averaging filters. Replacing c with a parameterized closure model m(baru theta) approx c gives the LES equations for the approximate large scale velocity barv approx baru","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"beginsplit\nM barv  = 0 \nfracmathrmd barvmathrmd t  = F(barv) + m(barv theta) - G barq\nendsplit","category":"page"},{"location":"features/closure/#NeuralClosure-module","page":"Neural closure models","title":"NeuralClosure module","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"IncompressibleNavierStokes provides a NeuralClosure module.","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.NeuralClosure","category":"page"},{"location":"features/closure/#NeuralClosure.NeuralClosure","page":"Neural closure models","title":"NeuralClosure.NeuralClosure","text":"Neural closure modelling tools.\n\n\n\n\n\n","category":"module"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"The following filters are available:","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.FaceAverage\nNeuralClosure.VolumeAverage\nNeuralClosure.reconstruct!","category":"page"},{"location":"features/closure/#NeuralClosure.FaceAverage","page":"Neural closure models","title":"NeuralClosure.FaceAverage","text":"(::FaceAverage)(v, u, setup_les)\n\nAverage fine grid u over coarse volume face. Put result in v.\n\n\n\n\n\n","category":"type"},{"location":"features/closure/#NeuralClosure.VolumeAverage","page":"Neural closure models","title":"NeuralClosure.VolumeAverage","text":"(::VolumeAverage)(v, u, setup_les, comp)\n\nAverage fine grid u over coarse volume. Put result in v.\n\n\n\n\n\n","category":"type"},{"location":"features/closure/#NeuralClosure.reconstruct!","page":"Neural closure models","title":"NeuralClosure.reconstruct!","text":"reconstruct!(u, v, setup_dns, setup_les)\n\nAverage fine grid u over coarse volume face. Put result in v.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"The following functions create data.","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.filtersaver\nNeuralClosure.create_les_data\nNeuralClosure.create_io_arrays","category":"page"},{"location":"features/closure/#NeuralClosure.filtersaver","page":"Neural closure models","title":"NeuralClosure.filtersaver","text":"filtersaver(dns, les, filters, compression, psolver_dns, psolver_les; nupdate = 1)\n\nSave filtered DNS data.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_les_data","page":"Neural closure models","title":"NeuralClosure.create_les_data","text":"create_les_data(\n    D = 2,\n    Re = 2e3,\n    lims = ntuple(α -> (typeof(Re)(0), typeof(Re)(1)), D),\n    nles = [ntuple(α -> 64, D)],\n    ndns = ntuple(α -> 256, D),\n    filters = (FaceAverage(),),\n    tburn = typeof(Re)(0.1),\n    tsim = typeof(Re)(0.1),\n    Δt = typeof(Re)(1e-4),\n    create_psolver = psolver_spectral,\n    savefreq = 1,\n    ArrayType = Array,\n    icfunc = (setup, psolver) -> random_field(setup, typeof(Re)(0); psolver),\n    rng,\n    kwargs...,\n)\n\nCreate filtered DNS data.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_io_arrays","page":"Neural closure models","title":"NeuralClosure.create_io_arrays","text":"create_io_arrays(data, setups)\n\nCreate (baru c) pairs for training.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#Training","page":"Neural closure models","title":"Training","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"To improve the model parameters, we exploit exact filtered DNS data baru and exact commutator errors c obtained through DNS. The model is trained by minimizing the a priori loss function","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"L^textprior(theta) =  m(baru theta) - c ^2","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"or the a posteriori loss function","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"L^textpost(theta) =  barv_theta - baru ^2","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"where barv_theta is the solution to the LES equation for the given parameters theta. The prior loss is easy to evaluate and easy to differentiate, as it does not involve solving the ODE. However, minimizing L^textprior does not take into account the effect of the prediction error on the LES solution error. The posterior loss does, but has a longer computational chain involving solving the LES ODE.","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.create_dataloader_prior\nNeuralClosure.create_dataloader_post\nNeuralClosure.train\nNeuralClosure.create_loss_prior\nNeuralClosure.create_relerr_prior\nNeuralClosure.mean_squared_error\nNeuralClosure.create_loss_post\nNeuralClosure.create_relerr_post\nNeuralClosure.create_callback","category":"page"},{"location":"features/closure/#NeuralClosure.create_dataloader_prior","page":"Neural closure models","title":"NeuralClosure.create_dataloader_prior","text":"createdataloader(data; nuse = 50, device = identity, rng)\n\nCreate dataloader that uses a batch of batchsize random samples from data at each evaluation. The batch is moved to device.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_dataloader_post","page":"Neural closure models","title":"NeuralClosure.create_dataloader_post","text":"create_dataloader_post(trajectories; nunroll = 10, device = identity, rng)\n\nCreate trajectory dataloader.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.train","page":"Neural closure models","title":"NeuralClosure.train","text":"train(\n    dataloaders,\n    loss,\n    opt,\n    θ;\n    niter = 100,\n    ncallback = 1,\n    callback = (i, θ) -> println(\"Iteration $i of $niter\"),\n)\n\nUpdate parameters θ to minimize loss(dataloader(), θ) using the optimiser opt for niter iterations.\n\nReturn the a new named tuple (; opt, θ, callbackstate) with updated state and parameters.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_loss_prior","page":"Neural closure models","title":"NeuralClosure.create_loss_prior","text":"createloss_prior(loss, f)\n\nWrap loss function loss(batch, θ).\n\nThe function loss should take inputs like loss(f, x, y, θ).\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_relerr_prior","page":"Neural closure models","title":"NeuralClosure.create_relerr_prior","text":"create_relerr_prior(f, x, y)\n\nCreate a-priori error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.mean_squared_error","page":"Neural closure models","title":"NeuralClosure.mean_squared_error","text":"mean_squared_error(f, x, y, θ; normalize = y -> sum(abs2, y), λ = sqrt(eps(eltype(x))))\n\nCompute MSE between f(x, θ) and y.\n\nThe MSE is further divided by normalize(y).\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_loss_post","page":"Neural closure models","title":"NeuralClosure.create_loss_post","text":"create_loss_post(;\n    setup,\n    method = RKMethods.RK44(; T = eltype(setup.grid.x[1])),\n    psolver,\n    closure,\n    nupdate = 1,\n    projectorder = :last,\n)\n\nCreate a-posteriori loss function.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_relerr_post","page":"Neural closure models","title":"NeuralClosure.create_relerr_post","text":"create_relerr_post(;\n    data,\n    setup,\n    method = RKMethods.RK44(; T = eltype(setup.grid.x[1])),\n    psolver,\n    closure_model,\n    nupdate = 1,\n)\n\nCreate a-posteriori relative error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_callback","page":"Neural closure models","title":"NeuralClosure.create_callback","text":"create_callback(\n    f,\n    x,\n    y;\n    state = Point2f[],\n    display_each_iteration = false,\n)\n\nCreate convergence plot for relative error between f(x, θ) and y. At each callback, plot is updated and current error is printed.\n\nIf state is nonempty, it also plots previous convergence.\n\nIf not using interactive GLMakie window, set display_each_iteration to true.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#Neural-architectures","page":"Neural closure models","title":"Neural architectures","text":"","category":"section"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"We provide two neural architectures: A convolutional neural network (CNN) and a Fourier neural operator (FNO).","category":"page"},{"location":"features/closure/","page":"Neural closure models","title":"Neural closure models","text":"NeuralClosure.wrappedclosure\nNeuralClosure.create_closure\nNeuralClosure.create_tensorclosure\nNeuralClosure.collocate\nNeuralClosure.decollocate\nNeuralClosure.cnn\nNeuralClosure.fno\nNeuralClosure.FourierLayer","category":"page"},{"location":"features/closure/#NeuralClosure.wrappedclosure","page":"Neural closure models","title":"NeuralClosure.wrappedclosure","text":"wrappedclosure(m, setup)\n\nWrap closure model and parameters so that it can be used in the solver.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_closure","page":"Neural closure models","title":"NeuralClosure.create_closure","text":"create_closure(layers...; rng)\n\nCreate neural closure model from layers.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.create_tensorclosure","page":"Neural closure models","title":"NeuralClosure.create_tensorclosure","text":"create_tensorclosure(layers...; setup, rng)\n\nCreate tensor basis closure.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.collocate","page":"Neural closure models","title":"NeuralClosure.collocate","text":"collocate(u)\n\nInterpolate velocity components to volume centers.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.decollocate","page":"Neural closure models","title":"NeuralClosure.decollocate","text":"decollocate(u)\n\nInterpolate closure force from volume centers to volume faces.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.cnn","page":"Neural closure models","title":"NeuralClosure.cnn","text":"cnn(;\n    setup,\n    radii,\n    channels,\n    activations,\n    use_bias,\n    channel_augmenter = identity,\n    rng = Random.default_rng(),\n)\n\nCreate CNN closure model. Return a tuple (closure, θ) where θ are the initial parameters and closure(u, θ) predicts the commutator error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.fno","page":"Neural closure models","title":"NeuralClosure.fno","text":"fno(; setup, kmax, c, σ, ψ, rng = Random.default_rng(), kwargs...)\n\nCreate FNO closure model. Return a tuple (closure, θ) where θ are the initial parameters and closure(V, θ) predicts the commutator error.\n\n\n\n\n\n","category":"function"},{"location":"features/closure/#NeuralClosure.FourierLayer","page":"Neural closure models","title":"NeuralClosure.FourierLayer","text":"FourierLayer(dimension, kmax, cin => cout; σ = identity, init_weight = glorot_uniform)\n\nFourier layer operating on uniformly discretized functions.\n\nSome important sizes:\n\ndimension: Spatial dimension, e.g. Dimension(2) or Dimension(3).\n(nx..., cin, nsample): Input size\n(nx..., cout, nsample): Output size\nnx = fill(n, dimension()): Number of points in each spatial dimension\nn ≥ kmax: Same number of points in each spatial dimension, must be larger than cut-off wavenumber\nkmax: Cut-off wavenumber\nnsample: Number of input samples (treated independently)\n\n\n\n\n\n","category":"type"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"D. Kochkov, J. A. Smith, A. Alieva, Q. Wang, M. P. Brenner and S. Hoyer. Machine learning-accelerated computational fluid dynamics. Proceedings of the National Academy of Sciences 118 (2021).\n\n\n\nM. Kurz, P. Offenhäuser and A. Beck. Deep Reinforcement Learning for Turbulence Modeling in Large Eddy Simulations, arXiv (2022).\n\n\n\nF. H. Harlow and J. E. Welch. *         Numerical Calculation of Time‐Dependent Viscous Incompressible Flow         of Fluid with Free Surface     *. The Physics of Fluids 8, 2182–2189 (1965), arXiv:https://aip.scitation.org/doi/pdf/10.1063/1.1761178.\n\n\n\nR. W. Verstappen and A. E. Veldman. Symmetry-Preserving Discretization of Turbulent Flow. J. Comput. Phys. 187, 343–368 (2003).\n\n\n\nB. Sanderse, R. Verstappen and B. Koren. Boundary treatment for fourth-order staggered mesh discretizations of the incompressible Navier–Stokes equations. Journal of Computational Physics 257, 1472–1505 (2014). Physics-compatible numerical methods.\n\n\n\nB. Sanderse and B. Koren. Accuracy analysis of explicit Runge–Kutta methods applied to the incompressible Navier–Stokes equations. Journal of Computational Physics 231, 3041–3063 (2012).\n\n\n\nB. Sanderse. Energy-conserving Runge–Kutta methods for the incompressible Navier–Stokes equations. Journal of Computational Physics 233, 100–131 (2013).\n\n\n\nR. Verstappen and A. Veldman. Direct Numerical Simulation of Turbulence at Lower Costs. Journal of Engineering Mathematics 32, 143–159 (1997).\n\n\n\nJ. Li and P. M. Carrica. A simple approach for vortex core visualization, arXiv:1910.06998 (2019), arXiv:1910.06998 [physics.flu-dyn].\n\n\n\nJ. Jeong and F. Hussain. On the identification of a vortex. J. Fluid. Mech. 285, 69–94 (1995).\n\n\n\nB. Sanderse and F. X. Trias. Energy-consistent discretization of viscous dissipation with application       to natural convection flow (Jul 2023), arXiv:2307.10874v1 [physics.flu-dyn].\n\n\n\nM. H. Silvis, R. A. Remmerswaal and R. Verstappen. Physical consistency of subgrid-scale models for large-eddy simulation of incompressible turbulent flows. Physics of Fluids 29 (2017).\n\n\n\nS. B. Pope. Turbulent Flows (Cambridge University Press, Cambridge, England, 2000).\n\n\n\nF. X. TRIAS, M. SORIA, A. OLIVA and C. D. PÉREZ-SEGARRA. Direct numerical simulations of two- and three-dimensional turbulent natural convection flows in a differentially heated cavity of aspect ratio 4. Journal of Fluid Mechanics 586, 259–293 (2007).\n\n\n\nP. Orlandi. Fluid flow phenomena: a numerical toolkit. Vol. 55 (Springer Science & Business Media, 2000).\n\n\n\nO. San and A. E. Staples. High-order methods for decaying two-dimensional homogeneous isotropic turbulence. Computers & Fluids 63, 105–127 (2012).\n\n\n\n","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/temperature/#Temperature-equation","page":"Temperature equation","title":"Temperature equation","text":"","category":"section"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"IncompressibleNavierStokes.jl supports adding a temperature equation, which is coupled back to the momentum equation through a gravity term [11].","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"To enable the temperature equation, you need to set the temperature keyword in setup:","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"setup = Setup(\n    args...;\n    kwargs...,\n    temperature = temperature_equation(; kwargs...),\n)","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"where temperature_equation can be configured as follows:","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"temperature_equation","category":"page"},{"location":"features/temperature/#IncompressibleNavierStokes.temperature_equation","page":"Temperature equation","title":"IncompressibleNavierStokes.temperature_equation","text":"temperature_equation(; \n    Pr,\n    Ra,\n    Ge,\n    dodissipation = true,\n    boundary_conditions,\n    gdir = 2,\n)\n\nTemperature equation setup.\n\nThe equation is parameterized by three dimensionless numbers (Prandtl number, Rayleigh number, and Gebhart number), and requires separate boundary conditions for the temperature field. The gdir keyword specifies the direction gravity, while non_dim_type specifies the type of non-dimensionalization.\n\n\n\n\n\n","category":"function"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"Some operators are available for the temperature equation:","category":"page"},{"location":"features/temperature/","page":"Temperature equation","title":"Temperature equation","text":"gravity!\nconvection_diffusion_temp!\ndissipation!","category":"page"},{"location":"features/temperature/#IncompressibleNavierStokes.gravity!","page":"Temperature equation","title":"IncompressibleNavierStokes.gravity!","text":"gravity!(F, temp, setup)\n\nCompute gravity term (add to existing F).\n\n\n\n\n\n","category":"function"},{"location":"features/temperature/#IncompressibleNavierStokes.convection_diffusion_temp!","page":"Temperature equation","title":"IncompressibleNavierStokes.convection_diffusion_temp!","text":"convection_diffusion_temp!(c, u, temp, setup)\n\nCompute convection-diffusion term for the temperature equation. Add result to c.\n\n\n\n\n\n","category":"function"},{"location":"features/temperature/#IncompressibleNavierStokes.dissipation!","page":"Temperature equation","title":"IncompressibleNavierStokes.dissipation!","text":"dissipation!(diss, diff, u, setup)\n\nCompute dissipation term for the temperature equation. Add result to diss.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"equations/time/#Time-discretization","page":"Time discretization","title":"Time discretization","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"The spatially discretized Navier-Stokes equations form a differential-algebraic system, with an ODE for the velocity","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"fracmathrmd umathrmd t = F(u t) - (G p + y_G)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"subject to the algebraic constraint formed by the mass equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"M u + y_M = 0","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"In the end of the previous section, we differentiated the mass equation in time to obtain a discrete pressure Poisson equation. This equation includes the term fracmathrmd y_Mmathrmd t, which is non-zero if an unsteady flow of mass is added to the domain (Dirichlet boundary conditions). This term ensures that the time-continuous discrete velocity field u(t) stays divergence free (conserves mass). However, if we directly discretize this system in time, the mass preservation may actually not be respected. For this, we will change the definition of the pressure such that the time-discretized velocity field is divergence free at each time step and each time sub-step (to be defined in the following).","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the interval 0 T for some simulation time T. We will divide it into N sub-intervals t^n t^n + 1 for n = 0 dots N - 1, with t^0 = 0, t^N = T, and increment Delta t^n = t^n + 1 - t^n. We define u^n approx u(t^n) as an approximation to the exact discrete velocity field u(t^n), with u^0 = u(0) starting from the exact initial conditions. We say that the time integration scheme (definition of u^n) is accurate to the order r if u^n = u(t^n) + mathcalO(Delta t^r) for all n.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"IncompressibleNavierStokes provides a collection of explicit and implicit Runge-Kutta methods, in addition to Adams-Bashforth Crank-Nicolson and one-leg beta method time steppers.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"The code is currently not adapted to time steppers from DifferentialEquations.jl, but they may be integrated in the future.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"AbstractODEMethod\nAbstractRungeKuttaMethod\nisexplicit\nlambda_conv_max\nlambda_diff_max\node_method_cache\nnstage\nrunge_kutta_method\ntimestep\ntimestep!","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.AbstractODEMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AbstractODEMethod","text":"AbstractODEMethod\n\nAbstract ODE method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#IncompressibleNavierStokes.AbstractRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AbstractRungeKuttaMethod","text":"AbstractRungeKuttaMethod\n\nAbstract Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#IncompressibleNavierStokes.isexplicit","page":"Time discretization","title":"IncompressibleNavierStokes.isexplicit","text":"isexplicit(method)\n\nReturn true if method is explicit, i.e. the value at a certain time step is given explicitly as a function of the previous time steps only.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.lambda_conv_max","page":"Time discretization","title":"IncompressibleNavierStokes.lambda_conv_max","text":"lambda_conv_max(method)\n\nGet maximum value of stability region for the convection operator (not a very good indication for the methods that do not include the imaginary axis)\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.lambda_diff_max","page":"Time discretization","title":"IncompressibleNavierStokes.lambda_diff_max","text":"lambda_diff_max(method)\n\nGet maximum value of stability region for the diffusion operator.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.ode_method_cache","page":"Time discretization","title":"IncompressibleNavierStokes.ode_method_cache","text":"ode_method_cache(method, setup)\n\nGet time stepper cache for the given ODE method.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.nstage","page":"Time discretization","title":"IncompressibleNavierStokes.nstage","text":"nstage(rk_method)\n\nGet number of stages of the Runge-Kutta method.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.runge_kutta_method","page":"Time discretization","title":"IncompressibleNavierStokes.runge_kutta_method","text":"runge_kutta_method(A, b, c, r; [p_add_solve], [newton_type], [maxiter], [abstol], [reltol])\n\nGet Runge Kutta method. The function checks whether the method is explicit.\n\np_add_solve: whether to add a pressure solve step to the method.\n\nFor implicit RK methods: newton_type, maxiter, abstol, reltol.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.timestep","page":"Time discretization","title":"IncompressibleNavierStokes.timestep","text":"step(stepper, Δt; bc_vectors = nothing)\n\nPerform one time step.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also timestep!.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#IncompressibleNavierStokes.timestep!","page":"Time discretization","title":"IncompressibleNavierStokes.timestep!","text":"step!(stepper, Δt; cache, momentum_cache, bc_vectors = nothing)\n\nPerform one time step>\n\nMutating/non-allocating/in-place version.\n\nSee also timestep.\n\n\n\n\n\n","category":"function"},{"location":"equations/time/#Explicit-Runge-Kutta-methods","page":"Time discretization","title":"Explicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [6].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Consider the velocity field u_0 at a certain time t_0. We will now perform one time step to t = t_0 + Delta t. For explicit Runge-Kutta methods, this time step is divided into s sub-steps t_i = t_0 + Delta t_i with increment Delta t_i = c_i Delta t. The final substep performs the full time step Delta t_s = Delta t such that t_s = t.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"For i = 1 dots s, the intermediate velocity u_i and pressure p_i are computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nk_i  = F(u_i - 1 t_i - 1) - y_G(t_i - 1) \nv_i  = u_0 + Delta t sum_j = 1^i a_i j k_j \nL p_i  = W M frac1c_i sum_j = 1^i a_i j k_j +\nW fracy_M(t_i) - y_M(t_0)Delta t_i \n = W frac(M v_i + y_M(t_i)) - (M u_0 + y_M(t_0))Delta t_i^n \n = W fracM v_i + y_M(t_i)Delta t_i^n \nu_i  = v_i - Delta t_i G p_i\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where (a_i j)_i j are the Butcher tableau coefficients of the RK-method, with the convention c_i = sum_j = 1^i a_i j.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, we return u_s. If u_0 = u(t_0), we get the accuracy u_s = u(t) + mathcalO(Delta t^r + 1), where r is the order of the RK-method. If we perform n RK time steps instead of one, starting at exact initial conditions u^0 = u(0), then u^n = u(t^n) + mathcalO(Delta t^r) for all n in 1 dots N. Note that for a given u, the corresponding pressure p can be calculated to the same accuracy as u by doing an additional pressure projection after each outer time step Delta t (if we know fracmathrmd y_Mmathrmd t(t)), or to first order accuracy by simply returning p_s.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Note that each of the sub-step velocities u_i is divergence free, after projecting the tentative velocities v_i. This is ensured due to the judiciously chosen replacement of fracmathrmd y_Mmathrmd t(t_i) with (y_M(t_i) - y_M(t_0))  Delta t_i. The space-discrete divergence-freeness is thus perfectly preserved, even though the time discretization introduces other errors.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"ExplicitRungeKuttaMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.ExplicitRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.ExplicitRungeKuttaMethod","text":"ExplicitRungeKuttaMethod(; A, b, c, r, p_add_solve = true)\n\nExplicit Runge Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#Implicit-Runge-Kutta-methods","page":"Time discretization","title":"Implicit Runge-Kutta methods","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Sanderse [7].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"ImplicitRungeKuttaMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.ImplicitRungeKuttaMethod","page":"Time discretization","title":"IncompressibleNavierStokes.ImplicitRungeKuttaMethod","text":"ImplicitRungeKuttaMethod(;\n    A,\n    b,\n    c,\n    r,\n    newton_type = :full,\n    maxiter = 10,\n    abstol = 1e-14,\n    reltol = 1e-14,\n    p_add_solve = true,\n)\n\nImplicit Runge Kutta method.\n\nThe implicit linear system is solved at each time step using Newton's method. The newton_type may be one of the following:\n\n:no: Replace iteration matrix with I/Δt (no Jacobian)\n:approximate: Build Jacobian once before iterations only\n:full: Build Jacobian at each iteration\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#Adams-Bashforth-Crank-Nicolson-method","page":"Time discretization","title":"Adams-Bashforth Crank-Nicolson method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. This methods uses Adams-Bashforth for the convective terms and Crank-Nicolson stepping for the diffusion and body force terms. Given the velocity field u_0 = u(t_0) at a time t_0 and its previous value u_-1 = u(t_0 - Delta t) at the previous time t_-1 = t_0 - Delta t, the predicted velocity field u at the time t = t_0 + Delta t is defined by first computing a tentative velocity:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nfracv - u_0Delta t\n = - (alpha_0 C(u_0 t_0) + alpha_-1 C(u_-1 t_-1)) \n + theta (D u_0 + y_D(t_0)) + (1 - theta) (D v + y_D(t)) \n + theta f(t_0) + (1 - theta) f(t) \n - (G p_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"where theta in 0 1 is the Crank-Nicolson parameter (theta = frac12 for second order convergence), (alpha_0 alpha_-1) = left( frac32 -frac12 right) are the Adams-Bashforth coefficients, and v is a tentative velocity yet to be made divergence free. We can group the terms containing v on the left hand side, to obtain","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"beginsplit\nleft( frac1Delta t I - (1 - theta) D right) v\n = left(frac1Delta t I - theta D right) u_0 \n - (alpha_0 C(u_0 t_0) + alpha_-1 C(u_-1 t_-1)) \n + theta y_D(t_0) + (1 - theta) y_D(t) \n + theta f(t_0) + (1 - theta) f(t) \n - (G p_0 + y_G(t_0))\nendsplit","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We can compute v by inverting the positive definite matrix left( frac1Delta t I - theta D right) for the given right hand side using a suitable linear solver. Assuming Delta t is constant, we can precompute a Cholesky factorization of this matrix before starting time stepping.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We then compute the pressure difference Delta p by solving","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta p = W fracM v + y_M(t)Delta t - W M (y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"after which a divergence free velocity u can be enforced:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"u = v - Delta t (G Delta p + y_G(t) - y_G(t_0))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A first order accurate prediction of the corresponding pressure is p = p_0 + Delta p. However, since this pressure is reused in the next time step, we perform an additional pressure solve to avoid accumulating first order errors. The resulting pressure p is then accurate to the same order as u.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"AdamsBashforthCrankNicolsonMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","page":"Time discretization","title":"IncompressibleNavierStokes.AdamsBashforthCrankNicolsonMethod","text":"AdamsBashforthCrankNicolsonMethod(\n    T = Float64;\n    α₁ = T(3 // 2),\n    α₂ = T(-1 // 2),\n    θ = T(1 // 2),\n    p_add_solve = true,\n    method_startup,\n)\n\nIMEX AB-CN: Adams-Bashforth for explicit convection (parameters α₁ and α₂) and Crank-Nicolson for implicit diffusion (implicitness θ). The method is second order for θ = 1/2.\n\nThe LU decomposition of the LHS matrix is computed every time the time step changes.\n\nNote that, in contrast to explicit methods, the pressure from previous time steps has an influence on the accuracy of the velocity.\n\n\n\n\n\n","category":"type"},{"location":"equations/time/#One-leg-beta-method","page":"Time discretization","title":"One-leg beta method","text":"","category":"section"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"See Verstappen and Veldman [4] [8].","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"We here require that the time step Delta t is constant. Given the velocity u_0 and pressure p_0 at the current time t_0 and their previous values u_-1 and p_-1 at the time t_-1 = t_0 - Delta t, we start by computing the \"offstep\" values v = (1 + beta) v_0 - beta v_-1 and Q = (1 + beta) p_0 - beta p_-1 for some beta = frac12.","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A tentative velocity field tildev is then computed as follows:","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"tildev = frac1beta + frac12 left( 2 beta u_0 - left( beta -\nfrac12 right) u_-1 + Delta t F(v t) - Delta t\n(G Q + y_G(t)) right)","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"A pressure correction Delta p is obtained by solving the Poisson equation","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"L Delta p = fracbeta + frac12Delta t W (M tildev + y_M(t))","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"Finally, the divergence free velocity field is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"u = tildev - fracDelta tbeta + frac12 G Delta p","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"while the second order accurate pressure is given by","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"p = 2 p_0 - p_-1 + frac43 Delta p","category":"page"},{"location":"equations/time/","page":"Time discretization","title":"Time discretization","text":"OneLegMethod","category":"page"},{"location":"equations/time/#IncompressibleNavierStokes.OneLegMethod","page":"Time discretization","title":"IncompressibleNavierStokes.OneLegMethod","text":"OneLegMethod(\n    T = Float64;\n    β = T(1 // 2),\n    p_add_solve = true,\n    method_startup,\n)\n\nExplicit one-leg β-method following symmetry-preserving discretization of turbulent flow. See Verstappen and Veldman [4] [8] for details.\n\n\n\n\n\n","category":"type"},{"location":"features/gpu/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"IncompressibleNavierStokes supports various array types. The desired array type only has to be passed to the Setup function:","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\nsetup = Setup(x...; kwargs..., ArrayType = CuArray)","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"All operators have been made are backend agnostic by using KernelAbstractions.jl. Even if a GPU is not available, the operators are multithreaded if Julia is started with multiple threads (e.g. julia -t 4)","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"This has been tested with CUDA compatible GPUs.\nThis has not been tested with other GPU interfaces, such as\nAMDGPU.jl\nMetal.jl\noneAPI.jl\nIf they start supporting sparse matrices and fast Fourier transforms they could also be used. ","category":"page"},{"location":"features/gpu/","page":"GPU Support","title":"GPU Support","text":"note: `psolver_direct` on CUDA\nTo use a specialized linear solver for CUDA, make sure to install and using CUDA.jl and CUDSS.jl. Then psolver_direct will automatically use the CUDSS solver.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"EditURL = \"../../../examples/LidDrivenCavity2D.jl\"","category":"page"},{"location":"generated/LidDrivenCavity2D/#Tutorial:-Lid-Driven-Cavity-2D","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity - 2D","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In this example we consider a box with a moving lid. The velocity is initially at rest. The solution should reach at steady state equilibrium after a certain time. The same steady state should be obtained when solving a steady state problem.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We start by loading packages. A Makie plotting backend is needed","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Case name for saving results","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"output = \"output/LidDrivenCavity2D\"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The code allows for using different floating point number types, including single precision (Float32) and double precision (Float64). On the CPU, the speed is not really different, but double precision uses twice as much memory as single precision. When running on the GPU, single precision is preferred. Half precision (Float16) is also an option, but then the values should be scaled judiciously to avoid vanishing digits when applying differential operators of the form \"right minus left divided by small distance\".","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Note how floating point type hygiene is enforced in the following using T to avoid mixing different precisions.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"T = Float64","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"T = Float32\n# T = Float16","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can also choose to do the computations on a different device. By default, the computations are performed on the host (CPU). An optional ArrayType allows for moving arrays to a different device such as a GPU.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Note: For GPUs, single precision is preferred.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Here we choose a moderate Reynolds number. Note how we pass the floating point type.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Re = T(1_000)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Non-zero Dirichlet boundary conditions are specified as plain Julia functions. Note that time derivatives are required.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"boundary_conditions = (\n    # x left, x right\n    (DirichletBC(), DirichletBC()),\n\n    # y bottom, y top\n    (\n        DirichletBC(),\n        DirichletBC(\n            (dim, x, y, t) -> dim() == 1 ? one(x) : zero(x),\n            (dim, x, y, t) -> zero(x),\n        ),\n    ),\n)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We create a two-dimensional domain with a box of size [1, 1]. The grid is created as a Cartesian product between two vectors. We add a refinement near the walls.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"n = 32\nlims = T(0), T(1)\nx = cosine_grid(lims..., n)\ny = cosine_grid(lims..., n)\nplotgrid(x, y)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We can now build the setup and assemble operators. A 3D setup is built if we also provide a vector of z-coordinates.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"setup = Setup(x, y; boundary_conditions, Re, ArrayType);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The initial conditions are provided in function. The value dim() determines the velocity component.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"ustart = create_initial_conditions(setup, (dim, x, y) -> zero(x));\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/#Solve-problems","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Solve problems","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Problems can be solved.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"The solve_steady_state function is for computing a state where the right hand side of the momentum equation is zero.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# u, p = solve_steady_state(setup, u₀, p₀)\nnothing","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"For this test case, the same steady state may be obtained by solving an unsteady problem for a sufficiently long time.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Iteration processors are called after every nupdate time steps. This can be useful for logging, plotting, or saving results. Their respective outputs are later returned by solve_unsteady.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"processors = (\n    # rtp = realtimeplotter(; setup, plot = fieldplot, nupdate = 50),\n    # ehist = realtimeplotter(; setup, plot = energy_history_plot, nupdate = 10),\n    # espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 10),\n    # anim = animator(; setup, path = \"$output/solution.mkv\", nupdate = 20),\n    # vtk = vtk_writer(; setup, nupdate = 100, dir = output, filename = \"solution\"),\n    # field = fieldsaver(; setup, nupdate = 10),\n    log = timelogger(; nupdate = 1000),\n);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"By default, a standard fourth order Runge-Kutta method is used. If we don't provide the time step explicitly, an adaptive time step is used.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"tlims = (T(0), T(10))\nstate, outputs = solve_unsteady(; setup, ustart, tlims, Δt = T(1e-3), processors);\nnothing #hide","category":"page"},{"location":"generated/LidDrivenCavity2D/#Post-process","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"We may visualize or export the computed fields","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Export fields to VTK. The file output/solution.vti may be opened for visualization in ParaView. This is particularly useful for inspecting results from 3D simulations.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\")","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot pressure","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :pressure)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot velocity. Note the time stamp used for computing boundary conditions, if any.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :velocitynorm)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"fieldplot(state; setup, fieldname = :vorticity)","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"In addition, the named tuple outputs contains quantities from our processors. The logger returns nothing.","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"# outputs.rtp\n# outputs.ehist\n# outputs.espec\n# outputs.anim\n# outputs.vtk\n# outputs.field\noutputs.log","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"","category":"page"},{"location":"generated/LidDrivenCavity2D/","page":"Tutorial: Lid-Driven Cavity (2D)","title":"Tutorial: Lid-Driven Cavity (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"EditURL = \"../../../examples/BackwardFacingStep2D.jl\"","category":"page"},{"location":"generated/BackwardFacingStep2D/#Backward-Facing-Step-2D","page":"Walls: Backward Facing Step (2D)","title":"Backward Facing Step - 2D","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"In this example we consider a channel with walls at the top and bottom, and a step at the left with a parabolic inflow. Initially the velocity is an extension of the inflow, but as time passes the velocity finds a new steady state.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Output directory","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"output = \"output/BackwardFacingStep2D\"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Floating point type","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"T = Float64","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Array type","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Reynolds number","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Re = T(3_000)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Boundary conditions: steady inflow on the top half","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"U(dim, x, y, t) =\n    dim() == 1 && y ≥ 0 ? 24y * (one(x) / 2 - y) : zero(x) + randn(typeof(x)) / 1_000\ndUdt(dim, x, y, t) = zero(x)\nboundary_conditions = (\n    # x left, x right\n    (DirichletBC(U, dUdt), PressureBC()),\n\n    # y rear, y front\n    (DirichletBC(), DirichletBC()),\n)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"A 2D grid is a Cartesian product of two vectors. Here we refine the grid near the walls.","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"x = LinRange(T(0), T(10), 301)\ny = cosine_grid(-T(0.5), T(0.5), 51)\nplotgrid(x, y)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"setup = Setup(x, y; Re, boundary_conditions, ArrayType);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"ustart = create_initial_conditions(setup, (dim, x, y) -> U(dim, x, y, zero(x)));\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Solve steady state problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"# u, p = solve_steady_state(setup, u₀, p₀);\nnothing","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"state, outputs = solve_unsteady(;\n    setup,\n    ustart,\n    tlims = (T(0), T(7)),\n    Δt = T(0.002),\n    processors = (\n        rtp = realtimeplotter(;\n            setup,\n            plot = fieldplot,\n            # plot = energy_history_plot,\n            # plot = energy_spectrum_plot,\n            nupdate = 1,\n        ),\n        # anim = animator(; setup, path = \"$output/vorticity.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = output, filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 1),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/BackwardFacingStep2D/#Post-process","page":"Walls: Backward Facing Step (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"We may visualize or export the computed fields","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Export to VTK","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\")","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot pressure","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :pressure)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot velocity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :velocitynorm)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"fieldplot(state; setup, fieldname = :vorticity)","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"","category":"page"},{"location":"generated/BackwardFacingStep2D/","page":"Walls: Backward Facing Step (2D)","title":"Walls: Backward Facing Step (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"EditURL = \"../../../examples/DecayingTurbulence2D.jl\"","category":"page"},{"location":"generated/DecayingTurbulence2D/#Decaying-Homogeneous-Isotropic-Turbulence-2D","page":"Decaying Turbulunce (2D)","title":"Decaying Homogeneous Isotropic Turbulence - 2D","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"In this example we consider decaying homogeneous isotropic turbulence, similar to the cases considered in [1] and [2]. The initial velocity field is created randomly, but with a specific energy spectrum. Due to viscous dissipation, the turbulent features eventually group to form larger visible eddies.","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Output directory","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"output = \"output/DecayingTurbulence2D\"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Floating point precision","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"T = Float64","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Array type","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"ArrayType = Array\n# using CUDA; ArrayType = CuArray\n# using AMDGPU; ArrayType = ROCArray\n# using oneAPI; ArrayType = oneArray\n# using Metal; ArrayType = MtlArray","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Viscosity model","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Re = T(10_000)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"n = 256\nlims = T(0), T(1)\nx = LinRange(lims..., n + 1), LinRange(lims..., n + 1)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"setup = Setup(x...; Re, ArrayType);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Create random initial conditions","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"ustart = random_field(setup, T(0));\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"state, outputs = solve_unsteady(;\n    setup,\n    ustart,\n    tlims = (T(0), T(1)),\n    Δt = T(1e-3),\n    processors = (\n        # rtp = realtimeplotter(; setup, nupdate = 1),\n        ehist = realtimeplotter(;\n            setup,\n            plot = energy_history_plot,\n            nupdate = 10,\n            displayfig = false,\n        ),\n        espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 10),\n        # anim = animator(; setup, path = \"$output/solution.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = output, filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 100),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/DecayingTurbulence2D/#Post-process","page":"Decaying Turbulunce (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"We may visualize or export the computed fields (u, p)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy history","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs.ehist","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Energy spectrum","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"outputs.espec","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Export to VTK","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\")","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"Plot field","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"fieldplot(state; setup)","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"","category":"page"},{"location":"generated/DecayingTurbulence2D/","page":"Decaying Turbulunce (2D)","title":"Decaying Turbulunce (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"equations/spatial/#Spatial-Discretization","page":"Spatial discretization","title":"Spatial Discretization","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"the d spatial dimensions are indexed by alpha in 1 dots d. The alpha-th unit vector is denoted e_alpha = (e_alpha beta)_beta = 1^d, where the Kronecker symbol e_alpha beta is 1 if alpha = beta and 0 otherwise. We note h_alpha = e_alpha  2. The Cartesian index I = (I_1 dots I_d) is used to avoid repeating terms and equations d times, where I_alpha is a scalar index (typically one of i, j, and k in common notation). This notation is dimension-agnostic, since we can write u_I instead of u_i j in 2D or u_i j k in 3D. In our Julia implementation of the solver we use the same Cartesian notation (u[I] instead of u[i, j] or u[i, j, k]).","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"For the discretization scheme, we use a staggered Cartesian grid as proposed by Harlow and Welch [3]. Consider a rectangular domain Omega = prod_alpha = 1^d a_alpha b_alpha, where a_alpha  b_alpha are the domain boundaries and prod is a Cartesian product. Let Omega = bigcup_I in mathcalI Omega_I be a partitioning of Omega, where mathcalI = prod_alpha = 1^d  frac12 2 - frac12 dots N_alpha - frac12  are volume center indices, N = (N_1 dots N_d) in mathbbN^d are the number of volumes in each dimension, Omega_I = prod_alpha = 1^d Delta^alpha_I_alpha is a finite volume, Gamma^alpha_I = Omega_I - h_alpha cap Omega_I + h_alpha = prod_beta neq alpha Delta^beta_I_beta is a volume face, Delta^alpha_i = left x^alpha_i - frac12 x^alpha_i + frac12 right is a volume edge, x^alpha_0 dots x^alpha_N_alpha are volume boundary coordinates, and x^alpha_i = frac12 left(x^alpha_i - frac12 + x^alpha_i + frac12right) for i in  1  2 dots N_alpha - 1  2 are volume center coordinates. We also define the operator delta_alpha which maps a discrete scalar field varphi = (varphi_I)_I to","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(delta_alpha varphi)_I = fracvarphi_I + h_alpha - varphi_I -\nh_alpha Delta^alpha_I_alpha ","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"It can be interpreted as a discrete equivalent of the continuous operator fracpartialpartial x^alpha. All the above definitions are extended to be valid in volume centers I in mathcalI, volume faces I in mathcalI + h_alpha, or volume corners I in mathcalI + sum_alpha = 1^d h_alpha. The discretization is illustrated below:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(Image: Grid)","category":"page"},{"location":"equations/spatial/#Finite-volume-discretization-of-the-Navier-Stokes-equations","page":"Spatial discretization","title":"Finite volume discretization of the Navier-Stokes equations","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We now define the unknown degrees of freedom. The average pressure in Omega_I, I in mathcalI is approximated by the quantity p_I(t). The average alpha-velocity on the face Gamma^alpha_I, I in mathcalI + h_alpha is approximated by the quantity u^alpha_I(t). Note how the pressure p and the d velocity fields u^alpha are each defined in their own canonical positions x_I and x_I + h_alpha for I in mathcalI. In the following, we derive equations for these unknowns.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Using the pressure control volume mathcalO = Omega_I with I in mathcalI in the mass integral constraint and approximating the face integrals with the mid-point quadrature rule int_Gamma_I u  mathrmd Gamma approx  Gamma_I  u_I results in the discrete divergence-free constraint","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d (delta_alpha u^alpha)_I = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Note how dividing by the volume size results in a discrete equation resembling the continuous one (since  Omega_I  =  Gamma^alpha_I   Delta^alpha_I_alpha ).","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Similarly, choosing an alpha-velocity control volume mathcalO = Omega_I with I in mathcalI + h_alpha in the integral momentum equation, approximating the volume- and face integrals using the mid-point quadrature rule, and replacing remaining spatial derivatives in the diffusive term with a finite difference approximation gives the discrete momentum equations","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"fracmathrmdmathrmd t u^alpha_I =\n- sum_beta = 1^d\n(delta_beta (u^alpha u^beta))_I\n+ nu sum_beta = 1^d\n(delta_beta delta_beta u^alpha)_I\n+ f^alpha(x_I)\n- (delta_alpha p)_I","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where we made the assumption that f is constant in time for simplicity. The outer discrete derivative in (delta_beta delta_beta u^alpha)_I is required at the position I, which means that the inner derivative is evaluated as (delta_beta u^alpha)_I + h_beta and (delta_beta u^alpha)_I - h_beta, thus requiring u^alpha_I - 2 h_beta, u^alpha_I, and u^alpha_I + 2 h_beta, which are all in their canonical positions. The two velocity components in the convective term u^alpha u^beta are required at the positions I - h_beta and I + h_beta, which are outside the canonical positions. Their value at the required position is obtained using averaging with weights 1  2 for the alpha-component and with linear interpolation for the beta-component. This preserves the skew-symmetry of the convection operator, such that energy is conserved (in the convective term) [4].","category":"page"},{"location":"equations/spatial/#Boundary-conditions","page":"Spatial discretization","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Storage convention\nWe use the column-major convention (Julia, MATLAB, Fortran), and not the row-major convention (Python, C). Thus the x^1-index i will vary for one whole cycle in the vectors before the x^2-index j, x^3 index k, and component-index alpha are incremented, e.g. u_h = (u^1_(1 1 1) u^1_(2 1 1) dots u^3_(N_u^3(1) N_u^3(2) N_u^3(3))) in 3D.","category":"page"},{"location":"equations/spatial/#Fourth-order-accurate-discretization","page":"Spatial discretization","title":"Fourth order accurate discretization","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The above discretization is second order accurate. A fourth order accurate discretization can be obtained by judiciously combining the second order discretization with itself on a grid with three times larger cells in each dimension [4] [5]. The coarse discretization is identical, but the mass equation is derived for the three times coarser control volume","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Omega^3_I =\nbigcup_alpha = 1^d Omega_I - e_alpha cup\nOmega_I cup Omega_I + e_alpha","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"while the momentum equation is derived for its shifted variant Omega^3_I + h_alpha. The resulting fourth order accurate equations are given by","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"sum_alpha = 1^d\n(delta_alpha u^alpha)_I\n-\nfrac Omega^3_I 3^2 + d  Omega_I \nsum_alpha = 1^d\n(delta^3_alpha u^alpha)_I\n= 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"and","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"fracmathrmdmathrmd t u^alpha_I =\n- sum_beta = 1^d\n(delta_beta (u^alpha u^beta))_I\n+ nu sum_beta = 1^d\n(delta_beta delta_beta u^alpha)_I\n+ f^alpha(x_I)\n- (delta_alpha p)_I\n+ textfourth order","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"(delta^3_alpha varphi)_I =\nfracvarphi_I + 3 h_alpha -\nvarphi_I - 3 h_alphaDelta^alpha_I_alpha - 1 +\nDelta^alpha_I_alpha + Delta^alpha_I_alpha + 1","category":"page"},{"location":"equations/spatial/#Matrix-representation","page":"Spatial discretization","title":"Matrix representation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"We can write the mass and momentum equations in matrix form. We will use the same matrix notation for the second- and fourth order accurate discretizations. The discrete mass equation becomes","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"M u_h + y_M = 0","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where M is the discrete divergence operator and y_M contains the boundary value contributions of the velocity to the divergence field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The discrete momentum equations become","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n    fracmathrmd u_hmathrmd t  = -C(u_h) + nu (D u_h +\n    y_D) + f_h - (G p_h + y_G) \n     = F(u_h) - (G p_h + y_G)\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where C is she convection operator (including boundary contributions), D is the diffusion operator, y_D is boundary contribution to the diffusion term, G = W_u^-1 M^mathsfT W is the pressure gradient operator, y_G contains the boundary contribution of the pressure to the pressure gradient (only non-zero for pressure boundary conditions), W_u is a diagonal matrix containing the velocity volume sizes  Omega_I + delta(alpha)  2 , and W is a diagonal matrix containing the reference volume sizes  Omega_I . The term F refers to all the forces except for the pressure gradient.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Volume normalization\nAll the operators have been divided by the velocity volume sizes. As a result, the operators have the same units as their continuous counterparts.","category":"page"},{"location":"equations/spatial/#Discrete-pressure-Poisson-equation","page":"Spatial discretization","title":"Discrete pressure Poisson equation","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Instead of directly discretizing the continuous pressure Poisson equation, we will rededuce it in the discrete setting, thus aiming to preserve the discrete divergence freeness instead of the continuous one. Applying the discrete divergence operator M to the discrete momentum equations yields the discrete pressure Poisson equation","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"L p_h = W M (F(u_h) - y_G) + W fracmathrmd y_Mmathrmd t","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"where L = W M G = W M W_u^-1 M^mathsfT W is a discrete Laplace operator. It is positive symmetric.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Unsteady Dirichlet boundary conditions\nIf the equations are prescribed with unsteady Dirichlet boundary conditions, for example an inflow that varies with time, the term fracmathrmd y_Mmathrmd t will be non-zero. If this term is not known exactly, for example if the next value of the inflow is unknown at the time of the current value, it must be computed using past values of of the velocity inflow only, for example fracmathrmd y_Mmathrmd t approx (y_M(t) - y_M(t - Delta t))  Delta t for some Delta t.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Uniqueness of pressure field\nUnless pressure boundary conditions are present, the pressure is only determined up to a constant, as L will have an eigenvalue of zero. Since only the gradient of the pressure appears in the equations, we can set the unknown constant to zero without affecting the velocity field.","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"note: Pressure projection\nThe pressure field p_h can be seen as a Lagrange multiplier enforcing the constraint of discrete divergence freeness. It is also possible to write the momentum equations without the pressure by explicitly solving the discrete Poisson equation:p_h = L^-1 W M (F(u_h) - y_G) + L^-1 W fracmathrmd y_Mmathrmd tThe momentum equations then becomefracmathrmd u_hmathrmd t = (I - G L^-1 W M)\n(F(u_h) - y_G) - G L^-1 W fracmathrmd y_Mmathrmd tThe matrix (I - G L^-1 W M) is a projector onto the space of discretely divergence free velocities. However, using this formulation would require an efficient way to perform the projection without assembling the operator matrix L^-1, which would be very costly.","category":"page"},{"location":"equations/spatial/#Discrete-output-quantities","page":"Spatial discretization","title":"Discrete output quantities","text":"","category":"section"},{"location":"equations/spatial/#Kinetic-energy","page":"Spatial discretization","title":"Kinetic energy","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The local kinetic energy is defined by k = frac12  u _2^2 = frac12 sum_alpha = 1^d u^alpha u^alpha. On the staggered grid however, the different velocity components are not located at the same point. We will therefore interpolate the velocity to the pressure point before summing the squares.","category":"page"},{"location":"equations/spatial/#Vorticity","page":"Spatial discretization","title":"Vorticity","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, the vorticity is a scalar. We define it as","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"omega = -delta^2 u^1 + delta^1 u^2","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"The 3D vorticity is a vector field (omega^1 omega^2 omega^3). Noting alpha^+ = operatornamemod_3(alpha + 1) and alpha^- = operatornamemod_3(alpha - 1), the vorticity is defined as through","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"omega^alpha = - delta^alpha^- u^alpha^+ +\ndelta^alpha^+ u^alpha^-","category":"page"},{"location":"equations/spatial/#Stream-function","page":"Spatial discretization","title":"Stream function","text":"","category":"section"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"In 2D, the stream function is defined at the corners with the vorticity. Integrating the stream function Poisson equation over the vorticity volume yields","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\n- int_Omega_I + h_1 + h_2 omega  mathrmd Omega\n = int_Omega_I + h_1 + h_2 nabla^2 psi \nmathrmd Omega \n = int_Gamma^1_I + e_1 + h_2 fracpartial psipartial x^1\n mathrmd Gamma\n- int_Gamma^1_I + h_2 fracpartial psipartial x^1\n mathrmd Gamma \n + int_Gamma^2_I + h_1 + e_2 fracpartial psipartial x^2\n mathrmd Gamma\n- int_Gamma^2_I + h_1 fracpartial psipartial x^2\n mathrmd Gamma\nendsplit","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"Replacing the integrals with the mid-point quadrature rule and the spatial derivatives with central finite differences yields the discrete Poisson equation for the stream function at the vorticity point:","category":"page"},{"location":"equations/spatial/","page":"Spatial discretization","title":"Spatial discretization","text":"beginsplit\nleft Gamma^1_I + h_1 + h_2 right\nleft(\n  fracpsi_I + 3  h_1 + h_2 - psi_I + h_1 + h_2x^1_I_1 + 3  2 - x^1_I_1 + 1 2\n- fracpsi_I + h_1 + h_2 - psi_I - h_1 + h_2x^1_I_1 + 1  2 - x^1_I_1 - 1  2\nright)  + \nleft Gamma^2_I + h_1 + h_2 right\nleft(\nfracpsi_I + h_1 + 3 h_2 - psi_I + h_1 + h_2x^2_I_1 + 3  2 - x^2_I_1 + 1  2\n-fracpsi_I + h_1 + h_2 - psi_I + h_1 - h_2x^2_I_2 + 1  2 - x^2_I_2 - 1  2\nright)  = \nleft Omega_I + h_1 + h_2 right\nomega_I + h_1 + h_2 \nendsplit","category":"page"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/tableaux/#API-Reference-–-Runge-Kutta-methods","page":"Runge-Kutta methods","title":"API Reference – Runge-Kutta methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods","text":"RKMethods\n\nSet up Butcher arrays A, b, and c, as well as and SSP coefficient r. For families of methods, optional input s is the number of stages.\n\nOriginal (MATLAB) by David Ketcheson, extended by Benjamin Sanderse.\n\n\n\n\n\n","category":"module"},{"location":"api/tableaux/#Explicit-Methods","page":"Runge-Kutta methods","title":"Explicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.FE11\nRKMethods.SSP22\nRKMethods.SSP42\nRKMethods.SSP33\nRKMethods.SSP43\nRKMethods.SSP104\nRKMethods.rSSPs2\nRKMethods.rSSPs3\nRKMethods.Wray3\nRKMethods.RK56\nRKMethods.DOPRI6","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.FE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.FE11","text":"FE11(; kwargs...)\n\nFE11.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SSP22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SSP22","text":"SSP22(; kwargs...)\n\nSSP22.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SSP42","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SSP42","text":"SSP42(; kwargs...)\n\nSSP42.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SSP33","text":"SSP33(; kwargs...)\n\nSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SSP43","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SSP43","text":"SSP43(; kwargs...)\n\nSSP43.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SSP104","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SSP104","text":"SSP104(; kwargs...)\n\nSSP104.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.rSSPs2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.rSSPs2","text":"rSSPs2(s = 2; kwargs...)\n\nRational (optimal, low-storage) s-stage 2nd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.rSSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.rSSPs3","text":"rSSPs3(s = 4; kwargs...)\n\nRational (optimal, low-storage) s^2-stage 3rd order SSP.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.Wray3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.Wray3","text":"Wray3(; kwargs...)\n\nWray's RK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK56","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK56","text":"RK56(; kwargs...)\n\nRK56.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.DOPRI6","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.DOPRI6","text":"DOPRI6(; kwargs...)\n\nDormand-Price pair.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Implicit-Methods","page":"Runge-Kutta methods","title":"Implicit Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.BE11\nRKMethods.SDIRK34\nRKMethods.ISSPm2\nRKMethods.ISSPs3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.BE11","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.BE11","text":"BE11(; kwargs...)\n\nBackward Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.SDIRK34","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.SDIRK34","text":"SDIRK34(; kwargs...)\n\n3-stage, 4th order singly diagonally implicit (SSP).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.ISSPm2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.ISSPm2","text":"ISSPm2(s = 1; kwargs...)\n\nOptimal DIRK SSP schemes of order 2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.ISSPs3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.ISSPs3","text":"ISSPs3(s = 2; kwargs...)\n\nOptimal DIRK SSP schemes of order 3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Half-explicit-methods","page":"Runge-Kutta methods","title":"Half explicit methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.HEM3\nRKMethods.HEM3BS\nRKMethods.HEM5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.HEM3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.HEM3","text":"HEM3(; kwargs...)\n\nBrasey and Hairer.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.HEM3BS","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.HEM3BS","text":"HEM3BS(; kwargs...)\n\nHEM3BS.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.HEM5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.HEM5","text":"HEM5(; kwargs...)\n\nBrasey and Hairer, 5 stage, 4th order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Classical-Methods","page":"Runge-Kutta methods","title":"Classical Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.GL1\nRKMethods.GL2\nRKMethods.GL3\nRKMethods.RIA1\nRKMethods.RIA2\nRKMethods.RIA3\nRKMethods.RIIA1\nRKMethods.RIIA2\nRKMethods.RIIA3\nRKMethods.LIIIA2\nRKMethods.LIIIA3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.GL1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.GL1","text":"GL1(; kwargs...)\n\nGL1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.GL2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.GL2","text":"GL2(; kwargs...)\n\nGL2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.GL3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.GL3","text":"GL3(; kwargs...)\n\nGL3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIA1","text":"RIA1(; kwargs...)\n\nThis is implicit Euler.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIA2","text":"RIA2(; kwargs...)\n\nRIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIA3","text":"RIA3(; kwargs...)\n\nRIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIIA1","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIIA1","text":"RIIA1(; kwargs...)\n\nRIIA1.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIIA2","text":"RIIA2(; kwargs...)\n\nRIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RIIA3","text":"RIIA3(; kwargs...)\n\nRIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.LIIIA2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.LIIIA2","text":"LIIIA2(; kwargs...)\n\nLIIIA2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.LIIIA3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.LIIIA3","text":"LIIIA3(; kwargs...)\n\nLIIIA3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Chebyshev-methods","page":"Runge-Kutta methods","title":"Chebyshev methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.CHDIRK3\nRKMethods.CHCONS3\nRKMethods.CHC3\nRKMethods.CHC5","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.CHDIRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.CHDIRK3","text":"CHDIRK3(; kwargs...)\n\nChebyshev based DIRK (not algebraically stable).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.CHCONS3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.CHCONS3","text":"CHCONS3(; kwargs...)\n\nCHCONS3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.CHC3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.CHC3","text":"CHC3(; kwargs...)\n\nChebyshev quadrature and C(3) satisfied. Note this equals Lobatto IIIA.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.CHC5","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.CHC5","text":"CHC5(; kwargs...)\n\nCHC5.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#Miscellaneous-Methods","page":"Runge-Kutta methods","title":"Miscellaneous Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.Mid22\nRKMethods.MTE22\nRKMethods.CN22\nRKMethods.Heun33\nRKMethods.RK33C2\nRKMethods.RK33P2\nRKMethods.RK44\nRKMethods.RK44C2\nRKMethods.RK44C23\nRKMethods.RK44P2","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.Mid22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.Mid22","text":"Mid22(; kwargs...)\n\nMidpoint 22 method.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.MTE22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.MTE22","text":"MTE22(; kwargs...)\n\nMinimal truncation error 22 method (Heun).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.CN22","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.CN22","text":"CN22(; kwargs...)\n\nCrank-Nicholson.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.Heun33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.Heun33","text":"Heun33(; kwargs...)\n\nHeun33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK33C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK33C2","text":"RK33C2(; kwargs...)\n\nRK3 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK33P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK33P2","text":"RK33P2(; kwargs...)\n\nRK3 satisfying the second order condition for the pressure.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK44","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK44","text":"RK44(; kwargs...)\n\nClassical fourth order.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK44C2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK44C2","text":"RK44C2(; kwargs...)\n\nRK4 satisfying C(2) for i=3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK44C23","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK44C23","text":"RK44C23(; kwargs...)\n\nRK4 satisfying C(2) for i=3 and c2=c3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.RK44P2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.RK44P2","text":"RK44P2(; kwargs...)\n\nRK4 satisfying the second order condition for the pressure (but not third order).\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#DSRK-Methods","page":"Runge-Kutta methods","title":"DSRK Methods","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.DSso2\nRKMethods.DSRK2\nRKMethods.DSRK3","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.DSso2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.DSso2","text":"DSso2(; kwargs...)\n\nCBM's DSRKso2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.DSRK2","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.DSRK2","text":"DSRK2(; kwargs...)\n\nCBM's DSRK2.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.DSRK3","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.DSRK3","text":"DSRK3(; kwargs...)\n\nZennaro's DSRK3.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#\"Non-SSP\"-Methods-of-Wong-and-Spiteri","page":"Runge-Kutta methods","title":"\"Non-SSP\" Methods of Wong & Spiteri","text":"","category":"section"},{"location":"api/tableaux/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"RKMethods.NSSP21\nRKMethods.NSSP32\nRKMethods.NSSP33\nRKMethods.NSSP53","category":"page"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.NSSP21","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.NSSP21","text":"NSSP21(; kwargs...)\n\nNSSP21.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.NSSP32","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.NSSP32","text":"NSSP32(; kwargs...)\n\nNSSP32.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.NSSP33","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.NSSP33","text":"NSSP33(; kwargs...)\n\nNSSP33.\n\n\n\n\n\n","category":"function"},{"location":"api/tableaux/#IncompressibleNavierStokes.RKMethods.NSSP53","page":"Runge-Kutta methods","title":"IncompressibleNavierStokes.RKMethods.NSSP53","text":"NSSP53(; kwargs...)\n\nNSSP53.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"All discrete operators are built using KernelAbstractions.jl and Cartesian indices, similar to WaterLily.jl. This allows for dimension- and backend-agnostic code. See this blog post for how to write kernels. IncompressibleNavierStokes previously relied on assembling sparse operators to perform the same operations. While being very efficient and also compatible with CUDA (CUSPARSE), storing these matrices in memory is expensive for large 3D problems.","category":"page"},{"location":"features/operators/","page":"Operators","title":"Operators","text":"Offset\navg\ndivergence!\ndivergence\nvorticity\nvorticity!\nconvection!\ndiffusion!\nbodyforce!\nmomentum!\nmomentum\nlaplacian!\nlaplacian\npressuregradient!\npressuregradient\ninterpolate_u_p\ninterpolate_u_p!\ninterpolate_ω_p\ninterpolate_ω_p!\nDfield!\nDfield\nQfield!\nQfield\neig2field!\neig2field\nkinetic_energy\nkinetic_energy!\ntotal_kinetic_energy\ntensorbasis\ndivoftensor!\ntensorbasis!\nget_scale_numbers\ndissipation_from_strain!","category":"page"},{"location":"features/operators/#IncompressibleNavierStokes.Offset","page":"Operators","title":"IncompressibleNavierStokes.Offset","text":"e = Offset{D}()\n\nCartesian index unit vector in D = 2 or D = 3 dimensions. Calling e(α) returns a Cartesian index with 1 in the dimension α and zeros elsewhere.\n\nSee https://b-fg.github.io/2023/05/07/waterlily-on-gpu.html for writing kernel loops using Cartesian indices.\n\n\n\n\n\n","category":"type"},{"location":"features/operators/#IncompressibleNavierStokes.avg","page":"Operators","title":"IncompressibleNavierStokes.avg","text":"Average scalar field ϕ in the α-direction.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.divergence!","page":"Operators","title":"IncompressibleNavierStokes.divergence!","text":"divergence!(div, u, setup)\n\nCompute divergence of velocity field (in-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.divergence","page":"Operators","title":"IncompressibleNavierStokes.divergence","text":"divergence(u, setup)\n\nCompute divergence of velocity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.vorticity","page":"Operators","title":"IncompressibleNavierStokes.vorticity","text":"vorticity(u, setup)\n\nCompute vorticity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.vorticity!","page":"Operators","title":"IncompressibleNavierStokes.vorticity!","text":"vorticity!(ω, u, setup)\n\nCompute vorticity field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.convection!","page":"Operators","title":"IncompressibleNavierStokes.convection!","text":"convection!(F, u, setup)\n\nCompute convective term.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.diffusion!","page":"Operators","title":"IncompressibleNavierStokes.diffusion!","text":"diffusion!(F, u, setup)\n\nCompute diffusive term.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.bodyforce!","page":"Operators","title":"IncompressibleNavierStokes.bodyforce!","text":"bodyforce!(F, u, t, setup)\n\nCompute body force.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.momentum!","page":"Operators","title":"IncompressibleNavierStokes.momentum!","text":"momentum!(F, u, temp, t, setup)\n\nRight hand side of momentum equations, excluding pressure gradient. Put the result in F.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.momentum","page":"Operators","title":"IncompressibleNavierStokes.momentum","text":"momentum(u, temp, t, setup)\n\nRight hand side of momentum equations, excluding pressure gradient.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.laplacian!","page":"Operators","title":"IncompressibleNavierStokes.laplacian!","text":"laplacian!(L, p, setup)\n\nCompute Laplacian of pressure field (in-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.laplacian","page":"Operators","title":"IncompressibleNavierStokes.laplacian","text":"laplacian(p, setup)\n\nCompute Laplacian of pressure field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.pressuregradient!","page":"Operators","title":"IncompressibleNavierStokes.pressuregradient!","text":"pressuregradient!(G, p, setup)\n\nCompute pressure gradient (in-place).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.pressuregradient","page":"Operators","title":"IncompressibleNavierStokes.pressuregradient","text":"pressuregradient(p, setup)\n\nCompute pressure gradient.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_u_p","page":"Operators","title":"IncompressibleNavierStokes.interpolate_u_p","text":"interpolate_u_p(u, setup)\n\nInterpolate velocity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_u_p!","page":"Operators","title":"IncompressibleNavierStokes.interpolate_u_p!","text":"interpolate_u_p!(up, u, setup)\n\nInterpolate velocity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_ω_p","page":"Operators","title":"IncompressibleNavierStokes.interpolate_ω_p","text":"interpolate_ω_p(ω, setup)\n\nInterpolate vorticity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.interpolate_ω_p!","page":"Operators","title":"IncompressibleNavierStokes.interpolate_ω_p!","text":"interpolate_ω_p!(ωp, ω, setup)\n\nInterpolate vorticity to pressure points.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Dfield!","page":"Operators","title":"IncompressibleNavierStokes.Dfield!","text":"Dfield!(d, G, p, setup; ϵ = eps(eltype(p)))\n\nCompute the D-field [9] given by\n\nD = frac2  nabla p nabla^2 p\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Dfield","page":"Operators","title":"IncompressibleNavierStokes.Dfield","text":"Dfield(p, setup; kwargs...)\n\nCompute the D-field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Qfield!","page":"Operators","title":"IncompressibleNavierStokes.Qfield!","text":"Qfield!(Q, u, setup)\n\nCompute Q-field [10] given by\n\nQ = - frac12 sum_α β fracpartial u^αpartial x^β\nfracpartial u^βpartial x^α\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.Qfield","page":"Operators","title":"IncompressibleNavierStokes.Qfield","text":"Qfield(u, setup)\n\nCompute the Q-field.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.eig2field!","page":"Operators","title":"IncompressibleNavierStokes.eig2field!","text":"eig2field!(λ, u, setup; ϵ = eps(eltype(λ)))\n\nCompute the second eigenvalue of S^2 + Omega^2, as proposed by Jeong and Hussain [10].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.eig2field","page":"Operators","title":"IncompressibleNavierStokes.eig2field","text":"eig2field(u, setup)\n\nCompute the second eigenvalue of S^2 + Omega^2, as proposed by Jeong and Hussain [10].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.kinetic_energy","page":"Operators","title":"IncompressibleNavierStokes.kinetic_energy","text":"kinetic_energy(u, setup; kwargs...)\n\nCompute kinetic energy field e (out-of-place version).\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.kinetic_energy!","page":"Operators","title":"IncompressibleNavierStokes.kinetic_energy!","text":"kinetic_energy!(k, u, setup; interpolate_first = false)\n\nCompute kinetic energy field k (in-place version). If interpolate_first is true, it is given by\n\ne_I = frac18 sum_alpha (u^alpha_I + delta(alpha)  2 + u^alpha_I - delta(alpha)  2)^2\n\nOtherwise, it is given by\n\ne_I = frac14 sum_alpha (u^alpha_I + delta(alpha)  2^2 + u^alpha_I - delta(alpha)  2^2)\n\nas in [11].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.total_kinetic_energy","page":"Operators","title":"IncompressibleNavierStokes.total_kinetic_energy","text":"total_kinetic_energy(setup, u; kwargs...)\n\nCompute total kinetic energy. The velocity components are interpolated to the volume centers and squared.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.tensorbasis","page":"Operators","title":"IncompressibleNavierStokes.tensorbasis","text":"tensorbasis(u, setup)\n\nCompute symmetry tensor basis T[1]-T[11] and invariants V[1]-V[5].\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.divoftensor!","page":"Operators","title":"IncompressibleNavierStokes.divoftensor!","text":"divoftensor!(s, σ, setup)\n\nCompute divergence of a tensor with all components in the pressure points. The stress tensors should be precomputed and stored in σ.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.tensorbasis!","page":"Operators","title":"IncompressibleNavierStokes.tensorbasis!","text":"tensorbasis!(B, V, u, setup)\n\nCompute symmetry tensor basis B[1]-B[11] and invariants V[1]-V[5], as specified in [12] in equations (9) and (11). Note that B[1] corresponds to T_0 in the paper, and V to I.\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.get_scale_numbers","page":"Operators","title":"IncompressibleNavierStokes.get_scale_numbers","text":"get_scale_numbers(u, setup)\n\nGet the following dimensional scale numbers [13]:\n\nVelocity u_textavg = langle u_i u_i rangle^12\nDissipation rate epsilon = 2 nu langle S_ij S_ij rangle\nKolmolgorov length scale eta = (fracnu^3epsilon)^14\nTaylor length scale lambda = (frac5 nuepsilon)^12 u_textavg\nTaylor-scale Reynolds number Re_lambda = fraclambda u_textavgsqrt3 nu\nIntegral length scale L = frac3 pi2 u_textavg^2 int_0^infty fracE(k)k  mathrmd k\nLarge-eddy turnover time tau = fracLu_textavg\n\n\n\n\n\n","category":"function"},{"location":"features/operators/#IncompressibleNavierStokes.dissipation_from_strain!","page":"Operators","title":"IncompressibleNavierStokes.dissipation_from_strain!","text":"dissipation_from_strain!(ϵ, u, setup)\n\nCompute dissipation term 2 nu langle S_i j S_i j rangle from strain-rate tensor.\n\n\n\n\n\n","category":"function"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/bc/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"Each boundary has exactly one type of boundary conditions. For periodic boundary conditions, the opposite boundary must also be periodic. The available boundary conditions are given below.","category":"page"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"PeriodicBC\nDirichletBC\nSymmetricBC\nPressureBC","category":"page"},{"location":"features/bc/#IncompressibleNavierStokes.PeriodicBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.PeriodicBC","text":"PeriodicBC()\n\nPeriodic boundary conditions. Must be periodic on both sides.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.DirichletBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.DirichletBC","text":"DirichletBC()\n\nNo slip boundary conditions, where all velocity components are zero.\n\nDirichletBC(u, dudt)\n\nDirichlet boundary conditions for the velocity, where u[1] = (x..., t) -> u1_BC up to u[d] = (x..., t) -> ud_BC, where d is the dimension.\n\nTo make the pressure the same order as velocity, also provide dudt.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.SymmetricBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.SymmetricBC","text":"SymmetricBC()\n\nSymmetric boundary conditions. The parallel velocity and pressure is the same at each side of the boundary. The normal velocity is zero.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/#IncompressibleNavierStokes.PressureBC","page":"Boundary conditions","title":"IncompressibleNavierStokes.PressureBC","text":"PressureBC()\n\nPressure boundary conditions. The pressure is prescribed on the boundary (usually an \"outlet\"). The velocity has zero Neumann conditions.\n\nNote: Currently, the pressure is prescribed with the constant value of zero on the entire boundary.\n\n\n\n\n\n","category":"type"},{"location":"features/bc/","page":"Boundary conditions","title":"Boundary conditions","text":"offset_p\noffset_u","category":"page"},{"location":"features/bc/#IncompressibleNavierStokes.offset_p","page":"Boundary conditions","title":"IncompressibleNavierStokes.offset_p","text":"offset_p(bc)\n\nNumber of non-DOF pressure components at boundary.\n\n\n\n\n\n","category":"function"},{"location":"features/bc/#IncompressibleNavierStokes.offset_u","page":"Boundary conditions","title":"IncompressibleNavierStokes.offset_u","text":"offset_u(bc, isnormal, isright)\n\nNumber of non-DOF velocity components at boundary. If isnormal, then the velocity is normal to the boundary, else parallel. If isright, it is at the end/right/rear/top boundary, otherwise beginning.\n\n\n\n\n\n","category":"function"},{"location":"equations/ns/#Incompressible-Navier-Stokes-equations","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The incompressible Navier-Stokes equations describe conservation of mass and conservation of momentum, which can be written as a divergence-free constraint and an evolution equation:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginaligned\n    nabla cdot u  = 0 \n    fracpartial upartial t + nabla cdot (u u^mathsfT)\n     = -nabla p + nu nabla^2 u + f\nendaligned","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where Omega subset mathbbR^d is the domain, d in 2 3 is the spatial dimension, u = (u^1 dots u^d) is the velocity field, p is the pressure, nu is the kinematic viscosity, and f = (f^1 dots f^d) is the body force per unit of volume. The velocity, pressure, and body force are functions of the spatial coordinate x = (x^1 dots x^d) and time t. We assume that Omega is a rectangular domain.","category":"page"},{"location":"equations/ns/#Integral-form","page":"Incompressible Navier-Stokes equations","title":"Integral form","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The integral form of the Navier-Stokes equations is used as starting point to develop a spatial discretization:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"beginaligned\n    frac1mathcalO int_partial mathcalO\n    u cdot n  mathrmd Gamma  = 0 \n    fracmathrmd mathrmd t frac1mathcalO\n    int_mathcalO u  mathrmd Omega\n     = frac1mathcalO int_partial mathcalO\n    left( - u u^mathsfT - p I + nu nabla u right) cdot n \n    mathrmd Gamma +\n    frac1mathcalOint_mathcalO f mathrmd Omega\nendaligned","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"where mathcalO subset Omega is an arbitrary control volume with boundary partial mathcalO, normal n, surface element mathrmd Gamma, and volume size mathcalO. We have divided by the control volume sizes in the integral form.","category":"page"},{"location":"equations/ns/#Boundary-conditions","page":"Incompressible Navier-Stokes equations","title":"Boundary conditions","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The boundary conditions on a part of the boundary Gamma subset partial Omega are one or more of the following:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Dirichlet: u = u_textBC on Gamma for some u_textBC;\nNeumann: nabla u cdot n = 0 on Gamma;\nPeriodic: u(x) = u(x + tau) and p(x) = p(x + tau)   for x in Gamma, where   Gamma + tau subset partial Omega   is another part of the boundary and   tau is a translation vector;\nStress free: sigma cdot n = 0 on Gamma,   where sigma = left(- p mathrmI + 2 nu S right).","category":"page"},{"location":"equations/ns/#Pressure-equation","page":"Incompressible Navier-Stokes equations","title":"Pressure equation","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Taking the divergence of the momemtum equations yields a Poisson equation for the pressure:","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- nabla^2 p = nabla cdot left( nabla cdot (u u^mathsfT) right) -\nnabla cdot f","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In scalar notation, this becomes","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"- sum_alpha = 1^d fracpartial^2partial x^alpha partial x^alpha p = sum_alpha\n= 1^d sum_beta = 1^d fracpartial^2 partial x^alpha partial\nx^beta (u^alpha u^beta) - sum_alpha = 1^d fracpartial\nf^alphapartial x^alpha","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note the absence of time derivatives in the pressure equation. While the velocity field evolves in time, the pressure only changes such that the velocity stays divergence free.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"If there are no pressure boundary conditions, the pressure is only unique up to a constant. We set this constant to 1.","category":"page"},{"location":"equations/ns/#Other-quantities-of-interest","page":"Incompressible Navier-Stokes equations","title":"Other quantities of interest","text":"","category":"section"},{"location":"equations/ns/#Reynolds-number","page":"Incompressible Navier-Stokes equations","title":"Reynolds number","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The Reynolds number is the inverse of the viscosity: Re = frac1nu. It is the only flow parameter governing the incompressible Navier-Stokes equations.","category":"page"},{"location":"equations/ns/#Kinetic-energy","page":"Incompressible Navier-Stokes equations","title":"Kinetic energy","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The local and total kinetic energy are defined by k = frac12  u _2^2 and K = frac12  u _L^2(Omega)^2 = int_Omega k  mathrmd Omega.","category":"page"},{"location":"equations/ns/#Vorticity","page":"Incompressible Navier-Stokes equations","title":"Vorticity","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"The vorticity is defined as omega = nabla times u.","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 2D, it is a scalar field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = -fracpartial u^1partial x^2 + fracpartial u^2partial\nx^1","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 3D, it is a vector field given by","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"omega = beginpmatrix\n    - fracpartial u^2partial x^3 + fracpartial u^3partial x^2 \n    - fracpartial u^3partial x^1 + fracpartial u^1partial x^3  \n    - fracpartial u^1partial x^2 + fracpartial u^2partial x^1\nendpmatrix","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"Note that the 2D vorticity is equal to the x^3-component of the 3D vorticity.","category":"page"},{"location":"equations/ns/#Stream-function","page":"Incompressible Navier-Stokes equations","title":"Stream function","text":"","category":"section"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 2D, the stream function psi is a scalar field such that","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"u^1 = fracpartial psipartial x^2 quad\nu^2 = -fracpartial psipartial x^1","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"It can be found by solving","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"nabla^2 psi = - omega","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"In 3D, the stream function is a vector field such that","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"u = nabla times psi","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"It can be found by solving","category":"page"},{"location":"equations/ns/","page":"Incompressible Navier-Stokes equations","title":"Incompressible Navier-Stokes equations","text":"nabla^2 psi = nabla times omega","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"EditURL = \"../../../examples/TaylorGreenVortex2D.jl\"","category":"page"},{"location":"generated/TaylorGreenVortex2D/#Convergence-study:-Taylor-Green-vortex-(2D)","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence study: Taylor-Green vortex (2D)","text":"","category":"section"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"In this example we consider the Taylor-Green vortex. In 2D, it has an analytical solution, given by","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"beginsplit\n    u^1(x y t)  = - sin(x) cos(y) mathrme^-2 t  Re \n    u^2(x y t)  = + cos(x) sin(y) mathrme^-2 t  Re\nendsplit","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"This allows us to test the convergence of our solver.","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes\nusing LinearAlgebra\n\n\"\"\"\nCompare numerical solution with analytical solution at final time.\n\"\"\"\nfunction compute_convergence(; D, nlist, lims, Re, tlims, Δt, uref, ArrayType = Array)\n    T = typeof(lims[1])\n    e = zeros(T, length(nlist))\n    for (i, n) in enumerate(nlist)\n        @info \"Computing error for n = $n\"\n        x = ntuple(α -> LinRange(lims..., n + 1), D)\n        setup = Setup(x...; Re, ArrayType)\n        psolver = psolver_spectral(setup)\n        ustart = create_initial_conditions(\n            setup,\n            (dim, x...) -> uref(dim, x..., tlims[1]),\n            tlims[1];\n            psolver,\n        )\n        ut = create_initial_conditions(\n            setup,\n            (dim, x...) -> uref(dim, x..., tlims[2]),\n            tlims[2];\n            psolver,\n            doproject = false,\n        )\n        (; u, t), outputs = solve_unsteady(; setup, ustart, tlims, Δt, psolver)\n        (; Ip) = setup.grid\n        a, b = T(0), T(0)\n        for α = 1:D\n            a += sum(abs2, u[α][Ip] - ut[α][Ip])\n            b += sum(abs2, ut[α][Ip])\n        end\n        e[i] = sqrt(a) / sqrt(b)\n    end\n    e\nend","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Analytical solution for 2D Taylor-Green vortex","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"solution(Re) =\n    (dim, x, y, t) -> (dim() == 1 ? -sin(x) * cos(y) : cos(x) * sin(y)) * exp(-2t / Re)","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Compute error for different resolutions","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Re = 2.0e3\nnlist = [2, 4, 8, 16, 32, 64, 128, 256]\ne = compute_convergence(;\n    D = 2,\n    nlist,\n    lims = (0.0, 2π),\n    Re,\n    tlims = (0.0, 2.0),\n    Δt = 0.01,\n    uref = solution(Re),\n)","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"Plot convergence","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"fig = Figure()\nax = Axis(\n    fig[1, 1];\n    xscale = log10,\n    yscale = log10,\n    xticks = nlist,\n    xlabel = \"n\",\n    title = \"Relative error\",\n)\nscatterlines!(ax, nlist, e; label = \"Data\")\nlines!(ax, collect(extrema(nlist)), n -> n^-2.0; linestyle = :dash, label = \"n^-2\")\naxislegend(ax)\nfig","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"","category":"page"},{"location":"generated/TaylorGreenVortex2D/","page":"Convergence: Taylor-Green Vortex (2D)","title":"Convergence: Taylor-Green Vortex (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"EditURL = \"../../../examples/RayleighBenard2D.jl\"","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Hardware","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"ArrayType = Array\n\n# using CUDA, CUDSS\n# ArrayType = CuArray","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Define observer function to track Nusselt numbers on top and bottom plates.","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"function nusseltplot(state; setup)\n    state isa Observable || (state = Observable(state))\n    (; Δ, Δu) = setup.grid\n    T = eltype(Δ[1])\n    Δy1 = Δu[2][1:1] |> sum\n    Δy2 = Δu[2][end-1:end-1] |> sum\n    _Nu1 = Point2f[]\n    Nu1 = lift(state) do (; temp, t)\n        dTdy = @. (temp[:, 2] - temp[:, 1]) / Δy1\n        Nu = sum((.-dTdy.*Δ[1])[2:end-1])\n        push!(_Nu1, Point2f(t, Nu))\n    end\n    _Nu2 = Point2f[]\n    Nu2 = lift(state) do (; temp, t)\n        dTdy = @. (temp[:, end-1] - temp[:, end-2]) / Δy2\n        Nu = sum((.-dTdy.*Δ[1])[2:end-1])\n        push!(_Nu2, Point2f(t, Nu))\n    end\n    fig = Figure()\n    ax = Axis(fig[1, 1]; title = \"Nusselt number\", xlabel = \"t\", ylabel = \"Nu\")\n    lines!(ax, Nu1; label = \"Lower plate\")\n    lines!(ax, Nu2; label = \"Upper plate\")\n    axislegend(ax)\n    on(_ -> autolimits!(ax), Nu2)\n    fig\nend","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Define observer function to track average temperature.","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"function averagetemp(state; setup)\n    state isa Observable || (state = Observable(state))\n    (; x, Δ, Ip, Δu) = setup.grid\n    T = eltype(Δ[1])\n    ix = Ip.indices[1]\n    Ty = lift(state) do (; temp, t)\n        Ty = sum(temp[ix, :] .* Δ[1][ix]; dims = 1) ./ sum(Δ[1][ix])\n        Array(Ty)[:]\n    end\n    Ty0 = copy(Ty[])\n    yy = Array(xp[2])\n    fig = Figure()\n    ax = Axis(fig[1, 1]; title = \"Average temperature\", xlabel = \"T\", ylabel = \"y\")\n    lines!(ax, Ty0, yy; label = \"t = 0\")\n    lines!(ax, Ty, yy; label = \"t = t\")\n    axislegend(ax)\n    on(_ -> autolimits!(ax), Ty)\n    fig\nend","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Instabilities should depend on the floating point precisision. Try both Float32 and Float64.","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"T = Float32","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Temperature equation setup.","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"temperature = temperature_equation(;\n    Pr = T(0.71),\n    Ra = T(1e7),\n    Ge = T(1.0),\n    dodissipation = true,\n    boundary_conditions = (\n        (SymmetricBC(), SymmetricBC()),\n        (DirichletBC(T(1)), DirichletBC(T(0))),\n    ),\n    gdir = 2,\n    nondim_type = 1,\n)","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Grid","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"n = 50\nx = tanh_grid(T(0), T(2), 2n, T(1.2))\ny = tanh_grid(T(0), T(1), n, T(1.2))\nplotgrid(x, y)","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Setup","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"setup = Setup(\n    x,\n    y;\n    boundary_conditions = ((DirichletBC(), DirichletBC()), (DirichletBC(), DirichletBC())),\n    Re = 1 / temperature.α1,\n    temperature,\n    ArrayType,\n);\nnothing #hide","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Initial conditions","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"ustart = create_initial_conditions(setup, (dim, x, y) -> zero(x));\n(; xp) = setup.grid;\n# T0(x, y) = 1 - y;\n# T0(x, y) = one(y) / 2;\nT0(x, y) = one(y) / 2 + max(sinpi(20 * x) / 100, 0); ## Perturbation\n# T0(x, y) = 1 - y + max(sinpi(20 * x) / 1000, 0); ## Perturbation\ntempstart = T0.(xp[1], xp[2]');\nnothing #hide","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Solve equation","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"state, outputs = solve_unsteady(;\n    setup,\n    ustart,\n    tempstart,\n    tlims = (T(0), T(12)),\n    Δt = T(1e-2),\n    processors = (;\n        rtp = realtimeplotter(;\n            setup,\n            fieldname = :temperature,\n            colorrange = (T(0), T(1)),\n            size = (600, 350),\n            colormap = :seaborn_icefire_gradient,\n            nupdate = 50,\n        ),\n        nusselt = realtimeplotter(;\n            setup,\n            plot = nusseltplot,\n            nupdate = 20,\n        ),\n        avg = realtimeplotter(;\n            setup,\n            plot = averagetemp,\n            nupdate = 50,\n        ),\n        log = timelogger(; nupdate = 100),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Field","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"outputs.rtp","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Nusselt numbers","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"outputs.nusselt","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"Average temperature","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"outputs.avg","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"","category":"page"},{"location":"generated/RayleighBenard2D/","page":"Temperature: Rayleigh-Bénard (2D)","title":"Temperature: Rayleigh-Bénard (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/pressure/#Pressure-solvers","page":"Pressure solvers","title":"Pressure solvers","text":"","category":"section"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"The discrete pressure Poisson equation","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"L p = W M F(u)","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"enforces divergence freeness. There are multiple options for solving this system.","category":"page"},{"location":"features/pressure/","page":"Pressure solvers","title":"Pressure solvers","text":"default_psolver\npsolver_direct\npsolver_cg\npsolver_cg_matrix\npsolver_spectral\npsolver_spectral_lowmemory\npressure\npressure!\npoisson\npoisson!\napplypressure!\nproject\nproject!","category":"page"},{"location":"features/pressure/#IncompressibleNavierStokes.default_psolver","page":"Pressure solvers","title":"IncompressibleNavierStokes.default_psolver","text":"default_psolver(setup)\n\nGet default Poisson solver from setup.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.psolver_direct","page":"Pressure solvers","title":"IncompressibleNavierStokes.psolver_direct","text":"poisson_direct(setup)\n\nCreate direct Poisson solver using an appropriate matrix decomposition.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.psolver_cg","page":"Pressure solvers","title":"IncompressibleNavierStokes.psolver_cg","text":"psolver_cg(\n    setup;\n    abstol = zero(eltype(setup.grid.x[1])),\n    reltol = sqrt(eps(eltype(setup.grid.x[1]))),\n    maxiter = prod(setup.grid.Np),\n    preconditioner = create_laplace_diag(setup),\n)\n\nConjugate gradients iterative Poisson solver.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.psolver_cg_matrix","page":"Pressure solvers","title":"IncompressibleNavierStokes.psolver_cg_matrix","text":"psolver_cg_matrix(setup; kwargs...)\n\nConjugate gradients iterative Poisson solver. The kwargs are passed to the cg! function from IterativeSolvers.jl.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.psolver_spectral","page":"Pressure solvers","title":"IncompressibleNavierStokes.psolver_spectral","text":"psolver_spectral(setup)\n\nCreate spectral Poisson solver from setup.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.psolver_spectral_lowmemory","page":"Pressure solvers","title":"IncompressibleNavierStokes.psolver_spectral_lowmemory","text":"psolver_spectral_lowmemory(setup)\n\nCreate spectral Poisson solver from setup. This one is slower than psolver_spectral but occupies less memory.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.pressure","page":"Pressure solvers","title":"IncompressibleNavierStokes.pressure","text":"pressure(u, temp, t, setup; psolver)\n\nCompute pressure from velocity field. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.pressure!","page":"Pressure solvers","title":"IncompressibleNavierStokes.pressure!","text":"pressure!(p, u, temp, t, setup; psolver, F, div)\n\nCompute pressure from velocity field. This makes the pressure compatible with the velocity field, resulting in same order pressure as velocity.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.poisson","page":"Pressure solvers","title":"IncompressibleNavierStokes.poisson","text":"poisson(psolver, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nNon-mutating/allocating/out-of-place version.\n\nSee also poisson!.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.poisson!","page":"Pressure solvers","title":"IncompressibleNavierStokes.poisson!","text":"poisson!(solver, p, f)\n\nSolve the Poisson equation for the pressure with right hand side f at time t. For periodic and no-slip BC, the sum of f should be zero.\n\nMutating/non-allocating/in-place version.\n\nSee also poisson.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.applypressure!","page":"Pressure solvers","title":"IncompressibleNavierStokes.applypressure!","text":"applypressure!(u, p, setup)\n\nSubtract pressure gradient (in-place).\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.project","page":"Pressure solvers","title":"IncompressibleNavierStokes.project","text":"project(u, setup; psolver)\n\nProject velocity field onto divergence-free space.\n\n\n\n\n\n","category":"function"},{"location":"features/pressure/#IncompressibleNavierStokes.project!","page":"Pressure solvers","title":"IncompressibleNavierStokes.project!","text":"project!(u, setup; psolver, div, p)\n\nProject velocity field onto divergence-free space.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install IncompressibleNavierStokes, open up a Julia-REPL, type ] to get into Pkg-mode, and type:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"add IncompressibleNavierStokes","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install the package and all dependencies to your local environment. Note that IncompressibleNavierStokes requires Julia version 1.9 or above.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"EditURL = \"../../../examples/Actuator2D.jl\"","category":"page"},{"location":"generated/Actuator2D/#Unsteady-actuator-case-2D","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady actuator case - 2D","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"In this example, an unsteady inlet velocity profile at encounters a wind turbine blade in a wall-less domain. The blade is modeled as a uniform body force on a thin rectangle.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We start by loading packages. A Makie plotting backend is needed for plotting. GLMakie creates an interactive window (useful for real-time plotting), but does not work when building this example on GitHub. CairoMakie makes high-quality static vector-graphics plots.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"using CairoMakie\nusing IncompressibleNavierStokes","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Output directory","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"output = \"output/Actuator2D\"","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"A 2D grid is a Cartesian product of two vectors","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"n = 40\nx = LinRange(0.0, 10.0, 5n + 1)\ny = LinRange(-2.0, 2.0, 2n + 1)\nplotgrid(x, y)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Boundary conditions","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"boundary_conditions = (\n    # x left, x right\n    (\n        # Unsteady BC requires time derivatives\n        DirichletBC(\n            (dim, x, y, t) -> sin(π / 6 * sin(π / 6 * t) + π / 2 * (dim() == 1)),\n            (dim, x, y, t) ->\n                (π / 6)^2 *\n                cos(π / 6 * t) *\n                cos(π / 6 * sin(π / 6 * t) + π / 2 * (dim() == 1)),\n        ),\n        PressureBC(),\n    ),\n\n    # y rear, y front\n    (PressureBC(), PressureBC()),\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Actuator body force: A thrust coefficient Cₜ distributed over a thin rectangle","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"xc, yc = 2.0, 0.0 # Disk center\nD = 1.0           # Disk diameter\nδ = 0.11          # Disk thickness\nCₜ = 0.2          # Thrust coefficient\ncₜ = Cₜ / (D * δ)\ninside(x, y) = abs(x - xc) ≤ δ / 2 && abs(y - yc) ≤ D / 2\nbodyforce(dim, x, y, t) = dim() == 1 ? -cₜ * inside(x, y) : 0.0","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Build setup and assemble operators","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"setup = Setup(x, y; Re = 100.0, boundary_conditions, bodyforce);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Initial conditions (extend inflow)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"ustart = create_initial_conditions(setup, (dim, x, y) -> dim() == 1 ? 1.0 : 0.0);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Solve unsteady problem","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"state, outputs = solve_unsteady(;\n    setup,\n    ustart,\n    tlims = (0.0, 12.0),\n    method = RKMethods.RK44P2(),\n    Δt = 0.05,\n    processors = (\n        rtp = realtimeplotter(; setup, plot = fieldplot, nupdate = 1),\n        # ehist = realtimeplotter(; setup, plot = energy_history_plot, nupdate = 1),\n        # espec = realtimeplotter(; setup, plot = energy_spectrum_plot, nupdate = 1),\n        # anim = animator(; setup, path = \"$output/vorticity.mkv\", nupdate = 20),\n        # vtk = vtk_writer(; setup, nupdate = 10, dir = \"$output\", filename = \"solution\"),\n        # field = fieldsaver(; setup, nupdate = 10),\n        log = timelogger(; nupdate = 1),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/Actuator2D/#Post-process","page":"Unsteady inflow: Actuator (2D)","title":"Post-process","text":"","category":"section"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We may visualize or export the computed fields (u, p).","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Export to VTK","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"save_vtk(setup, state.u, state.t, \"$output/solution\")","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"We create a box to visualize the actuator.","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"box = (\n    [xc - δ / 2, xc - δ / 2, xc + δ / 2, xc + δ / 2, xc - δ / 2],\n    [yc + D / 2, yc - D / 2, yc - D / 2, yc + D / 2, yc + D / 2],\n)","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot pressure","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :pressure)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot velocity","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :velocitynorm)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"Plot vorticity","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"fig = fieldplot(state; setup, fieldname = :vorticity)\nlines!(box...; color = :red)\nfig","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"","category":"page"},{"location":"generated/Actuator2D/","page":"Unsteady inflow: Actuator (2D)","title":"Unsteady inflow: Actuator (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"features/les/#Large-eddy-simulation","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Depending on the problem specification, a given grid resolution may not be sufficient to resolve all spatial features of the flow. Consider the following example:","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"(Image: Resolution)","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the left, the grid spacing is too large to capt the smallest eddies in the flow. These eddies create sub-grid stresses that also affect the large scale features. The grid must be refined if we want to compute these stresses exactly.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"On the right, the smallest spatial feature of the flow is fully resolved, and there are no sub-grid stresses. The equations can be solved without worrying about errors from unresolved features. This is known as Direct Numerical Simulation (DNS).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"If refining the grid is too costly, a closure model can be used to predict the sub-grid stresses. The models only give an estimate for these stresses, and may need to be calibrated to the given problem. When used correctly, they can predict the evolution of the large fluid motions without computing the sub-grid motions themselves. This is known as Large Eddy Simulation (LES).","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Eddy viscosity models add a local contribution to the global baseline viscosity. The baseline viscosity models transfer of energy from resolved to atomic scales. The new turbulent viscosity on the other hand, models energy transfer from resolved to unresolved scales. This non-constant field is computed from the local velocity field.","category":"page"},{"location":"features/les/","page":"Large eddy simulation","title":"Large eddy simulation","text":"smagtensor!\nsmagorinsky_closure","category":"page"},{"location":"features/les/#IncompressibleNavierStokes.smagtensor!","page":"Large eddy simulation","title":"IncompressibleNavierStokes.smagtensor!","text":"smagtensor!(σ, u, θ, setup)\n\nCompute Smagorinsky stress tensors σ[I]. The Smagorinsky constant θ should be a scalar between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"features/les/#IncompressibleNavierStokes.smagorinsky_closure","page":"Large eddy simulation","title":"IncompressibleNavierStokes.smagorinsky_closure","text":"m = smagorinsky_closure(setup)\n\nCreate Smagorinsky closure model m. The model is called as m(u, θ), where the Smagorinsky constant θ should be a scalar between 0 and 1 (for example θ = 0.1).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#IncompressibleNavierStokes","page":"Home","title":"IncompressibleNavierStokes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IncompressibleNavierStokes is a package providing energy-conserving solvers for the incompressible Navier-Stokes equations on a staggered Cartesian grid. It is based on the Matlab package INS2D/INS3D.","category":"page"},{"location":"api/api/","page":"API","title":"API","text":"CurrentModule = IncompressibleNavierStokes","category":"page"},{"location":"api/api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"IncompressibleNavierStokes\nSetup","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.IncompressibleNavierStokes","page":"API","title":"IncompressibleNavierStokes.IncompressibleNavierStokes","text":"IncompressibleNavierStokes\n\nEnergy-conserving solvers for the incompressible Navier-Stokes equations.\n\n\n\n\n\n","category":"module"},{"location":"api/api/#IncompressibleNavierStokes.Setup","page":"API","title":"IncompressibleNavierStokes.Setup","text":"Setup(\n    x...;\n    boundary_conditions = ntuple(d -> (PeriodicBC(), PeriodicBC()), length(x)),\n    Re = convert(eltype(x[1]), 1_000),\n    bodyforce = nothing,\n    issteadybodyforce = true,\n    closure_model = nothing,\n    ArrayType = Array,\n    workgroupsize = 64,\n    temperature = nothing,\n)\n\nCreate setup.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Grid","page":"API","title":"Grid","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Dimension\nGrid\nmax_size\ncosine_grid\nstretched_grid\ntanh_grid","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.Dimension","page":"API","title":"IncompressibleNavierStokes.Dimension","text":"Dimension(N)\n\nRepresent an N-dimensional space. Returns N when called.\n\njulia> d = Dimension(3)\nDimension{3}()\n\njulia> d()\n3\n\n\n\n\n\n","category":"type"},{"location":"api/api/#IncompressibleNavierStokes.Grid","page":"API","title":"IncompressibleNavierStokes.Grid","text":"Grid(x, boundary_conditions)\n\nCreate nonuniform Cartesian box mesh x[1] × ... × x[d] with boundary conditions boundary_conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.max_size","page":"API","title":"IncompressibleNavierStokes.max_size","text":"max_size(grid)\n\nGet size of the largest grid element.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.cosine_grid","page":"API","title":"IncompressibleNavierStokes.cosine_grid","text":"cosine_grid(a, b, N)\n\nCreate a nonuniform grid of N + 1 points from a to b using a cosine profile, i.e.\n\nx_i = a + frac12 left( 1 - cos left( pi fracin right) right)\n(b - a) quad i = 0 dots N\n\nSee also stretched_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.stretched_grid","page":"API","title":"IncompressibleNavierStokes.stretched_grid","text":"stretched_grid(a, b, N, s = 1)\n\nCreate a nonuniform grid of N + 1 points from a to b with a stretch factor of s. If s = 1, return a uniform spacing from a to b. Otherwise, return a vector x in mathbbR^N + 1 such that x_n = a + sum_i = 1^n s^i - 1 h for n = 0 dots  N. Setting x_N = b then gives h = (b - a) frac1 - s1 - s^N, resulting in\n\nx_n = a + (b - a) frac1 - s^n1 - s^N quad n = 0 dots N\n\nNote that stretched_grid(a, b, N, s)[n] corresponds to x_n - 1.\n\nSee also cosine_grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.tanh_grid","page":"API","title":"IncompressibleNavierStokes.tanh_grid","text":"tanh_grid(a, b, N, γ = typeof(a)(1))\n\nCreate a nonuniform grid of N + 1 points from a to b, as proposed by Trias et al. [14].\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Preprocess","page":"API","title":"Preprocess","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"create_initial_conditions\nrandom_field","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.create_initial_conditions","page":"API","title":"IncompressibleNavierStokes.create_initial_conditions","text":"create_initial_conditions(\n    setup,\n    initial_velocity,\n    t = 0;\n    psolver = default_psolver(setup),\n    doproject = true,\n)\n\nCreate divergence free initial velocity field u at starting time t. The initial conditions of u[α] are specified by the function initial_velocity(Dimension(α), x...).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.random_field","page":"API","title":"IncompressibleNavierStokes.random_field","text":"random_field(\n    setup, t = 0;\n    A = 1,\n    kp = 10,\n    psolver = default_psolver(setup),\n    rng = Random.default_rng(),\n)\n\nCreate random field, as in [15].\n\nK: Maximum wavenumber\nA: Eddy amplitude scaling\nkp: Peak energy wavenumber\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Processors","page":"API","title":"Processors","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"processor\ntimelogger\nobservefield\nvtk_writer\nfieldsaver\nrealtimeplotter\nfieldplot\nenergy_history_plot\nenergy_spectrum_plot\nanimator","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.processor","page":"API","title":"IncompressibleNavierStokes.processor","text":"processor(initialize, finalize = (initialized, state) -> initialized)\n\nProcess results from time stepping. Before time stepping, the initialize function is called on an observable of the time stepper state, returning initialized. The observable is updated every time step.\n\nAfter timestepping, the finalize function is called on initialized and the final state.\n\nSee the following example:\n\nfunction initialize(state)\n    s = 0\n    println(\"Let's sum up the time steps\")\n    on(state) do (; n, t)\n        println(\"The summand is $n, the time is $t\")\n        s = s + n\n    end\n    s\nend\n\nfinalize(i, state) = println(\"The final sum (at time t=$(state.t)) is $s\")\np = processor(initialize, finalize)\n\nWhen solved for 6 time steps from t=0 to t=2 the displayed output is\n\nLet's sum up the time steps\nThe summand is 0, the time is 0.0\nThe summand is 1, the time is 0.4\nThe summand is 2, the time is 0.8\nThe summand is 3, the time is 1.2\nThe summand is 4, the time is 1.6\nThe summand is 5, the time is 2.0\nThe final sum (at time t=2.0) is 15\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.timelogger","page":"API","title":"IncompressibleNavierStokes.timelogger","text":"timelogger(; showmax = true, nupdate = 1)\n\nCreate processor that logs time step information.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.observefield","page":"API","title":"IncompressibleNavierStokes.observefield","text":"observefield(\n    state;\n    setup,\n    fieldname,\n    logtol = eps(eltype(setup.grid.x[1])),\n    psolver = nothing,\n)\n\nObserve field fieldname at pressure points.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.vtk_writer","page":"API","title":"IncompressibleNavierStokes.vtk_writer","text":"vtk_writer(;\n    setup,\n    nupdate = 1,\n    dir = \"output\",\n    filename = \"solution\",\n    fields = (:velocity,),\n)\n\nCreate processor that writes the solution every nupdate time steps to a VTK file. The resulting Paraview data collection file is stored in \"$dir/$filename.pvd\".\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.fieldsaver","page":"API","title":"IncompressibleNavierStokes.fieldsaver","text":"fieldsaver(; setup, nupdate = 1)\n\nCreate processor that stores the solution and time every nupdate time step.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.realtimeplotter","page":"API","title":"IncompressibleNavierStokes.realtimeplotter","text":"realtimeplotter(;\n    setup,\n    plot = fieldplot,\n    nupdate = 1,\n    displayfig = true,\n    screen = nothing,\n    displayupdates = false,\n    sleeptime = nothing,\n    kwargs...,\n)\n\nProcessor for plotting the solution in real time.\n\nKeyword arguments:\n\nplot: Plot function.\nnupdate: Show solution every nupdate time step.\ndisplayfig: Display the figure at the start.\nscreen: If nothing, use default display.   If GLMakie.screen() multiple plots can be displayed in separate   windows like in MATLAB (see also GLMakie.closeall()).\ndisplayupdates: Display the figure at every update (if using CairoMakie).\nsleeptime: The sleeptime is slept at every update, to give Makie   time to update the plot. Set this to nothing to skip sleeping.\n\nAdditional kwargs are passed to the plot function.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.fieldplot","page":"API","title":"IncompressibleNavierStokes.fieldplot","text":"fieldplot(\n    state;\n    setup,\n    fieldname = :vorticity,\n    type = nothing,\n    kwargs...,\n)\n\nPlot state field in pressure points. If state is Observable, then the plot is interactive.\n\nAvailable fieldnames are:\n\n:velocity,\n:vorticity,\n:streamfunction,\n:pressure.\n\nAvailable plot types for 2D are:\n\nheatmap (default),\nimage,\ncontour,\ncontourf.\n\nAvailable plot types for 3D are:\n\ncontour (default).\n\nThe alpha value gets passed to contour in 3D.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_history_plot","page":"API","title":"IncompressibleNavierStokes.energy_history_plot","text":"energy_history_plot(state; setup)\n\nCreate energy history plot.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.energy_spectrum_plot","page":"API","title":"IncompressibleNavierStokes.energy_spectrum_plot","text":"energy_spectrum_plot(state; setup)\n\nCreate energy spectrum plot. The energy at a scalar wavenumber level kappa in mathbbN is defined by\n\nhate(kappa) = int_kappa leq  k _2  kappa + 1  hate(k)  mathrmd k\n\nas in San and Staples [16].\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.animator","page":"API","title":"IncompressibleNavierStokes.animator","text":"animator(; setup, path, plot = fieldplot, nupdate = 1, kwargs...)\n\nAnimate a plot of the solution every update iteration. The animation is saved to path, which should have one of the following extensions:\n\n\".mkv\"\n\".mp4\"\n\".webm\"\n\".gif\"\n\nThe plot is determined by a plotter processor. Additional kwargs are passed to plot.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Solvers","page":"API","title":"Solvers","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_cfl_timestep!\nsolve_unsteady\nsolve_steady_state","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.get_cfl_timestep!","page":"API","title":"IncompressibleNavierStokes.get_cfl_timestep!","text":"get_cfl_timestep!(buf, u, setup)\n\nGet proposed maximum time step for convection and diffusion terms.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_unsteady","page":"API","title":"IncompressibleNavierStokes.solve_unsteady","text":"solve_unsteady(;\n    setup,\n    tlims,\n    ustart,\n    tempstart = nothing,\n    method = RKMethods.RK44(; T = eltype(u₀[1])),\n    psolver = default_psolver(setup),\n    Δt = nothing,\n    cfl = eltype(ustart[1])(0.9),\n    n_adapt_Δt = 1,\n    docopy = true,\n    processors = (;),\n)\n\nSolve unsteady problem using method.\n\nIf Δt is a real number, it is rounded such that (t_end - t_start) / Δt is an integer. If Δt = nothing, the time step is chosen every n_adapt_Δt iteration with CFL-number cfl .\n\nThe processors are called after every time step.\n\nNote that the state observable passed to the processor.initialize function contains vector living on the device, and you may have to move them back to the host using Array(u) in the processor.\n\nReturn (; u, t), outputs, where outputs is a  named tuple with the outputs of processors with the same field names.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.solve_steady_state","page":"API","title":"IncompressibleNavierStokes.solve_steady_state","text":"function solve_steady_state(\n    setup, V₀, p₀;\n    jacobian_type = :newton,\n    npicard = 2,\n    abstol = 1e-10,\n    maxiter = 10,\n)\n\nSolve steady state problem of the Navier-Stokes equations. This saddlepoint system arises from linearization of the convective terms.\n\nEach processor is called after every processor.nupdate iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"save_vtk\nplotgrid\nget_lims\nplotmat","category":"page"},{"location":"api/api/#IncompressibleNavierStokes.save_vtk","page":"API","title":"IncompressibleNavierStokes.save_vtk","text":"save_vtk(setup, u, filename = \"output/solution\"; fieldnames = [:velocity], psolver)\n\nSave velocity and pressure field to a VTK file.\n\nIn the case of a 2D setup, the velocity field is saved as a 3D vector with a z-component of zero, as this seems to be preferred by ParaView.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plotgrid","page":"API","title":"IncompressibleNavierStokes.plotgrid","text":"plotgrid(x...)\n\nPlot nonuniform Cartesian grid.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.get_lims","page":"API","title":"IncompressibleNavierStokes.get_lims","text":"get_lims(x, n = 1.5)\n\nGet approximate lower and upper limits of a field x based on the mean and standard deviation (mu pm n sigma). If x is constant, a margin of 1e-4 is enforced. This is required for contour plotting functions that require a certain range.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#IncompressibleNavierStokes.plotmat","page":"API","title":"IncompressibleNavierStokes.plotmat","text":"plotmat(A)\n\nPlot matrix.\n\n\n\n\n\n","category":"function"},{"location":"features/precision/#Floating-point-precision","page":"Floating point precision","title":"Floating point precision","text":"","category":"section"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"IncompressibleNavierStokes generates efficient code for different floating point precisions, such as","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"Double precision (Float64)\nSingle precision (Float32)\nHalf precision (Float16)","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"To use single or half precision, all user input floats should be converted to the desired type. Mixing different precisions causes unnecessary conversions and may break the code. See the tutorial for an example on how to enforce floating point type hygiene.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: GPU precision\nFor GPUs, single precision is preferred. CUDA.jls cu converts to single precision.","category":"page"},{"location":"features/precision/","page":"Floating point precision","title":"Floating point precision","text":"note: Pressure solvers\nSparseArrays.jls sparse matrix factorizations only support double precision. psolver_direct only works for Float64. Consider using an iterative solver such as psolver_cg when using single or half precision.","category":"page"}]
}
