import{_ as e,c as o,o as i,a6 as s}from"./chunks/framework.B8Zg0AH8.js";const h=JSON.parse('{"title":"Floating point precision","description":"","frontmatter":{},"headers":[],"relativePath":"features/precision.md","filePath":"features/precision.md","lastUpdated":null}'),r={name:"features/precision.md"},t=s('<h1 id="Floating-point-precision" tabindex="-1">Floating point precision <a class="header-anchor" href="#Floating-point-precision" aria-label="Permalink to &quot;Floating point precision {#Floating-point-precision}&quot;">â€‹</a></h1><p>IncompressibleNavierStokes generates efficient code for different floating point precisions, such as</p><ul><li><p>Double precision (<code>Float64</code>)</p></li><li><p>Single precision (<code>Float32</code>)</p></li><li><p>Half precision (<code>Float16</code>)</p></li></ul><p>To use single or half precision, all user input floats should be converted to the desired type. Mixing different precisions causes unnecessary conversions and may break the code. See the <a href="./generated/LidDrivenCavity2D">tutorial</a> for an example on how to enforce floating point type hygiene.</p><div class="tip custom-block"><p class="custom-block-title">GPU precision</p><p>For GPUs, single precision is preferred. <code>CUDA.jl</code>s <code>cu</code> converts to single precision.</p></div><div class="tip custom-block"><p class="custom-block-title">Pressure solvers</p><p><a href="https://github.com/JuliaSparse/SparseArrays.jl" target="_blank" rel="noreferrer"><code>SparseArrays.jl</code></a>s sparse matrix factorizations only support double precision. <a href="/agdestein.github.io/IncompressibleNavierStokes.jl/dev/features/pressure#IncompressibleNavierStokes.psolver_direct"><code>psolver_direct</code></a> only works for <code>Float64</code>. Consider using an iterative solver such as <a href="/agdestein.github.io/IncompressibleNavierStokes.jl/dev/features/pressure#IncompressibleNavierStokes.psolver_cg"><code>psolver_cg</code></a> when using single or half precision.</p></div>',6),a=[t];function n(c,p,l,d,u,f){return i(),o("div",null,a)}const g=e(r,[["render",n]]);export{h as __pageData,g as default};
